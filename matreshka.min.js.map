{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///matreshka.min.js","webpack:///webpack/bootstrap d053e08b9f2d648da17b","webpack:///./src/index.js","webpack:///./src/matreshka/index.js","webpack:///./src/class.js","webpack:///./src/matreshka/_staticmembers.js","webpack:///./src/defaultbinders.js","webpack:///./src/binders/input.js","webpack:///./src/binders/textarea.js","webpack:///./src/binders/select.js","webpack:///./src/binders/progress.js","webpack:///./src/binders/output.js","webpack:///./src/lookforbinder.js","webpack:///./src/parserbrackets.js","webpack:///./src/tomatreshka.js","webpack:///./src/object/index.js","webpack:///./src/object/_prototype.js","webpack:///./src/object/_afterinit.js","webpack:///./src/matreshka/_afterinit.js","webpack:///./src/on/_addlistener.js","webpack:///./src/_core/init.js","webpack:///./src/_core/defs.js","webpack:///./src/trigger/_triggerone.js","webpack:///./src/_helpers/apply.js","webpack:///./src/_core/defineprop.js","webpack:///./src/set.js","webpack:///./src/_helpers/checkobjecttype.js","webpack:///./src/_helpers/matreshkaerror.js","webpack:///./src/_helpers/is.js","webpack:///./src/on/_domeventregexp.js","webpack:///./src/on/_adddomlistener.js","webpack:///./src/_dom/index.js","webpack:///./src/_dom/default-dollar.js","webpack:///./src/_dom/mq/index.js","webpack:///./src/_dom/mq/_init.js","webpack:///./src/_dom/mq/_html2nodelist.js","webpack:///./src/_dom/mq/parsehtml.js","webpack:///./src/_dom/mq/on.js","webpack:///./src/_dom/mq/_data.js","webpack:///./src/_dom/mq/off.js","webpack:///./src/_dom/mq/add.js","webpack:///./src/_helpers/assign.js","webpack:///./src/on/_createdomeventhandler.js","webpack:///./src/object/adddatakeys.js","webpack:///./src/object/removedatakeys.js","webpack:///./src/object/isdatakey.js","webpack:///./src/object/setdata.js","webpack:///./src/object/keyof.js","webpack:///./src/object/keys.js","webpack:///./src/object/values.js","webpack:///./src/object/entries.js","webpack:///./src/object/tojson.js","webpack:///./src/object/each.js","webpack:///./src/object/iterator.js","webpack:///./src/array/index.js","webpack:///./src/array/_prototype.js","webpack:///./src/array/_afterinit.js","webpack:///./src/array/mediateitem.js","webpack:///./src/array/orderby/index.js","webpack:///./src/array/_cheaprecreate.js","webpack:///./src/array/orderby/_pureorderby.js","webpack:///./src/array/_reportmodified.js","webpack:///./src/array/_processrendering/index.js","webpack:///./src/array/_processrendering/processpush.js","webpack:///./src/array/_processrendering/renderitemnode.js","webpack:///./src/parsebindings/index.js","webpack:///./src/parsebindings/_parserdata.js","webpack:///./src/calc/index.js","webpack:///./src/_helpers/debounce.js","webpack:///./src/calc/_addsource.js","webpack:///./src/on/_addtreelistener.js","webpack:///./src/on/_delegatelistener/index.js","webpack:///./src/on/_delegatelistener/arrayaddhandler.js","webpack:///./src/on/_delegatelistener/objectsethandler.js","webpack:///./src/on/_delegatelistener/arrayremovehandler.js","webpack:///./src/off/_undelegatelistener.js","webpack:///./src/off/_removelistener.js","webpack:///./src/off/_removedomlistener.js","webpack:///./src/on/_delegatelistener/objectremovehandler.js","webpack:///./src/on/_delegatelistener/changehandler.js","webpack:///./src/off/_removetreelistener.js","webpack:///./src/calc/_createcalchandler.js","webpack:///./src/_helpers/deepfind.js","webpack:///./src/parsebindings/_processtextnode.js","webpack:///./src/bindnode/index.js","webpack:///./src/bindnode/_getnodes.js","webpack:///./src/bindnode/_selectnodes.js","webpack:///./src/_helpers/toarray.js","webpack:///./src/bindnode/_createbindingswitcher.js","webpack:///./src/unbindnode/index.js","webpack:///./src/unbindnode/_removebinding.js","webpack:///./src/bindnode/_bindsinglenode.js","webpack:///./src/bindnode/_createnodehandler.js","webpack:///./src/bindnode/_createobjecthandler.js","webpack:///./src/parsebindings/_processattribute/index.js","webpack:///./src/parsebindings/_processattribute/_getbindingkey.js","webpack:///./src/parsebindings/_processattribute/_definehiddencontentproperty.js","webpack:///./src/array/_processrendering/checkalreadyrendered.js","webpack:///./src/array/_processrendering/processunshift.js","webpack:///./src/array/_processrendering/processrecreate.js","webpack:///./src/array/_processrendering/getalreadyrendered.js","webpack:///./src/array/_processrendering/processsort.js","webpack:///./src/array/_processrendering/processremove.js","webpack:///./src/array/_processrendering/processrerender.js","webpack:///./src/array/_processrendering/processspliceadd.js","webpack:///./src/array/pull.js","webpack:///./src/array/recreate/index.js","webpack:///./src/array/recreate/_updatetracked.js","webpack:///./src/array/recreate/_updateobject.js","webpack:///./src/array/rerender.js","webpack:///./src/array/restore.js","webpack:///./src/array/tojson.js","webpack:///./src/array/_pseudonativemethods/index.js","webpack:///./src/array/_pseudonativemethods/createpseudonativemethod.js","webpack:///./src/array/_tomatreshkaarray.js","webpack:///./src/array/_pseudonativemethods/createsortingmethod.js","webpack:///./src/array/_pseudonativemethods/createremovingmethod.js","webpack:///./src/array/_pseudonativemethods/createaddingmethod.js","webpack:///./src/array/_pseudonativemethods/createsplice.js","webpack:///./src/array/_pseudonativemethods/createcopywithin.js","webpack:///./src/array/_pseudonativemethods/createfill.js","webpack:///./src/array/_pseudonativemethods/concat.js","webpack:///./src/array/_pseudonativemethods/keys.js","webpack:///./src/array/_pseudonativemethods/values.js","webpack:///./src/array/_pseudonativemethods/entries.js","webpack:///./src/array/iterator.js","webpack:///./src/array/_staticmembers.js","webpack:///./src/array/from.js","webpack:///./src/array/of.js","webpack:///./src/binders/index.js","webpack:///./src/binders/html.js","webpack:///./src/binders/display.js","webpack:///./src/binders/classname.js","webpack:///./src/binders/_classlist.js","webpack:///./src/binders/prop.js","webpack:///./src/binders/attr.js","webpack:///./src/binders/text.js","webpack:///./src/binders/style.js","webpack:///./src/binders/dataset.js","webpack:///./src/matreshka/_universalmethods.js","webpack:///./src/on/index.js","webpack:///./src/on/_splitbyspaceregexp.js","webpack:///./src/once.js","webpack:///./src/off/index.js","webpack:///./src/ondebounce.js","webpack:///./src/trigger/index.js","webpack:///./src/trigger/_triggerdomevent.js","webpack:///./src/trigger/_triggeronedomevent.js","webpack:///./src/bindoptionalnode.js","webpack:///./src/bindsandbox.js","webpack:///./src/select.js","webpack:///./src/selectall.js","webpack:///./src/remove.js","webpack:///./src/instantiate.js","webpack:///./src/mediate.js","webpack:///./src/usedomlibrary.js","webpack:///./src/matreshka/_prototype.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","Matreshka","MatreshkaArray","MatreshkaObject","Object","Array","Class","staticMembers","instanceMembers","initMK","matreshkaError","constructor","prototype","staticProps","_key2","Constructor","hasOwnProperty","Parent","proto","create","parentStaticNames","staticNamesProperty","undefined","_result","_source2","_keys4","keys","_l7","length","_i4","getOwnPropertySymbols","symbol","symbols","_target","_index","_l2","staticNames","name","_","_target2","_keys2","_i2","_l3","_target3","_index2","_l4","key","value","_target4","_keys3","_i3","_l5","_target5","_index3","_l6","Symbol","defaultBinders","lookForBinder","parserBrackers","toMatreshka","_binders","binders","_universalmethods","universalMethods","assign","useDOMLibrary","input","textarea","select","progress","output","node","tagName","type","multiple","on","getValue","checked","setValue","options","result","i","selected","push","givenValue","indexOf","textContent","property","binder","left","right","data","_ret","_ret2","item","arrayItems","index","_l","v","recreate","object","_keys","_i","setData","_afterInit$setData$ad","_afterInit","addDataKeys","removeDataKeys","isDataKey","keyOf","values","entries","toJSON","each","iterator","symbolIterator","isMatreshkaObject","jset","changeDelegatedHandler","eventOptions","arguments","def","defs","get","triggerOne","deleteDelegatedHandler","changeHandler","silent","deleteHandler","afterMatreshkaObjectInit","afterMatreshkaInit","addListener","nodes","$nodes","callback","context","info","_initMK","allEvents","events","ctx","event","_info$skipChecks","skipChecks","domEventExecResult","domEventReg","exec","eventName","_domEventExecResult$","selector","addDomListener","existingEvent","argCallback","_callback","eventCallback","propModEventReg","test","defineProp","replace","props","objectId","set","PseudoMap","obj","matreshkaData","defineProperty","enumerable","writable","configurable","has","WeakMap","triggerArgs","l","latestEvent","apply","func","args","errorAccessor","noAccessor","propDef","mediator","bindings","getter","setter","isMatreshkaArray","fromSetter","isMatreshka","checkObjectType","objKey","objVal","previousValue","_eventOptions","skipMediator","fromMediator","force","forceHTML","silentHTML","skipCalc","newValue","is","_source","_key","isChanged","self","extendedEventOptions","triggerChange","beforechangeStr","beforechangeEventName","changeBindingsEventName","changeStr","changeEventName","changeDepsEventName","changeDelegatedKeyEventName","changeTreeEventName","changeCommonEventName","changeDelegatedEventName","method","typeofObject","getError","errors","Error","bindingErrorPrefix","calcErrorPrefix","eventsErrorPrefix","arrayErrorPrefix","getType","variable","getTypeError","variableName","expectedType","common:object_type","_ref","common:call_class","common:use_magic_props","binding:node_missing","_ref2","selectorInfo","binding:falsy_key","binding:instance_nodes_missing","_ref3","missing","binding:magic_props_nodes_length","calc:target_type","_ref4","target","calc:source_key_type","_ref5","sourceKey","calc:source_object_type","_ref6","sourceObject","calc:source_type","_ref7","source","array:model_type","_ref8","Model","array:add_render_twice","array:rendered_number_nodes","_ref9","array:renderer_node_missing","_ref10","array:nonexistent_method","_ref11","array:method_compat_renderer","_ref12","pull:to_remove_type","_ref13","toRemove","restore:no_nodes","trigger:names_type","_ref14","names","on:names_type","_ref15","removedatakeys:key_type","_ref16","adddatakeys:key_type","_ref17","remove:key_type","_ref18","mediate:key_type","_ref19","isPolyfill","v1","v2","createBindingHandlers","fullEventName","domEventHandler","bindHandler","evt","dom","$","unbindHandler","off","createDomEventHandler","eventNamespace","_createBindingHandler","addBindListenerResult","addUnbindListenerResult","mq","neededMethods","globalDollar","useGlobalDollar","fn","parseHTML","Init","add","MQInit","nodeType","win","html2nodeList","newContext","querySelectorAll","document","window","givenHTML","wrapMap","option","legend","thead","tr","td","col","area","html","createElement","optgroup","tbody","tfoot","colgroup","caption","th","ex","wrapper","innerHTML","children","childNodes","matches","webkitMatchesSelector","mozMatchesSelector","msMatchesSelector","oMatchesSelector","delegateHandler","handler","randomID","Math","random","toString","scopeSelector","splittedSelector","split","matching","sel","setAttribute","removeAttribute","namesStr","splitBySpaceReg","delegate","_names$i$split","splitByDotReg","namespace","j","nodeID","b$","nodeIndex","exist","k","addEventListener","removeEventListener","splice","idMap","TypeError","nextKey","nextValue","domEvent","originalEvent","matreshkaTriggerArgs","which","ctrlKey","altKey","preventDefault","stopPropagation","givenKeys","_this","newKeys","_defineProp","removedKeys","getNotListedKeys","inObject","fromObject","replaceData","notListedKeys","_eventOptions2","_getNotListedKeys","keysArray","keysArr","recursive","thisArg","matreshkaObjectIterator","next","done","dontRender","_assign","mediateItem","orderBy","pull","rerender","restore","pseudoNativeMethods","modelItemMediator","itemData","changeModel","changeItemRendererHandler","_eventOptions$forceRe","forceRerender","afterMatreshkaArrayInit","hasModel","createItemMediator","arr","itemMediator","orders","cheapRecreate","pureOrderBy","added","removed","reportModified","newItems","newLength","oldLength","lengthDiff","defaultOrder","commonOrder","sort","a","b","order","addedLength","removedLength","modified","_defs$get","_self$renderIfPossibl","renderIfPossible","asteriskAddEvtName","asteriskRemoveEvtName","addone","addedItem","remove","removeone","removedItem","modify","processRendering","container","sandbox","selfDef","processPush","processUnshift","processRemove","processSort","processRerender","processRecreate","processSpliceAdd","checkAlreadyRendered","_renderItemNode","renderItemNode","itemEventOptions","appendChild","renderer","_item$bindRenderedAsS","bindRenderedAsSandbox","itemRenderer","usedRenderer","rendererContext","selfId","moveSandbox","itemDef","_itemDef$renderedInAr","renderedInArrays","sandboxPropDef","parentArray","htmlTestReg","trim","getNodes","parsed","parseBindings","unbindNode","bindNode","onRender","onItemRender","givenNodes","useExactBinder","fromParser","setValueOnBind","allNodes","leftBracket","parserData","bindingReg","_loop","ELEMENT_NODE","TEXT_NODE","outerHTML","attributes","attribute","processAttribute","childNode","processTextNode","textNode","calc","parserBrackets","rightBracket","escLeftBracket","escRightBracket","RegExp","strictBindingReg","debounceCalc","sources","givenHandler","itemTarget","_keys5","_i5","itemSource","itemHandler","commonEventOptions","mergedEventOptions","_key4","_result2","_source4","_eventOptions$setOnIn","setOnInit","_eventOptions$debounc","debounceCalcOnInit","_eventOptions$debounc2","_eventOptions$debounc3","debounceCalcDelay","_eventOptions$isTarge","isTargetPropertyHidden","defaultHandler","allSources","syncCalcHandler","createCalcHandler","debouncedCalcHandler","calcHandler","debounce","addSource","sourceKeyItem","givenDelay","timeout","delay","callContext","clearTimeout","setTimeout","_eventOptions$exactKe","exactKey","isDelegated","deepPath","addTreeListener","createTreeListener","restPath","newHandler","changeEvent","extendedChangeEvent","removeTreeListener","listenPath","slice","delegateListener","givenPath","path","pathStr","_end","_j","join","delegatedData","arrayAddHandler","arrayRemoveHandler","objectSetHandler","objectRemoveHandler","defKey","undelegateListener","detatchDelegatedLogic","delegatedEventName","retain","delegatedAddEvtName","delegatedRemoveEvtName","delegatedSetEvtName","delegatedChangeEvtName","removeListener","noTrigger","removeDomListener","allEventsName","allEventsItem","removeEventData","binding","listenedPath","_changeEvent$protecto","protector","protectKey","setEventOptions","deepFind","targetValue","paths","current","_window","lastIndex","token","tokens","fragment","createDocumentFragment","newTextNode","createTextNode","textNodeBinder","insertBefore","removeChild","temporaryOptionalFlag","optional","itemKey","itemNode","itemBinder","_key3","_source3","_key5","_result3","_source5","keyObjKey","keyObjValue","_keys7","_i7","_l10","_keys6","_l8","_i6","_source6","_key6","_result4","keyObjValueItem","_l9","_eventOptions$optiona","deepPathLength","bindingSwitcher","createBindingSwitcher","_object","$allNodes","oneNode","_index4","_l11","bindSingleNode","htmlReg","customSelectorReg","selectNodes","givenSelector","selectors","execResult","boundKey","subSelector","boundNodes","randomAttr","toArray","start","array","lastDeepPathItem","previousTarget","deep","propsKey","propsItem","_target6","removeBinding","nodesItem","retainBindings","retainNodes","_target8","_index6","_l12","_target7","_index5","bindingOptions","nodeHandler","objectHandler","destroy","disabled","evtName","spaceReg","givenBinder","getValueOnBind","debounceSetValue","debounceGetValue","debounceSetValueOnBind","_eventOptions$debounc4","debounceGetValueOnBind","_eventOptions$debounc5","debounceSetValueDelay","_eventOptions$debounc6","debounceGetValueDelay","_eventOptions$useExac","isUndefined","foundBinder","_binder","initialize","syncNodeHandler","createNodeHandler","debouncedNodeHandler","syncObjectHandler","createObjectHandler","debouncedObjectHandler","fromNode","changedNode","onChangeValue","evtBinder","dirtyHackValue","getBindingKey","text","probablyValueInput","probablyCheckableInput","defaultBinder","attributeBinder","defineHiddenContentProperty","hiddenPropertyPrefix","hiddenPropertyIndex","regs","firstChild","alreadyRenderedMap","alreadyRenderedNode","getAlreadyRendered","contains","nextIndex","lastIndexOf","nextNode","shift","pullByValue","pullByIndex","typeofToRemove","givenNewItems","was","trackBy","skipItemMediator","updateTracked","toMediate","newItem","updateObject","trackMap","instance","_renderIfPossible","createPseudoNativeMethod","concat","methods","forEach","hasOptions","arrayPrototype","toMatreshkaArray","originalMethod","separator","searchElement","fromIndex","createSortingMethod","createRemovingMethod","createAddingMethod","createSplice","createCopyWithin","createFill","arrayLike","sortCallback","givenEventOptions","returns","argsLength","useMediator","isPush","arg","functionArguments","originalCopyWithin","copyWithin","originalFill","fill","nativeCallResult","matreshkaArrayIterator","from","of","mapFn","ParentClass","arrayFrom","_arguments","display","className","prop","attr","style","dataset","switcher","getComputedStyle","getPropertyValue","none","elementClassName","toggle","_classlistJs","classList","re","propertyName","e","attributeName","getAttribute","toDashed","replacer","u","toLowerCase","once","onDebounce","trigger","bindOptionalNode","bindSandbox","selectAll","instantiate","mediate","givenNames","triggerOnInit","isNamesVarArray","namesObjName","namesObjCallback","delegatedEventParts","delegatedName","givenCallback","onceCallback","_len","domEvtExecResult","_domEvtExecResult$","triggerDomEvent","triggerDOMEvent","descendant","descendants","triggerOneDOMEvent","Event","createEvent","initEvent","bubbles","cancelable","dispatchEvent","customSelectorTestReg","querySelector","givenKey","prefix","removeEventPrefies","defaultUpdateFunction","createInstantiateMediator","UsedClass","updateFunction","givenUpdateFunction","isKeysArray","createMediator","propMediator","library","MK"],"mappings":"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","file":"matreshka.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Matreshka\"] = factory();\n\telse\n\t\troot[\"Matreshka\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","/* Matreshka 2 */\n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Matreshka\"] = factory();\n\telse\n\t\troot[\"Matreshka\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Matreshka = __webpack_require__(1);\n\t\n\tvar MatreshkaArray = __webpack_require__(52);\n\t\n\tvar MatreshkaObject = __webpack_require__(13);\n\t\n\tMatreshka.Object = MatreshkaObject;\n\tMatreshka.Array = MatreshkaArray;\n\t\n\tmodule.exports = Matreshka;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Class = __webpack_require__(2);\n\t\n\tvar staticMembers = __webpack_require__(3);\n\t\n\tvar instanceMembers = __webpack_require__(154);\n\t\n\tvar initMK = __webpack_require__(18);\n\t\n\tvar matreshkaError = __webpack_require__(25);\n\t\n\tinstanceMembers.constructor = function Matreshka() {\n\t    if (!(this instanceof Matreshka)) {\n\t        throw matreshkaError('common:call_class');\n\t    }\n\t\n\t    initMK(this);\n\t};\n\t\n\tvar Matreshka = Class(instanceMembers, staticMembers);\n\t\n\tmodule.exports = Matreshka;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t// static methods and properties of classes will be hidden under Symbol('staticNames')\n\tvar staticNamesProperty = typeof Symbol === 'function' ? Symbol('staticNames') : '__staticNames';\n\tvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\tmodule.exports = Class;\n\tfunction Class(prototype, staticProps) {\n\t    var Constructor = hasOwnProperty.call(prototype, 'constructor') ? prototype.constructor : function EmptyConstructor() {};\n\t    // extends is kept for backward compatibility\n\t    var Parent = prototype.extends;\n\t    // inherit proto from class parent or empty object\n\t    var proto = Object.create(Parent ? Parent.prototype : {});\n\t    var parentStaticNames = Parent ? Parent[staticNamesProperty] : undefined;\n\t\n\t    // allow to pass symbols as prototype properties\n\t    var _result = proto;\n\t\n\t    for (var _source2 = prototype, _keys4 = Object.keys(_source2), _l7 = _keys4.length, _i4 = 0, _key2; _i4 < _l7; _i4++) {\n\t        _key2 = _keys4[_i4];\n\t        _result[_key2] = _source2[_key2];\n\t    }\n\t\n\t    if (getOwnPropertySymbols) {\n\t        var symbols = getOwnPropertySymbols(prototype);\n\t\n\t        for (var _target = symbols, _index = 0, symbol, _l2 = _target.length; symbol = _target[_index], _index < _l2; _index++) {\n\t            proto[symbol] = prototype[symbol];\n\t        }\n\t    }\n\t\n\t    // inherit staric properties of a parent\n\t    if (typeof parentStaticNames === 'object') {\n\t        (function () {\n\t            var staticNames = Constructor[staticNamesProperty] || {};\n\t            Constructor[staticNamesProperty] = staticNames;\n\t\n\t            // inherit static properties of a parent when their keys are symbols\n\t            for (var _target2 = parentStaticNames, _keys2 = Object.keys(_target2), _i2 = 0, name, _, _l3 = _keys2.length; (name = _keys2[_i2], _ = _target2[name]), _i2 < _l3; _i2++) {\n\t                Constructor[name] = Parent[name];\n\t                staticNames[name] = true;\n\t            }\n\t\n\t            if (getOwnPropertySymbols) {\n\t                var _symbols = getOwnPropertySymbols(parentStaticNames);\n\t\n\t                for (var _target3 = _symbols, _index2 = 0, symbol, _l4 = _target3.length; symbol = _target3[_index2], _index2 < _l4; _index2++) {\n\t                    Constructor[symbol] = Parent[symbol];\n\t                    staticNames[symbol] = true;\n\t                }\n\t            }\n\t        })();\n\t    }\n\t\n\t    // extend Constructor with passed static properties\n\t    if (typeof staticProps === 'object') {\n\t        (function () {\n\t            var staticNames = Constructor[staticNamesProperty] || {};\n\t            Constructor[staticNamesProperty] = staticNames;\n\t\n\t            // extend Constructor with passed static properties if their keys are symbols\n\t            for (var _target4 = staticProps, _keys3 = Object.keys(_target4), _i3 = 0, key, value, _l5 = _keys3.length; (key = _keys3[_i3], value = _target4[key]), _i3 < _l5; _i3++) {\n\t                Constructor[key] = value;\n\t                staticNames[key] = true;\n\t            }\n\t\n\t            if (getOwnPropertySymbols) {\n\t                var _symbols2 = getOwnPropertySymbols(staticProps);\n\t\n\t                for (var _target5 = _symbols2, _index3 = 0, symbol, _l6 = _target5.length; symbol = _target5[_index3], _index3 < _l6; _index3++) {\n\t                    Constructor[symbol] = staticProps[symbol];\n\t                    staticNames[symbol] = true;\n\t                }\n\t            }\n\t        })();\n\t    }\n\t\n\t    Constructor.prototype = proto;\n\t\n\t    // if new Class({}) is called return its instance\n\t    if (this instanceof Class) {\n\t        return new Constructor();\n\t    }\n\t\n\t    return Constructor;\n\t}\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar defaultBinders = __webpack_require__(4);\n\t\n\tvar lookForBinder = __webpack_require__(10);\n\t\n\tvar parserBrackers = __webpack_require__(11);\n\t\n\tvar Class = __webpack_require__(2);\n\t\n\tvar toMatreshka = __webpack_require__(12);\n\t\n\tvar _binders = __webpack_require__(127);\n\t\n\tvar binders = _binders;\n\t\n\tvar _universalmethods = __webpack_require__(137);\n\t\n\tvar universalMethods = _universalmethods;\n\t\n\tvar assign = __webpack_require__(39);\n\t\n\tvar useDOMLibrary = __webpack_require__(153);\n\t\n\tmodule.exports = assign({\n\t    Class: Class,\n\t    defaultBinders: defaultBinders,\n\t    lookForBinder: lookForBinder,\n\t    binders: binders,\n\t    parserBrackers: parserBrackers,\n\t    toMatreshka: toMatreshka,\n\t    useDOMLibrary: useDOMLibrary\n\t}, universalMethods);\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar input = __webpack_require__(5);\n\t\n\tvar textarea = __webpack_require__(6);\n\t\n\tvar select = __webpack_require__(7);\n\t\n\tvar progress = __webpack_require__(8);\n\t\n\tvar output = __webpack_require__(9);\n\t\n\t// defaultBinders collection by default contains only one function-checker\n\tmodule.exports = [function (node) {\n\t    switch (node.tagName) {\n\t        case 'INPUT':\n\t            return input(node.type);\n\t        case 'TEXTAREA':\n\t            return textarea();\n\t        case 'SELECT':\n\t            return select(node.multiple);\n\t        case 'PROGRESS':\n\t            return progress();\n\t        case 'OUTPUT':\n\t            return output();\n\t        default:\n\t            return null;\n\t    }\n\t}];\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t// returns a binder for input element based on its type\n\tmodule.exports = input;\n\tfunction input(type) {\n\t    var on = void 0;\n\t    switch (type) {\n\t        case 'checkbox':\n\t            return {\n\t                on: 'click keyup',\n\t                getValue: function () {\n\t                    return this.checked;\n\t                },\n\t                setValue: function (value) {\n\t                    this.checked = value;\n\t                }\n\t            };\n\t        case 'radio':\n\t            return {\n\t                on: 'click keyup',\n\t                getValue: function () {\n\t                    return this.value;\n\t                },\n\t                setValue: function (value) {\n\t                    this.checked = typeof value !== 'undefined' && this.value === value;\n\t                }\n\t            };\n\t        case 'submit':\n\t        case 'button':\n\t        case 'image':\n\t        case 'reset':\n\t            return {};\n\t        case 'hidden':\n\t            on = null;\n\t            break;\n\t        case 'file':\n\t            on = 'change';\n\t            break;\n\t\n\t        /*\n\t        case 'text':\n\t        case 'password':\n\t        case 'date':\n\t        case 'datetime':\n\t        case 'datetime-local':\n\t        case 'month':\n\t        case 'time':\n\t        case 'week':\n\t        case 'range':\n\t        case 'color':\n\t        case 'search':\n\t        case 'email':\n\t        case 'tel':\n\t        case 'url':\n\t        case 'file':\n\t        case 'number': */\n\t        default:\n\t            // other future (HTML6+) inputs\n\t            on = 'input';\n\t    }\n\t\n\t    return {\n\t        on: on,\n\t        getValue: function () {\n\t            return this.value;\n\t        },\n\t        setValue: function (value) {\n\t            this.value = value;\n\t        }\n\t    };\n\t}\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar input = __webpack_require__(5);\n\t\n\t// returns a binder for textarea element\n\tmodule.exports = textarea;\n\tfunction textarea() {\n\t    // textarea behaves just like text input\n\t    return input('text');\n\t}\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t// returns a binder for select element\n\tmodule.exports = select;\n\tfunction select(multiple) {\n\t    if (multiple) {\n\t        return {\n\t            on: 'change',\n\t            getValue: function () {\n\t                var options = this.options;\n\t\n\t                var result = [];\n\t\n\t                for (var i = 0; options.length > i; i++) {\n\t                    if (options[i].selected) {\n\t                        result.push(options[i].value);\n\t                    }\n\t                }\n\t\n\t                return result;\n\t            },\n\t            setValue: function (givenValue) {\n\t                var options = this.options;\n\t\n\t                var value = typeof givenValue === 'string' ? [givenValue] : givenValue;\n\t                for (var i = options.length - 1; i >= 0; i--) {\n\t                    options[i].selected = ~value.indexOf(options[i].value);\n\t                }\n\t            }\n\t        };\n\t    }\n\t\n\t    return {\n\t        on: 'change',\n\t        getValue: function () {\n\t            return this.value;\n\t        },\n\t        setValue: function (value) {\n\t            this.value = value;\n\t\n\t            if (!value) {\n\t                var options = this.options;\n\t\n\t                for (var i = options.length - 1; i >= 0; i--) {\n\t                    if (!options[i].value) {\n\t                        options[i].selected = true;\n\t                        break;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    };\n\t}\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar input = __webpack_require__(5);\n\t\n\t// returns a binder for textarea element\n\tmodule.exports = progress;\n\tfunction progress() {\n\t    return input();\n\t}\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t// returns a binder for output element\n\tmodule.exports = output;\n\tfunction output() {\n\t    return {\n\t        on: null,\n\t        getValue: function () {\n\t            return this.value || this.textContent;\n\t        },\n\t        setValue: function (value) {\n\t            var property = 'form' in this ? 'value' : 'textContent';\n\t            this[property] = value === null ? '' : '' + value;\n\t        }\n\t    };\n\t}\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar defaultBinders = __webpack_require__(4);\n\t\n\t// tries to find a binder for given node\n\tmodule.exports = lookForBinder;\n\tfunction lookForBinder(node) {\n\t    for (var i = 0; i < defaultBinders.length; i++) {\n\t        var binder = defaultBinders[i].call(node, node);\n\t        if (binder) {\n\t            return binder;\n\t        }\n\t    }\n\t\n\t    return undefined;\n\t}\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t// brackets for bindings parser\n\tmodule.exports = {\n\t    left: '{{',\n\t    right: '}}'\n\t};\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t// recursively converts objects and arrays to Matreshka.Object and Matreshka.Array instances\n\tmodule.exports = toMatreshka;\n\tfunction toMatreshka(data) {\n\t    // fix circular ref issue\n\t    var MatreshkaObject = __webpack_require__(13);\n\t    var MatreshkaArray = __webpack_require__(52);\n\t\n\t    // convert only objects\n\t    if (data && typeof data === 'object') {\n\t        var _ret = function () {\n\t            if ('length' in data) {\n\t                var _ret2 = function () {\n\t                    // if length is given convert it to Matreshka.Array instance\n\t                    var arrayItems = Array(data.length);\n\t\n\t                    for (var _target = data, index = 0, item, _l = _target.length; item = _target[index], index < _l; index++) {\n\t                        arrayItems[index] = toMatreshka(item);\n\t                    }\n\t\n\t                    return {\n\t                        v: {\n\t                            v: new MatreshkaArray().recreate(arrayItems)\n\t                        }\n\t                    };\n\t                }();\n\t\n\t                if (typeof _ret2 === \"object\") return _ret2.v;\n\t            }\n\t\n\t            // if length is not given convert it to Matreshka.Object instance\n\t            var object = {};\n\t\n\t            for (var _target2 = data, _keys = Object.keys(_target2), _i = 0, key, value, _l2 = _keys.length; (key = _keys[_i], value = _target2[key]), _i < _l2; _i++) {\n\t                object[key] = toMatreshka(value);\n\t            }\n\t\n\t            return {\n\t                v: new MatreshkaObject(object)\n\t            };\n\t        }();\n\t\n\t        if (typeof _ret === \"object\") return _ret.v;\n\t    }\n\t\n\t    // for all non-objects just return passed data\n\t    return data;\n\t}\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Class = __webpack_require__(2);\n\t\n\tvar Matreshka = __webpack_require__(1);\n\t\n\tvar instanceMembers = __webpack_require__(14);\n\t\n\tvar matreshkaError = __webpack_require__(25);\n\t\n\tvar initMK = __webpack_require__(18);\n\t\n\tinstanceMembers.extends = Matreshka;\n\t\n\tinstanceMembers.constructor = function MatreshkaObject(data) {\n\t    if (!(this instanceof MatreshkaObject)) {\n\t        throw matreshkaError('common:call_class');\n\t    }\n\t\n\t    initMK(this);\n\t\n\t    // return is used to make possible to chain super() calls\n\t    return typeof data !== 'undefined' ? this.setData(data) : this;\n\t};\n\t\n\tvar MatreshkaObject = Class(instanceMembers);\n\t\n\tmodule.exports = MatreshkaObject;\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _afterInit$setData$ad;\n\t\n\tvar _afterInit = __webpack_require__(15);\n\t\n\tvar addDataKeys = __webpack_require__(41);\n\t\n\tvar removeDataKeys = __webpack_require__(42);\n\t\n\tvar isDataKey = __webpack_require__(43);\n\t\n\tvar setData = __webpack_require__(44);\n\t\n\tvar keyOf = __webpack_require__(45);\n\t\n\tvar keys = __webpack_require__(46);\n\t\n\tvar values = __webpack_require__(47);\n\t\n\tvar entries = __webpack_require__(48);\n\t\n\tvar toJSON = __webpack_require__(49);\n\t\n\tvar each = __webpack_require__(50);\n\t\n\tvar iterator = __webpack_require__(51);\n\t\n\tvar symbolIterator = typeof Symbol === 'function' ? Symbol.iterator : '@@iterator';\n\t\n\tmodule.exports = (_afterInit$setData$ad = {\n\t    _afterInit: _afterInit,\n\t    setData: setData,\n\t    addDataKeys: addDataKeys,\n\t    removeDataKeys: removeDataKeys,\n\t    isDataKey: isDataKey,\n\t    keys: keys,\n\t    values: values,\n\t    entries: entries,\n\t    keyOf: keyOf,\n\t    toJSON: toJSON,\n\t    each: each,\n\t    isMatreshkaObject: true,\n\t    jset: setData }, _afterInit$setData$ad[symbolIterator] = iterator, _afterInit$setData$ad);\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar afterMatreshkaInit = __webpack_require__(16);\n\t\n\tvar addListener = __webpack_require__(17);\n\t\n\tvar triggerOne = __webpack_require__(20);\n\t\n\tvar defs = __webpack_require__(19);\n\t\n\t// called on _change:delegated\n\t// tiggers asterisk events logic by triggering _asterisk:set\n\tfunction changeDelegatedHandler() {\n\t    var eventOptions = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t    var key = eventOptions.key;\n\t\n\t    var def = defs.get(this);\n\t\n\t    if (key && key in def.keys) {\n\t        triggerOne(this, '_asterisk:set', eventOptions);\n\t    }\n\t}\n\t\n\t// called on _delete:delegated\n\t// removes asterisk events logic by triggering _asterisk:remove\n\tfunction deleteDelegatedHandler() {\n\t    var eventOptions = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t    var key = eventOptions.key;\n\t\n\t    var def = defs.get(this);\n\t\n\t    if (key && key in def.keys) {\n\t        triggerOne(this, '_asterisk:remove', eventOptions);\n\t    }\n\t}\n\t\n\t// called on change\n\t// triggers set and modify if data keys are changed\n\tfunction changeHandler() {\n\t    var eventOptions = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t    var key = eventOptions.key;\n\t    var silent = eventOptions.silent;\n\t\n\t    var def = defs.get(this);\n\t\n\t    if (key && key in def.keys && !silent) {\n\t        triggerOne(this, 'set', eventOptions);\n\t        triggerOne(this, 'modify', eventOptions);\n\t    }\n\t}\n\t\n\t// called on delete\n\t// triggers remove and modify if data keys are removed\n\tfunction deleteHandler() {\n\t    var eventOptions = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t    var key = eventOptions.key;\n\t    var silent = eventOptions.silent;\n\t\n\t    var def = defs.get(this);\n\t\n\t    if (key && key in def.keys) {\n\t        delete def.keys[key];\n\t\n\t        if (!silent) {\n\t            triggerOne(this, 'remove', eventOptions);\n\t            triggerOne(this, 'modify', eventOptions);\n\t        }\n\t    }\n\t}\n\t\n\t// Matreshka.Object initializer\n\tmodule.exports = afterMatreshkaObjectInit;\n\tfunction afterMatreshkaObjectInit(def) {\n\t    // Matreshka initializer\n\t    afterMatreshkaInit.call(this);\n\t    // create a set of data keys\n\t    def.keys = {};\n\t\n\t    // trigger asterisk events\n\t    addListener(this, '_change:delegated', changeDelegatedHandler);\n\t\n\t    // trigger asterisk events removal\n\t    addListener(this, '_delete:delegated', deleteDelegatedHandler);\n\t\n\t    // fire \"modify\" and \"set\" events when data key is changed\n\t    addListener(this, 'change', changeHandler);\n\t\n\t    // fire \"modify\" and \"remove\" events when data key is removed\n\t    addListener(this, 'delete', deleteHandler);\n\t}\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\t// Matreshka initializer\n\tmodule.exports = afterMatreshkaInit;\n\tfunction afterMatreshkaInit() {\n\t    this.nodes = {};\n\t    this.$nodes = {};\n\t}\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar initMK = __webpack_require__(18);\n\t\n\tvar triggerOne = __webpack_require__(20);\n\t\n\tvar defineProp = __webpack_require__(22);\n\t\n\tvar domEventReg = __webpack_require__(27);\n\t\n\t// property modifier event regexp\n\tvar propModEventReg // eslint-disable-next-line max-len\n\t= /^_change:deps:|^_change:bindings:|^_change:delegated:|^_change:common:|^_change:tree:|^change:|^beforechange:/;\n\t\n\t// adds simple event listener\n\t// used as core of event engine\n\tmodule.exports = addListener;\n\tfunction addListener(object, name, callback, context) {\n\t    var info = arguments.length <= 4 || arguments[4] === undefined ? {} : arguments[4];\n\t\n\t    var _initMK = initMK(object);\n\t\n\t    var allEvents = _initMK.events;\n\t\n\t    var ctx = context || object;\n\t    var events = allEvents[name];\n\t    var event = { callback: callback, context: context, ctx: ctx, name: name, info: info };\n\t    // skipChecks is used by internal methods for better performance\n\t    var _info$skipChecks = info.skipChecks;\n\t    var skipChecks = _info$skipChecks === undefined ? false : _info$skipChecks;\n\t\n\t\n\t    if (!skipChecks) {\n\t        var domEventExecResult = domEventReg.exec(name);\n\t\n\t        if (domEventExecResult) {\n\t            var eventName = domEventExecResult[1];\n\t            var _domEventExecResult$ = domEventExecResult[2];\n\t            var key = _domEventExecResult$ === undefined ? 'sandbox' : _domEventExecResult$;\n\t            var selector = domEventExecResult[3];\n\t            // fixing circular reference issue\n\t\n\t            var addDomListener = __webpack_require__(28);\n\t\n\t            addDomListener(object, key, eventName, selector, callback, context, info);\n\t\n\t            return true;\n\t        }\n\t    }\n\t\n\t    // if there are events with the same name\n\t    if (events) {\n\t        if (!skipChecks) {\n\t            // if there are events with the same data, return false\n\t            for (var i = 0; i < events.length; i++) {\n\t                var existingEvent = events[i];\n\t                var argCallback = callback && callback._callback || callback;\n\t                var eventCallback = existingEvent.callback._callback || existingEvent.callback;\n\t                if (argCallback === eventCallback && existingEvent.context === context) {\n\t                    return false;\n\t                }\n\t            }\n\t        }\n\t\n\t        // if the event isn't found add it to the event list\n\t        events.push(event);\n\t    } else {\n\t        // if there are no events with the same name, create an array with only  one event\n\t        allEvents[name] = [event];\n\t    }\n\t\n\t    if (propModEventReg.test(name)) {\n\t        // define needed accessors for KEY\n\t        defineProp(object, name.replace(propModEventReg, ''));\n\t    }\n\t\n\t    // names prefixed by underscore mean \"private\" events\n\t    if (!skipChecks && name[0] !== '_') {\n\t        triggerOne(object, 'addevent:' + name, event);\n\t        triggerOne(object, 'addevent', event);\n\t    }\n\t\n\t    // if event is added successfully return true\n\t    return true;\n\t}\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar defs = __webpack_require__(19);\n\t\n\tvar objectId = 0;\n\t\n\t// this is common function which associates an object with its Matreshka definition\n\tmodule.exports = initMK;\n\tfunction initMK(object) {\n\t    var def = defs.get(object);\n\t    if (!def) {\n\t        def = {\n\t            // a property name of \"events\" object is an event name\n\t            // and a value is an array of event handlers\n\t            events: {\n\t                /* example: {\n\t                    callback: function,\n\t                    ctx: object,\n\t                    context: object2,\n\t                    name: \"example\",\n\t                    info: { ...extra data for an event... }\n\t                } */\n\t            },\n\t            // \"props\" contains special information about properties (getters, setters etc)\n\t            props: {\n\t                /* example: {\n\t                    value: object[key],\n\t                    mediator: null,\n\t                    bindings: [{\n\t                        node,\n\t                        binder,\n\t                        nodeHandler,\n\t                        objectHandler,\n\t                        ...other required info\n\t                    }]\n\t                }*/\n\t            },\n\t            id: objectId\n\t        };\n\t\n\t        objectId += 1;\n\t\n\t        defs.set(object, def);\n\t\n\t        if (object._afterInit) {\n\t            object._afterInit(def);\n\t        }\n\t    }\n\t\n\t    return def;\n\t}\n\n/***/ },\n/* 19 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tfunction PseudoMap() {}\n\t\n\t// PseudoMap simulates WeakMap behavior with O(1) search complexity\n\t// it's needed to support @IE9 and @IE10\n\tvar _result = PseudoMap.prototype;\n\t\n\tfor (var _source2 = {\n\t    get: function (obj) {\n\t        return obj.matreshkaData;\n\t    },\n\t    set: function (obj, data) {\n\t        Object.defineProperty(obj, 'matreshkaData', {\n\t            value: data,\n\t            enumerable: false,\n\t            writable: false,\n\t            configurable: false\n\t        });\n\t    },\n\t    has: function (obj) {\n\t        return ('matreshkaData' in obj);\n\t    }\n\t}, _keys2 = Object.keys(_source2), _l2 = _keys2.length, _i2 = 0, _key2; _i2 < _l2; _i2++) {\n\t    _key2 = _keys2[_i2];\n\t    _result[_key2] = _source2[_key2];\n\t}\n\t\n\tmodule.exports = typeof WeakMap === 'undefined' ? new PseudoMap() : new WeakMap();\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar defs = __webpack_require__(19);\n\t\n\tvar apply = __webpack_require__(21);\n\t\n\t// triggers one event\n\tmodule.exports = triggerOne;\n\tfunction triggerOne(object, name, triggerArgs) {\n\t    var def = defs.get(object);\n\t    var events = def && def.events[name];\n\t\n\t    if (events) {\n\t        var l = events.length;\n\t        var i = 0;\n\t\n\t        // allow to pass both array of args and single arg as triggerArgs\n\t        if (triggerArgs instanceof Array) {\n\t            while (i < l) {\n\t                var event = triggerOne.latestEvent = events[i];\n\t                var callback = event.callback;\n\t                var ctx = event.ctx;\n\t\n\t                apply(callback, ctx, triggerArgs);\n\t                i += 1;\n\t            }\n\t        } else {\n\t            while (i < l) {\n\t                var _event = triggerOne.latestEvent = events[i];\n\t                var _callback = _event.callback;\n\t                var _ctx = _event.ctx;\n\t\n\t                _callback.call(_ctx, triggerArgs);\n\t                i += 1;\n\t            }\n\t        }\n\t    }\n\t}\n\t\n\t// latestEvent is used as required hack in somemethods\n\ttriggerOne.latestEvent = {\n\t    info: {},\n\t    name: null\n\t};\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tmodule.exports = apply;\n\tfunction apply(func, context, args) {\n\t    if (context) {\n\t        switch (args.length) {\n\t            case 0:\n\t                return func.call(context);\n\t            case 1:\n\t                return func.call(context, args[0]);\n\t            case 2:\n\t                return func.call(context, args[0], args[1]);\n\t            case 3:\n\t                return func.call(context, args[0], args[1], args[2]);\n\t            case 4:\n\t                return func.call(context, args[0], args[1], args[2], args[3]);\n\t            default:\n\t                return func.apply(context, args); // eslint-disable-line prefer-spread\n\t        }\n\t    }\n\t\n\t    switch (args.length) {\n\t        case 0:\n\t            return func();\n\t        case 1:\n\t            return func(args[0]);\n\t        case 2:\n\t            return func(args[0], args[1]);\n\t        case 3:\n\t            return func(args[0], args[1], args[2]);\n\t        case 4:\n\t            return func(args[0], args[1], args[2], args[3]);\n\t        default:\n\t            return func.apply(undefined, args); // eslint-disable-line prefer-spread\n\t    }\n\t}\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar defs = __webpack_require__(19);\n\t\n\tvar set = __webpack_require__(23);\n\t\n\tvar matreshkaError = __webpack_require__(25);\n\t\n\tfunction errorAccessor() {\n\t    throw matreshkaError('common:use_magic_props');\n\t}\n\t\n\t// the function defines needed descriptor for given property\n\tmodule.exports = defineProp;\n\tfunction defineProp(object, key, noAccessor) {\n\t    var def = defs.get(object);\n\t\n\t    // if no object definition do nothing\n\t    if (!def) {\n\t        return null;\n\t    }\n\t\n\t    if (!def.props[key]) {\n\t        (function () {\n\t            var propDef = def.props[key] = {\n\t                value: object[key],\n\t                mediator: null,\n\t                bindings: null\n\t            };\n\t            var getter = void 0;\n\t            var setter = void 0;\n\t\n\t            // make possible to throw an error on get and on set if sandbox (for all objects)\n\t            // or container (for Matreshka.Array instances) are used\n\t            if (key === 'sandbox' || object.isMatreshkaArray && key === 'container') {\n\t                getter = setter = errorAccessor;\n\t            }\n\t\n\t            if (!noAccessor) {\n\t                Object.defineProperty(object, key, {\n\t                    configurable: true,\n\t                    enumerable: true,\n\t                    get: function () {\n\t                        return getter ? getter() : propDef.value;\n\t                    },\n\t                    set: function (v) {\n\t                        return setter ? setter() : set(object, key, v, {\n\t                            fromSetter: true\n\t                        });\n\t                    }\n\t                });\n\t            }\n\t        })();\n\t    }\n\t\n\t    return def.props[key];\n\t}\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar defs = __webpack_require__(19);\n\t\n\tvar triggerOne = __webpack_require__(20);\n\t\n\tvar checkObjectType = __webpack_require__(24);\n\t\n\tvar is = __webpack_require__(26);\n\t\n\t// the function sets new value for a property\n\t// since its performance is very critical we're checking events existence manually\n\tmodule.exports = set;\n\tfunction set(object, key, value, eventOptions) {\n\t    if (typeof this === 'object' && this.isMatreshka) {\n\t        // when context is Matreshka instance, use this as an object and shift other args\n\t        /* eslint-disable no-param-reassign */\n\t        eventOptions = value;\n\t        value = key;\n\t        key = object;\n\t        object = this;\n\t        /* eslint-enable no-param-reassign */\n\t    } else {\n\t        // throw error when object type is wrong\n\t        checkObjectType(object, 'set');\n\t    }\n\t\n\t    // if no key or falsy key is given\n\t    if (!key) {\n\t        return object;\n\t    }\n\t\n\t    // allow to use key-value object as another method variation\n\t    if (typeof key === 'object') {\n\t        for (var _target = key, _keys = Object.keys(_target), _i = 0, objKey, objVal, _l = _keys.length; (objKey = _keys[_i], objVal = _target[objKey]), _i < _l; _i++) {\n\t            set(object, objKey, objVal, value)\n\t        }\n\t\n\t        return object;\n\t    }\n\t\n\t    eventOptions = eventOptions || {}; // eslint-disable-line no-param-reassign\n\t    var def = defs.get(object);\n\t\n\t    // if no object definition then make simple assignment\n\t    if (!def) {\n\t        object[key] = value;\n\t        return object;\n\t    }\n\t\n\t    var props = def.props;\n\t    var events = def.events;\n\t\n\t    var propDef = props[key];\n\t\n\t    // if no property definition then make simple assignment\n\t    if (!propDef) {\n\t        object[key] = value;\n\t        return object;\n\t    }\n\t\n\t    var previousValue = propDef.value;\n\t    var mediator = propDef.mediator;\n\t\n\t    // possible flags, all of them are falsy by default\n\t\n\t    var _eventOptions = eventOptions;\n\t    var skipMediator = _eventOptions.skipMediator;\n\t    var fromMediator = _eventOptions.fromMediator;\n\t    var force = _eventOptions.force;\n\t    var forceHTML = _eventOptions.forceHTML;\n\t    var silent = _eventOptions.silent;\n\t    var silentHTML = _eventOptions.silentHTML;\n\t    var skipCalc = _eventOptions.skipCalc;\n\t\n\t\n\t    var newValue = void 0;\n\t\n\t    if (mediator && !is(value, previousValue) && !skipMediator && !fromMediator) {\n\t        newValue = mediator(value);\n\t    } else {\n\t        newValue = value;\n\t    }\n\t\n\t    var isChanged = !is(newValue, previousValue);\n\t\n\t    // add to eventOptions object some useful properties\n\t    // we override default eventOptions because some of the properties need to have actual values,\n\t    // not inherited ones (eg when calc is used)\n\t\n\t    var _keys2,\n\t        _l2,\n\t        _i2,\n\t        _source,\n\t        _key,\n\t        _result = {};\n\t\n\t    for (_source = eventOptions, _keys2 = Object.keys(_source), _l2 = _keys2.length, _i2 = 0; _i2 < _l2; _i2++) {\n\t        _key = _keys2[_i2];\n\t        _result[_key] = _source[_key];\n\t    }\n\t\n\t    _result.value = newValue\n\t    _result.self = object\n\t    _result.previousValue = previousValue\n\t    _result.key = key\n\t    _result.isChanged = isChanged\n\t    var extendedEventOptions = _result;\n\t\n\t    var triggerChange = (isChanged || force) && !silent;\n\t\n\t    // trigger beforechange:KEY and beforechange events\n\t    if (triggerChange) {\n\t        var beforechangeStr = 'beforechange';\n\t        var beforechangeEventName = beforechangeStr + ':' + key;\n\t\n\t        if (events[beforechangeEventName]) {\n\t            triggerOne(object, beforechangeEventName, extendedEventOptions);\n\t        }\n\t\n\t        if (events[beforechangeStr]) {\n\t            triggerOne(object, beforechangeStr, extendedEventOptions);\n\t        }\n\t    }\n\t\n\t    propDef.value = newValue;\n\t\n\t    // triger bindings\n\t    if (!silentHTML && (isChanged || forceHTML)) {\n\t        var changeBindingsEventName = '_change:bindings:' + key;\n\t        if (events[changeBindingsEventName]) {\n\t            triggerOne(object, changeBindingsEventName, extendedEventOptions);\n\t        }\n\t    }\n\t\n\t    // trigger change:KEY and change events\n\t    if (triggerChange) {\n\t        var changeStr = 'change';\n\t        var changeEventName = changeStr + ':' + key;\n\t        if (events[changeEventName]) {\n\t            triggerOne(object, changeEventName, extendedEventOptions);\n\t        }\n\t\n\t        if (events[changeStr]) {\n\t            triggerOne(object, changeStr, extendedEventOptions);\n\t        }\n\t    }\n\t\n\t    // trigger dependencies made by calc method\n\t    if ((isChanged || force) && !skipCalc) {\n\t        var changeDepsEventName = '_change:deps:' + key;\n\t        if (events[changeDepsEventName]) {\n\t            triggerOne(object, changeDepsEventName, extendedEventOptions);\n\t        }\n\t    }\n\t\n\t    if (isChanged) {\n\t        // trigger common delegated events logic\n\t        var changeDelegatedKeyEventName = '_change:delegated:' + key;\n\t        if (events[changeDelegatedKeyEventName]) {\n\t            triggerOne(object, changeDelegatedKeyEventName, extendedEventOptions);\n\t        }\n\t\n\t        // trigger tree change events logic\n\t        var changeTreeEventName = '_change:tree:' + key;\n\t        if (events[changeTreeEventName]) {\n\t            triggerOne(object, changeTreeEventName, extendedEventOptions);\n\t        }\n\t\n\t        // trigger other internal change events\n\t        var changeCommonEventName = '_change:common:' + key;\n\t        if (events[changeCommonEventName]) {\n\t            triggerOne(object, changeCommonEventName, extendedEventOptions);\n\t        }\n\t\n\t        // trigger delegated logic for asterisk events (*.*.*@foo)\n\t        // TODO: Confusing events names (\"_change:delegated\", \"_change:common:KEY\" etc)\n\t        var changeDelegatedEventName = '_change:delegated';\n\t        if (events[changeDelegatedEventName]) {\n\t            triggerOne(object, changeDelegatedEventName, extendedEventOptions);\n\t        }\n\t    }\n\t\n\t    return object;\n\t}\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar matreshkaError = __webpack_require__(25);\n\t\n\t// checks type of a variable and throws an error if its type is not an object\n\tmodule.exports = checkObjectType;\n\tfunction checkObjectType(object, method) {\n\t    var typeofObject = object === null ? 'null' : typeof object;\n\t\n\t    if (typeofObject !== 'object' && typeofObject !== 'function') {\n\t        throw matreshkaError('common:object_type', {\n\t            object: object,\n\t            method: method\n\t        });\n\t    }\n\t}\n\n/***/ },\n/* 25 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/* eslint-disable prefer-template, max-len */\n\tvar bindingErrorPrefix = 'Binding error:';\n\tvar calcErrorPrefix = 'Calc error:';\n\tvar eventsErrorPrefix = 'Events error:';\n\tvar arrayErrorPrefix = 'Matreshka.Array error:';\n\t\n\tvar getType = function (variable) {\n\t    if (variable === null) {\n\t        return 'null';\n\t    }\n\t\n\t    return typeof variable;\n\t};\n\tvar getTypeError = function (variable, variableName, expectedType) {\n\t    return variableName + ' must have type \"' + expectedType + '\" but got \"' + getType(variable) + '\" instead.';\n\t};\n\t\n\tvar errors = {\n\t    'common:object_type': function (_ref) {\n\t        var object = _ref.object;\n\t        var method = _ref.method;\n\t        return 'Error in ' + method + ':' + getTypeError(object, 'object', 'object');\n\t    },\n\t    'common:call_class': function () {\n\t        return 'Cannot call a class as a function';\n\t    },\n\t    'common:use_magic_props': function () {\n\t        return '\"sandbox\" key (for all objects) and \"container\" key (for Matreshka.Array instances)' + ' are reserved for service use and cannot be used as usual properties';\n\t    },\n\t\n\t    'binding:node_missing': function (_ref2) {\n\t        var key = _ref2.key;\n\t        var node = _ref2.node;\n\t\n\t        var selectorInfo = typeof node === 'string' ? ' (given selector is \"' + node + '\")' : '';\n\t        return bindingErrorPrefix + ' node is missing for key \"' + key + '\"' + selectorInfo + '.';\n\t    },\n\t    'binding:falsy_key': function () {\n\t        return bindingErrorPrefix + ' \"key\" arg cannot be falsy';\n\t    },\n\t    'binding:instance_nodes_missing': function (_ref3) {\n\t        var $nodes = _ref3.$nodes;\n\t\n\t        var missing = !$nodes ? '$nodes' : 'nodes';\n\t        return bindingErrorPrefix + ' \"' + missing + '\" property of Matreshka instance is missing.' + ' It must be an object and must not be reassigned.';\n\t    },\n\t    'binding:magic_props_nodes_length': function () {\n\t        return bindingErrorPrefix + ' \"sandbox\" key (for all objects) and \"container\" key' + ' (for Matreshka.Array instances) cannot have more than one bound node';\n\t    },\n\t\n\t    'calc:target_type': function (_ref4) {\n\t        var target = _ref4.target;\n\t        return calcErrorPrefix + ' ' + getTypeError(target, 'target key', 'string');\n\t    },\n\t    'calc:source_key_type': function (_ref5) {\n\t        var sourceKey = _ref5.sourceKey;\n\t        return calcErrorPrefix + ' ' + getTypeError(sourceKey, 'source key', 'string');\n\t    },\n\t    'calc:source_object_type': function (_ref6) {\n\t        var sourceObject = _ref6.sourceObject;\n\t        return calcErrorPrefix + ' ' + getTypeError(sourceObject, 'source object', 'object');\n\t    },\n\t    'calc:source_type': function (_ref7) {\n\t        var source = _ref7.source;\n\t        return calcErrorPrefix + ' ' + getTypeError(source, 'source', 'object');\n\t    },\n\t\n\t    'array:model_type': function (_ref8) {\n\t        var Model = _ref8.Model;\n\t        return arrayErrorPrefix + ' ' + getTypeError(Model, 'Model', 'function');\n\t    },\n\t    'array:add_render_twice': function () {\n\t        return arrayErrorPrefix + ' one rendered object was inserted twice.';\n\t    },\n\t    'array:rendered_number_nodes': function (_ref9) {\n\t        var length = _ref9.length;\n\t        return arrayErrorPrefix + ' renderer returned ' + length + ' nodes instead of one.' + (' ' + (length > 0 ? 'To fix this wrap these nodes by single node.' : ''));\n\t    },\n\t    'array:renderer_node_missing': function (_ref10) {\n\t        var selector = _ref10.selector;\n\t        return arrayErrorPrefix + ' renderer node is missing (given selector is \"' + selector + '\")';\n\t    },\n\t    'array:nonexistent_method': function (_ref11) {\n\t        var method = _ref11.method;\n\t        return arrayErrorPrefix + ' Array.prototype.' + method + ' doesn\\'t exist.' + ' You need to include a polyfill for it (e. g. babel-node)';\n\t    },\n\t    'array:method_compat_renderer': function (_ref12) {\n\t        var method = _ref12.method;\n\t        return arrayErrorPrefix + ' Not possible to render when ' + method + ' method is called';\n\t    },\n\t\n\t    'pull:to_remove_type': function (_ref13) {\n\t        var toRemove = _ref13.toRemove;\n\t        return 'Error in pull: ' + getTypeError(toRemove, 'toRemove', 'number');\n\t    },\n\t\n\t    'restore:no_nodes': function () {\n\t        return arrayErrorPrefix + ' cannot find any container to restore an instance using \"restore\" method';\n\t    },\n\t\n\t    'trigger:names_type': function (_ref14) {\n\t        var names = _ref14.names;\n\t        return eventsErrorPrefix + ' ' + getTypeError(names, 'event name', 'string');\n\t    },\n\t\n\t    'on:names_type': function (_ref15) {\n\t        var names = _ref15.names;\n\t        return errors['trigger:names_type']({ names: names });\n\t    },\n\t\n\t    'removedatakeys:key_type': function (_ref16) {\n\t        var key = _ref16.key;\n\t        return 'Error in removeDataKeys: ' + getTypeError(key, 'key', 'string');\n\t    },\n\t\n\t    'adddatakeys:key_type': function (_ref17) {\n\t        var key = _ref17.key;\n\t        return 'Error in addDataKeys: ' + getTypeError(key, 'key', 'string');\n\t    },\n\t\n\t    'remove:key_type': function (_ref18) {\n\t        var key = _ref18.key;\n\t        return 'Error in remove: ' + getTypeError(key, 'key', 'string');\n\t    },\n\t\n\t    'mediate:key_type': function (_ref19) {\n\t        var key = _ref19.key;\n\t        return 'Error in mediate: ' + getTypeError(key, 'key', 'string');\n\t    }\n\t};\n\t\n\tmodule.exports = matreshkaError;\n\tfunction matreshkaError(key, data) {\n\t    var getError = errors[key];\n\t    if (!getError) {\n\t        throw Error('Unknown error \"' + key + '\". Please report about this on Github.');\n\t    }\n\t\n\t    return new Error(getError(data));\n\t}\n\n/***/ },\n/* 26 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\t// determines whether two values are the same value\n\t/* istanbul ignore next */\n\t// eslint-disable-next-line\n\tvar isPolyfill = function (v1, v2) {\n\t  return v1 === 0 && v2 === 0 ? 1 / v1 === 1 / v2 : v1 !== v1 && v2 !== v2 || v1 === v2;\n\t};\n\t\n\tmodule.exports = Object.is || isPolyfill;\n\n/***/ },\n/* 27 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\t// the regexp allows to parse things like \"click::x(.y)\"\n\t// it's shared between few modules\n\tmodule.exports = /([^::]+)::([^\\(\\)]+)?(?:\\((.*)\\))?/;\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar initMK = __webpack_require__(18);\n\t\n\tvar defineProp = __webpack_require__(22);\n\t\n\tvar addListener = __webpack_require__(17);\n\t\n\tvar dom = __webpack_require__(29);\n\t\n\tvar createDomEventHandler = __webpack_require__(40);\n\t\n\t// returns an object with event handlers used at addDomListener\n\tfunction createBindingHandlers(_ref) {\n\t    var fullEventName = _ref.fullEventName;\n\t    var domEventHandler = _ref.domEventHandler;\n\t    var selector = _ref.selector;\n\t\n\t    return {\n\t        bindHandler: function () {\n\t            var evt = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t            var node = evt.node;\n\t\n\t            if (node) {\n\t                dom.$(node).on(fullEventName, selector, domEventHandler);\n\t            }\n\t        },\n\t        unbindHandler: function () {\n\t            var evt = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t            var node = evt.node;\n\t\n\t            if (node) {\n\t                dom.$(node).off(fullEventName, selector, domEventHandler);\n\t            }\n\t        }\n\t    };\n\t}\n\t\n\t// adds DOM event listener for nodes bound to given property\n\tmodule.exports = addDomListener;\n\tfunction addDomListener(object, key, eventName, selector, callback, context, info) {\n\t    var def = initMK(object);\n\t    var propDef = defineProp(object, key);\n\t\n\t    var domEventHandler = createDomEventHandler({\n\t        key: key,\n\t        object: object,\n\t        callback: callback,\n\t        context: context || object\n\t    });\n\t\n\t    // making possible to remove this event listener\n\t    domEventHandler._callback = callback;\n\t\n\t    var eventNamespace = def.id + key;\n\t    var fullEventName = eventName + '.' + eventNamespace;\n\t\n\t    var _createBindingHandler = createBindingHandlers({\n\t        fullEventName: fullEventName,\n\t        domEventHandler: domEventHandler,\n\t        selector: selector\n\t    });\n\t\n\t    var bindHandler = _createBindingHandler.bindHandler;\n\t    var unbindHandler = _createBindingHandler.unbindHandler;\n\t\n\t    var addBindListenerResult = addListener(object, 'bind:' + key, bindHandler, context, info);\n\t    var addUnbindListenerResult = addListener(object, 'unbind:' + key, unbindHandler, context, info);\n\t\n\t    // if events are added successfully then run bindHandler for every node immediately\n\t    // TODO: Describe why do we need addBindListenerResult and addUnbindListenerResult\n\t    if (addBindListenerResult && addUnbindListenerResult) {\n\t        var bindings = propDef.bindings;\n\t\n\t        if (bindings) {\n\t            for (var _target = bindings, _index = 0, _ref2, _l = _target.length; _ref2 = _target[_index], _index < _l; _index++) {\n\t                var node = _ref2.node;\n\t                return bindHandler({ node: node });\n\t            }\n\t        }\n\t    }\n\t\n\t    return object;\n\t}\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar $ = __webpack_require__(30);\n\t\n\tmodule.exports = { $: $ };\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar mq = __webpack_require__(31);\n\t\n\t// check existence of needed methods in $ global variable\n\t// to use it for internal needs\n\t\n\tvar neededMethods = ['on', 'off', 'add']; /* global $ */\n\t\n\t\n\tvar globalDollar = typeof $ === 'function' ? $ : null;\n\tvar useGlobalDollar = true;\n\t\n\t/* istanbul ignore if */\n\tif (globalDollar) {\n\t    var fn = globalDollar.fn || globalDollar.prototype;\n\t    for (var i = 0; i < neededMethods.length; i++) {\n\t        if (!fn[neededMethods[i]]) {\n\t            useGlobalDollar = false;\n\t            break;\n\t        }\n\t    }\n\t\n\t    if (!globalDollar.parseHTML) {\n\t        // Zepto doesn't include its own parseHTML\n\t        // TODO: Assignment of parseHTML is side effect\n\t        globalDollar.parseHTML = mq.parseHTML;\n\t    }\n\t} else {\n\t    useGlobalDollar = false;\n\t}\n\t\n\tmodule.exports = useGlobalDollar ? globalDollar : mq;\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Init = __webpack_require__(32);\n\t\n\tvar parseHTML = __webpack_require__(34);\n\t\n\tvar on = __webpack_require__(35);\n\t\n\tvar off = __webpack_require__(37);\n\t\n\tvar add = __webpack_require__(38);\n\t\n\tvar assign = __webpack_require__(39);\n\t\n\t// tiny jQuery replacement for Matreshka\n\t// mq previously called balalaika.js\n\tmodule.exports = mq;\n\tfunction mq(selector, context) {\n\t    return new Init(selector, context);\n\t}\n\t\n\tmq.parseHTML = parseHTML;\n\t\n\tassign(Init.prototype, {\n\t    on: on,\n\t    off: off,\n\t    add: add\n\t});\n\n/***/ },\n/* 32 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar html2nodeList = __webpack_require__(33);\n\t\n\tvar win = window;\n\t\n\t// function-constructor of mq library\n\t// accepts many kinds of arguments (selector, html, function)\n\tfunction MQInit(selector, context) {\n\t    var result = void 0;\n\t\n\t    if (selector) {\n\t        if (selector.nodeType || typeof win === 'object' && selector === win) {\n\t            result = [selector];\n\t        } else if (typeof selector === 'string') {\n\t            if (/</.test(selector)) {\n\t                result = html2nodeList(selector);\n\t            } else if (context) {\n\t                var newContext = new MQInit(context)[0];\n\t\n\t                if (newContext) {\n\t                    result = newContext.querySelectorAll(selector);\n\t                }\n\t            } else {\n\t                result = win.document.querySelectorAll(selector);\n\t            }\n\t        } else if ('length' in selector) {\n\t            // if it's something array-like (eg NodeList)\n\t            result = selector;\n\t        } else {\n\t            // this is somethong another (eg Attr)\n\t            result = [selector];\n\t        }\n\t    }\n\t\n\t    var length = result && result.length;\n\t\n\t    if (length) {\n\t        for (var i = 0; i < length; i++) {\n\t            this.push(result[i]);\n\t        }\n\t    }\n\t}\n\t\n\tMQInit.prototype = [];\n\t\n\tmodule.exports = MQInit;\n\n/***/ },\n/* 33 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t// converts HTML string to NodeList instance\n\tmodule.exports = html2nodeList;\n\tfunction html2nodeList(givenHTML) {\n\t    // wrapMap is taken from jQuery\n\t    var wrapMap = {\n\t        option: [1, '<select multiple=\"multiple\">', '</select>'],\n\t        legend: [1, '<fieldset>', '</fieldset>'],\n\t        thead: [1, '<table>', '</table>'],\n\t        tr: [2, '<table><tbody>', '</tbody></table>'],\n\t        td: [3, '<table><tbody><tr>', '</tr></tbody></table>'],\n\t        col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],\n\t        area: [1, '<map>', '</map>'],\n\t        _: [0, '', '']\n\t    };\n\t\n\t    var html = givenHTML.replace(/^\\s+|\\s+$/g, '');\n\t    var node = window.document.createElement('div');\n\t    var i = void 0;\n\t\n\t    wrapMap.optgroup = wrapMap.option;\n\t    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\n\t    wrapMap.th = wrapMap.td;\n\t\n\t    var ex = /<([\\w:]+)/.exec(html);\n\t    var wrapper = ex && wrapMap[ex[1]] || wrapMap._;\n\t\n\t    node.innerHTML = wrapper[1] + html + wrapper[2];\n\t\n\t    i = wrapper[0];\n\t\n\t    while (i) {\n\t        i -= 1;\n\t        node = node.children[0];\n\t    }\n\t\n\t    return node.childNodes;\n\t}\n\n/***/ },\n/* 34 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar html2nodeList = __webpack_require__(33);\n\t\n\tvar Init = __webpack_require__(32);\n\t\n\t// parses given HTML and returns mq instance\n\tmodule.exports = parseHTML;\n\tfunction parseHTML(html) {\n\t    return new Init(html2nodeList(html));\n\t}\n\n/***/ },\n/* 35 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar data = __webpack_require__(36);\n\t\n\tvar splitBySpaceReg = /\\s+/;\n\tvar splitByDotReg = /\\.(.+)/;\n\t\n\t// checks an element against a selector\n\tfunction is(node, selector) {\n\t    return (node.matches || node.webkitMatchesSelector || node.mozMatchesSelector || node.msMatchesSelector || node.oMatchesSelector).call(node, selector);\n\t}\n\t\n\t// the function is used when a selector is given\n\tfunction delegateHandler(evt, selector, handler) {\n\t    var randomID = Math.random().toString().replace('0.', 'x');\n\t    var scopeSelector = '[' + randomID + '=\"' + randomID + '\"] ';\n\t    var splittedSelector = selector.split(',');\n\t\n\t    var matching = '';\n\t\n\t    for (var i = 0; i < splittedSelector.length; i++) {\n\t        var sel = splittedSelector[i];\n\t        matching += '' + (i === 0 ? '' : ',') + scopeSelector + sel + ',' + scopeSelector + sel + ' *';\n\t    }\n\t\n\t    this.setAttribute(randomID, randomID);\n\t\n\t    if (is(evt.target, matching)) {\n\t        handler.call(this, evt);\n\t    }\n\t\n\t    this.removeAttribute(randomID);\n\t}\n\t\n\t// adds event listener to a set of elemnts\n\tmodule.exports = on;\n\tfunction on(namesStr, selector, handler) {\n\t    var names = namesStr.split(splitBySpaceReg);\n\t    var delegate = void 0;\n\t\n\t    if (typeof selector === 'function') {\n\t        handler = selector; // eslint-disable-line no-param-reassign\n\t        selector = null; // eslint-disable-line no-param-reassign\n\t    }\n\t\n\t    if (selector) {\n\t        delegate = function uniqueDelegateHandler(evt) {\n\t            delegateHandler.call(this, evt, selector, handler);\n\t        };\n\t    }\n\t\n\t    for (var i = 0; i < names.length; i++) {\n\t        var _names$i$split = names[i].split(splitByDotReg);\n\t\n\t        var name = _names$i$split[0];\n\t        var namespace = _names$i$split[1];\n\t\n\t\n\t        for (var j = 0; j < this.length; j++) {\n\t            var node = this[j];\n\t            var nodeID = node.b$ = node.b$ || ++data.nodeIndex; // eslint-disable-line no-plusplus\n\t            var events = data.allEvents[name + nodeID] = data.allEvents[name + nodeID] || [];\n\t\n\t            var exist = false;\n\t\n\t            for (var k = 0; k < events.length; k++) {\n\t                var event = events[k];\n\t\n\t                if (handler === event.handler && (!selector || selector === event.selector)) {\n\t                    exist = true;\n\t                    break;\n\t                }\n\t            }\n\t\n\t            if (!exist) {\n\t                events.push({\n\t                    delegate: delegate,\n\t                    handler: handler,\n\t                    namespace: namespace,\n\t                    selector: selector\n\t                });\n\t\n\t                node.addEventListener(name, delegate || handler, false);\n\t            }\n\t        }\n\t    }\n\t\n\t    return this;\n\t}\n\n/***/ },\n/* 36 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\t// an object allows to share data between modules; it's needed because we use\n\t// simplified ES modules there and cannot import and share a number\n\tmodule.exports = {\n\t    nodeIndex: 0,\n\t    allEvents: {}\n\t};\n\n/***/ },\n/* 37 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar data = __webpack_require__(36);\n\t\n\tvar splitBySpaceReg = /\\s+/;\n\tvar splitByDotReg = /\\.(.+)/;\n\t\n\t// removes event handler from a set of elements\n\tmodule.exports = off;\n\tfunction off(namesStr, selector, handler) {\n\t    if (typeof selector === 'function') {\n\t        handler = selector; // eslint-disable-line no-param-reassign\n\t        selector = null; // eslint-disable-line no-param-reassign\n\t    }\n\t\n\t    var names = namesStr.split(splitBySpaceReg);\n\t\n\t    for (var i = 0; i < names.length; i++) {\n\t        var _names$i$split = names[i].split(splitByDotReg);\n\t\n\t        var name = _names$i$split[0];\n\t        var namespace = _names$i$split[1];\n\t\n\t\n\t        for (var j = 0; j < this.length; j++) {\n\t            var node = this[j];\n\t            var events = data.allEvents[name + node.b$];\n\t\n\t            if (events) {\n\t                for (var k = 0; k < events.length; k++) {\n\t                    var event = events[k];\n\t                    if ((!handler || handler === event.handler || handler === event.delegate) && (!namespace || namespace === event.namespace) && (!selector || selector === event.selector)) {\n\t                        node.removeEventListener(name, event.delegate || event.handler);\n\t                        events.splice(k, 1);\n\t                        k -= 1;\n\t                    }\n\t                }\n\t            } else if (!namespace && !selector) {\n\t                node.removeEventListener(name, handler);\n\t            }\n\t        }\n\t    }\n\t\n\t    return this;\n\t}\n\n/***/ },\n/* 38 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Init = __webpack_require__(32);\n\t\n\tvar data = __webpack_require__(36);\n\t\n\t// adds unique nodes to mq collection\n\tmodule.exports = add;\n\tfunction add(selector) {\n\t    var idMap = {};\n\t\n\t    var result = void 0;\n\t\n\t    var nodes = new Init(selector);\n\t\n\t    if (this.length) {\n\t        result = new Init();\n\t        for (var i = 0; i < this.length; i++) {\n\t            var node = this[i];\n\t            var nodeID = node.b$ = node.b$ || ++data.nodeIndex; // eslint-disable-line no-plusplus\n\t            idMap[nodeID] = 1;\n\t            result.push(node);\n\t        }\n\t\n\t        for (var _i = 0; _i < nodes.length; _i++) {\n\t            var _node = nodes[_i];\n\t            var _nodeID = _node.b$ = _node.b$ || ++data.nodeIndex; // eslint-disable-line no-plusplus\n\t            if (!idMap[_nodeID]) {\n\t                idMap[_nodeID] = 1;\n\t                result.push(_node);\n\t            }\n\t        }\n\t    } else {\n\t        result = nodes;\n\t    }\n\t\n\t    return result;\n\t}\n\n/***/ },\n/* 39 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t// Object.assign polyfyll\n\t/* istanbul ignore next */\n\tvar assign = Object.assign || function assign(target) {\n\t    /* istanbul ignore next */\n\t    if (target === undefined || target === null) {\n\t        throw new TypeError('Cannot convert undefined or null to object');\n\t    }\n\t\n\t    var output = Object(target);\n\t\n\t    for (var index = 1; index < arguments.length; index++) {\n\t        var source = arguments[index];\n\t        if (source !== undefined && source !== null) {\n\t            for (var _target = source, _keys = Object.keys(_target), _i = 0, nextKey, nextValue, _l = _keys.length; (nextKey = _keys[_i], nextValue = _target[nextKey]), _i < _l; _i++) {\n\t                output[nextKey] = nextValue;\n\t            }\n\t        }\n\t    }\n\t\n\t    return output;\n\t};\n\t\n\tmodule.exports = assign;\n\n/***/ },\n/* 40 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar apply = __webpack_require__(21);\n\t\n\t// returns DOM event handler\n\tmodule.exports = createDomEventHandler;\n\tfunction createDomEventHandler(_ref) {\n\t    var key = _ref.key;\n\t    var object = _ref.object;\n\t    var callback = _ref.callback;\n\t    var context = _ref.context;\n\t\n\t    return function domEventHandler(domEvent) {\n\t        var originalEvent = domEvent.originalEvent || domEvent;\n\t        // matreshkaTriggerArgs are created when DOM event is triggered by trigger method\n\t        var triggerArgs = originalEvent.matreshkaTriggerArgs;\n\t        var which = domEvent.which;\n\t        var target = domEvent.target;\n\t        var ctrlKey = domEvent.ctrlKey;\n\t        var altKey = domEvent.altKey;\n\t\n\t\n\t        if (triggerArgs) {\n\t            // if args are passed to trigger method then pass them to an event handler\n\t            apply(callback, context, triggerArgs);\n\t        } else {\n\t            // use the following object as an arg for event handler\n\t            callback.call(context, {\n\t                self: object,\n\t                node: this,\n\t                preventDefault: function () {\n\t                    return domEvent.preventDefault();\n\t                },\n\t                stopPropagation: function () {\n\t                    return domEvent.stopPropagation();\n\t                },\n\t                key: key,\n\t                domEvent: domEvent,\n\t                originalEvent: originalEvent,\n\t                which: which,\n\t                target: target,\n\t                ctrlKey: ctrlKey,\n\t                altKey: altKey\n\t            });\n\t        }\n\t    };\n\t}\n\n/***/ },\n/* 41 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar initMK = __webpack_require__(18);\n\t\n\tvar defineProp = __webpack_require__(22);\n\t\n\tvar matreshkaError = __webpack_require__(25);\n\t\n\tvar triggerOne = __webpack_require__(20);\n\t\n\t// adds keys to a list of data keys\n\tmodule.exports = addDataKeys;\n\tfunction addDataKeys(givenKeys) {\n\t    var _this = this;\n\t\n\t    var _initMK = initMK(this);\n\t\n\t    var keys = _initMK.keys;\n\t\n\t\n\t    var newKeys = void 0;\n\t\n\t    // accept an array keys or a list of args\n\t    if (givenKeys instanceof Array) {\n\t        newKeys = givenKeys;\n\t    } else {\n\t        newKeys = arguments;\n\t    }\n\t\n\t    for (var _target = newKeys, _index = 0, key, _l = _target.length; key = _target[_index], _index < _l; _index++) {\n\t        if (typeof key !== 'string') {\n\t            throw matreshkaError('adddatakeys:key_type', { key: key });\n\t        }\n\t\n\t        // if key is not in a list of keys\n\t        if (!(key in keys)) {\n\t            // define descriptors for this property\n\t            var _defineProp = defineProp(_this, key);\n\t\n\t            var value = _defineProp.value;\n\t\n\t            var eventOptions = { key: key, value: value };\n\t\n\t            // add a key to the list of keys\n\t            keys[key] = true;\n\t\n\t            // trigger events which say that data is changed\n\t            triggerOne(_this, 'set', eventOptions);\n\t            triggerOne(_this, 'modify', eventOptions);\n\t        }\n\t    }\n\t\n\t    return this;\n\t}\n\n/***/ },\n/* 42 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar defs = __webpack_require__(19);\n\t\n\tvar triggerOne = __webpack_require__(20);\n\t\n\tvar matreshkaError = __webpack_require__(25);\n\t\n\t// removes given keys from a list of data keys\n\tmodule.exports = removeDataKeys;\n\tfunction removeDataKeys(givenKeys) {\n\t    var _this = this;\n\t\n\t    var def = defs.get(this);\n\t\n\t    /* istanbul ignore if */\n\t    if (!def) {\n\t        return this;\n\t    }\n\t\n\t    var keys = def.keys;\n\t\n\t    var removedKeys = void 0;\n\t\n\t    // accept an array keys or a list of args\n\t    if (givenKeys instanceof Array) {\n\t        removedKeys = givenKeys;\n\t    } else {\n\t        removedKeys = arguments;\n\t    }\n\t\n\t    for (var _target = removedKeys, _index = 0, key, _l = _target.length; key = _target[_index], _index < _l; _index++) {\n\t        if (typeof key !== 'string') {\n\t            throw matreshkaError('removedatakeys:key_type', { key: key });\n\t        }\n\t\n\t        if (key in keys) {\n\t            var eventOptions = {\n\t                key: key,\n\t                value: _this[key]\n\t            };\n\t\n\t            delete keys[key];\n\t\n\t            // fire \"modify\" and \"remove\" events\n\t            triggerOne(_this, 'modify', eventOptions);\n\t            triggerOne(_this, 'remove', eventOptions);\n\t        }\n\t    }\n\t\n\t    return this;\n\t}\n\n/***/ },\n/* 43 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar defs = __webpack_require__(19);\n\t\n\t// checks is a key present in data keys list\n\tmodule.exports = isDataKey;\n\tfunction isDataKey(key) {\n\t    var def = defs.get(this);\n\t\n\t    /* istanbul ignore if */\n\t    if (!def) {\n\t        return false;\n\t    }\n\t\n\t    return key in def.keys;\n\t}\n\n/***/ },\n/* 44 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar initMK = __webpack_require__(18);\n\t\n\tvar defineProp = __webpack_require__(22);\n\t\n\tvar set = __webpack_require__(23);\n\t\n\t// returns an array of keys listed at inObject but not listed at fromObject\n\tfunction getNotListedKeys(inObject, fromObject) {\n\t    var result = [];\n\t\n\t    for (var _target = inObject, _keys = Object.keys(_target), _i = 0, key, _, _l = _keys.length; (key = _keys[_i], _ = _target[key]), _i < _l; _i++) {\n\t        if (!(key in fromObject)) {\n\t            result.push(key);\n\t        }\n\t    }\n\t\n\t    return result;\n\t}\n\t\n\t// changes property value and adds given key to a list of data keys\n\tmodule.exports = setData;\n\tfunction setData(key, value, eventOptions) {\n\t    var _this = this;\n\t\n\t    // if no key or falsy key is given\n\t    if (!key) {\n\t        return this;\n\t    }\n\t\n\t    var _initMK = initMK(this);\n\t\n\t    var keys = _initMK.keys;\n\t\n\t    // allow to pass key-value object\n\t\n\t    if (typeof key === 'object') {\n\t        var _ret = function () {\n\t            eventOptions = value || {}; // eslint-disable-line no-param-reassign\n\t\n\t            var _eventOptions = eventOptions;\n\t            var replaceData = _eventOptions.replaceData;\n\t\n\t            // do not call setData recursivally for better performance\n\t\n\t            for (var _target2 = key, _keys2 = Object.keys(_target2), _i2 = 0, objKey, objVal, _l2 = _keys2.length; (objKey = _keys2[_i2], objVal = _target2[objKey]), _i2 < _l2; _i2++) {\n\t                // remove data keys not listed at key-value object\n\t                if (replaceData) {\n\t                    var notListedKeys = getNotListedKeys(keys, key);\n\t\n\t                    if (notListedKeys.length) {\n\t                        _this.removeDataKeys(notListedKeys);\n\t                    }\n\t                }\n\t\n\t                // define descriptors for given property\n\t                defineProp(_this, objKey);\n\t\n\t                // add a key to a list of keys\n\t                keys[objKey] = 1;\n\t\n\t                // do other things with set method\n\t                set(_this, objKey, objVal, eventOptions);\n\t            }\n\t\n\t            return {\n\t                v: _this\n\t            };\n\t        }();\n\t\n\t        if (typeof _ret === \"object\") return _ret.v;\n\t    }\n\t\n\t    eventOptions = eventOptions || {}; // eslint-disable-line no-param-reassign\n\t\n\t    var _eventOptions2 = eventOptions;\n\t    var replaceData = _eventOptions2.replaceData;\n\t\n\t    // remove all data keys except given key\n\t\n\t    if (replaceData) {\n\t        var _getNotListedKeys;\n\t\n\t        var notListedKeys = getNotListedKeys(keys, (_getNotListedKeys = {}, _getNotListedKeys[key] = true, _getNotListedKeys));\n\t\n\t        if (notListedKeys.length) {\n\t            this.removeDataKeys(notListedKeys);\n\t        }\n\t    }\n\t\n\t    // define descriptors for given property\n\t    defineProp(this, key);\n\t\n\t    // add a key to a list of keys\n\t    keys[key] = 1;\n\t\n\t    // do other things with set method\n\t    return set(this, key, value, eventOptions);\n\t}\n\n/***/ },\n/* 45 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar defs = __webpack_require__(19);\n\t\n\t// iterates over data keys looking for a property with given value\n\t// and returns a key of found property\n\tmodule.exports = keyOf;\n\tfunction keyOf(value) {\n\t    var def = defs.get(this);\n\t\n\t    /* istanbul ignore if */\n\t    if (!def) {\n\t        return null;\n\t    }\n\t\n\t    var keysArray = Object.keys(def.keys);\n\t\n\t    for (var i = 0; i < keysArray.length; i++) {\n\t        var key = keysArray[i];\n\t        if (this[key] === value) {\n\t            return key;\n\t        }\n\t    }\n\t\n\t    return null;\n\t}\n\n/***/ },\n/* 46 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar defs = __webpack_require__(19);\n\t\n\t// returns an array which contains all data keys\n\tmodule.exports = keys;\n\tfunction keys() {\n\t    var def = defs.get(this);\n\t\n\t    /* istanbul ignore if */\n\t    if (!def) {\n\t        return [];\n\t    }\n\t\n\t    return Object.keys(def.keys);\n\t}\n\n/***/ },\n/* 47 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar defs = __webpack_require__(19);\n\t\n\t// returns an array which contains all data values\n\tmodule.exports = keys;\n\tfunction keys() {\n\t    var def = defs.get(this);\n\t\n\t    /* istanbul ignore if */\n\t    if (!def) {\n\t        return [];\n\t    }\n\t\n\t    var keysArr = Object.keys(def.keys);\n\t    var length = keysArr.length;\n\t\n\t    var result = new Array(length);\n\t\n\t    for (var i = 0; i < keysArr.length; i++) {\n\t        result[i] = this[keysArr[i]];\n\t    }\n\t\n\t    return result;\n\t}\n\n/***/ },\n/* 48 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar defs = __webpack_require__(19);\n\t\n\t// returns an array which contains things like [key, value]\n\tmodule.exports = keys;\n\tfunction keys() {\n\t    var def = defs.get(this);\n\t\n\t    /* istanbul ignore if */\n\t    if (!def) {\n\t        return [];\n\t    }\n\t\n\t    var keysArr = Object.keys(def.keys);\n\t    var length = keysArr.length;\n\t\n\t    var result = new Array(length);\n\t\n\t    for (var i = 0; i < keysArr.length; i++) {\n\t        var key = keysArr[i];\n\t        result[i] = [key, this[key]];\n\t    }\n\t\n\t    return result;\n\t}\n\n/***/ },\n/* 49 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar initMK = __webpack_require__(18);\n\t\n\t// converts Matreshka.Object instance to ordinary object\n\tmodule.exports = toJSON;\n\tfunction toJSON() {\n\t    var _this = this;\n\t\n\t    var recursive = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];\n\t\n\t    var _initMK = initMK(this);\n\t\n\t    var keys = _initMK.keys;\n\t\n\t    var result = {};\n\t\n\t    for (var _target = keys, _keys = Object.keys(_target), _i = 0, key, _, _l = _keys.length; (key = _keys[_i], _ = _target[key]), _i < _l; _i++) {\n\t        var value = _this[key];\n\t        // when recursive is true and when value has toJSON method then call it recusively\n\t        if (recursive && value && typeof value.toJSON === 'function') {\n\t            result[key] = value.toJSON(true);\n\t        } else {\n\t            result[key] = value;\n\t        }\n\t    }\n\t\n\t    return result;\n\t}\n\n/***/ },\n/* 50 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar defs = __webpack_require__(19);\n\t\n\t// iterates over data keys and calls callback on every iteration\n\t// @IE for..of is preferable and the method will be removed in one of major versions\n\tmodule.exports = each;\n\tfunction each(callback, thisArg) {\n\t    var _this = this;\n\t\n\t    var def = defs.get(this);\n\t    var ctx = typeof thisArg !== 'undefined' ? thisArg : this;\n\t\n\t    /* istanbul ignore if */\n\t    if (!def) {\n\t        return this;\n\t    }\n\t\n\t    for (var _target = def.keys, _keys = Object.keys(_target), _i = 0, key, _, _l = _keys.length; (key = _keys[_i], _ = _target[key]), _i < _l; _i++) {\n\t        callback.call(ctx, _this[key], key, _this);\n\t    }\n\t\n\t    return this;\n\t}\n\n/***/ },\n/* 51 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\t// Symbol.iterator of Matreshka.Object instances\n\tmodule.exports = matreshkaObjectIterator;\n\tfunction matreshkaObjectIterator() {\n\t    var _this = this;\n\t\n\t    var keys = this.keys();\n\t    var i = 0;\n\t\n\t    return {\n\t        next: function () {\n\t            if (i > keys.length - 1) {\n\t                return { done: true };\n\t            }\n\t\n\t            return {\n\t                done: false,\n\t                value: _this[keys[i++]] // eslint-disable-line no-plusplus\n\t            };\n\t        }\n\t    };\n\t}\n\n/***/ },\n/* 52 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Class = __webpack_require__(2);\n\t\n\tvar Matreshka = __webpack_require__(1);\n\t\n\tvar instanceMembers = __webpack_require__(53);\n\t\n\tvar matreshkaError = __webpack_require__(25);\n\t\n\tvar initMK = __webpack_require__(18);\n\t\n\tvar staticMembers = __webpack_require__(124);\n\t\n\tinstanceMembers.extends = Matreshka;\n\t\n\tinstanceMembers.constructor = function MatreshkaArray(length) {\n\t    if (!(this instanceof MatreshkaArray)) {\n\t        throw matreshkaError('common:call_class');\n\t    }\n\t\n\t    initMK(this);\n\t\n\t    // repeat the same logic as for native Array\n\t    if (arguments.length === 1 && typeof length === 'number') {\n\t        this.length = length;\n\t    } else if (arguments.length) {\n\t        this.recreate(arguments, {\n\t            silent: true,\n\t            dontRender: true\n\t        });\n\t    }\n\t\n\t    // return is used to make possible to chain super() calls\n\t    return this;\n\t};\n\t\n\tvar MatreshkaArray = Class(instanceMembers, staticMembers);\n\t\n\tmodule.exports = MatreshkaArray;\n\n/***/ },\n/* 53 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _assign;\n\t\n\tvar assign = __webpack_require__(39);\n\t\n\tvar _afterInit = __webpack_require__(54);\n\t\n\tvar mediateItem = __webpack_require__(55);\n\t\n\tvar orderBy = __webpack_require__(56);\n\t\n\tvar pull = __webpack_require__(103);\n\t\n\tvar recreate = __webpack_require__(104);\n\t\n\tvar rerender = __webpack_require__(107);\n\t\n\tvar restore = __webpack_require__(108);\n\t\n\tvar toJSON = __webpack_require__(109);\n\t\n\tvar pseudoNativeMethods = __webpack_require__(110);\n\t\n\tvar iterator = __webpack_require__(123);\n\t\n\tvar symbolIterator = typeof Symbol === 'function' ? Symbol.iterator : '@@iterator';\n\t\n\tmodule.exports = assign((_assign = {\n\t    _afterInit: _afterInit,\n\t    mediateItem: mediateItem,\n\t    orderBy: orderBy,\n\t    pull: pull,\n\t    recreate: recreate,\n\t    rerender: rerender,\n\t    restore: restore,\n\t    toJSON: toJSON,\n\t    length: 0,\n\t    isMatreshkaArray: true\n\t}, _assign[symbolIterator] = iterator, _assign), pseudoNativeMethods);\n\n/***/ },\n/* 54 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar afterMatreshkaInit = __webpack_require__(16);\n\t\n\tvar addListener = __webpack_require__(17);\n\t\n\tvar matreshkaError = __webpack_require__(25);\n\t\n\t// the function returns array item converted to Model instance\n\tfunction modelItemMediator(item, index) {\n\t    var Model = this.Model;\n\t\n\t    // if an item is already instance of Model\n\t\n\t    if (item instanceof Model) {\n\t        return item;\n\t    }\n\t\n\t    var itemData = void 0;\n\t\n\t    if (item && typeof item.toJSON === 'function') {\n\t        // if item is not falsy and if it has toJSON method\n\t        // then retrieve instance data by this method\n\t        itemData = item.toJSON(false);\n\t    } else {\n\t        // if not then use an item as its data\n\t        itemData = item;\n\t    }\n\t\n\t    return new Model(itemData, this, index);\n\t}\n\t\n\t// event handler to listen changes of Model property\n\tfunction changeModel() {\n\t    var Model = this.Model;\n\t\n\t    // if model has wrong type then throw an error\n\t\n\t    if (typeof Model !== 'function') {\n\t        throw matreshkaError('array:model_type', { Model: Model });\n\t    }\n\t\n\t    // attatch item mediator\n\t    this.mediateItem(modelItemMediator);\n\t}\n\t\n\t// event handler to listen changes of itemRenderer property\n\tfunction changeItemRendererHandler() {\n\t    var eventOptions = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t    var _eventOptions$forceRe = eventOptions.forceRerender;\n\t    var forceRerender = _eventOptions$forceRe === undefined ? true : _eventOptions$forceRe;\n\t\n\t    this.rerender({ forceRerender: forceRerender });\n\t}\n\t\n\t// Matreshka.Array initializer\n\tmodule.exports = afterMatreshkaArrayInit;\n\tfunction afterMatreshkaArrayInit() {\n\t    // we need to calculate hasModel before change:Model is added\n\t    var hasModel = 'Model' in this;\n\t\n\t    // call Matreshka initializer\n\t    afterMatreshkaInit.call(this);\n\t\n\t    addListener(this, '_change:common:Model', changeModel, this, {\n\t        skipChecks: true\n\t    });\n\t\n\t    addListener(this, '_change:common:itemRenderer', changeItemRendererHandler, this, {\n\t        skipChecks: true\n\t    });\n\t\n\t    // call changeModel handler immediately if model is present\n\t    // it will throw an error if Model is not a function\n\t    if (hasModel) {\n\t        changeModel.call(this);\n\t    }\n\t}\n\n/***/ },\n/* 55 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar initMK = __webpack_require__(18);\n\t\n\t// creates item mediator\n\tfunction createItemMediator(_ref) {\n\t    var arr = _ref.arr;\n\t    var mediator = _ref.mediator;\n\t\n\t    return function itemMediator(value, index) {\n\t        // args: value, old value, index, array itself\n\t        return mediator.call(arr, value, index, arr);\n\t    };\n\t}\n\t\n\t// defines a \"type\" of every array item\n\tmodule.exports = mediateItem;\n\tfunction mediateItem(mediator) {\n\t    var def = initMK(this);\n\t    var length = this.length;\n\t\n\t    // store itemMediator in object definition\n\t\n\t    var itemMediator = def.itemMediator = createItemMediator({\n\t        arr: this,\n\t        mediator: mediator\n\t    });\n\t\n\t    // convert existing items\n\t    for (var i = 0; i < length; i++) {\n\t        this[i] = itemMediator(this[i], i);\n\t    }\n\t\n\t    return this;\n\t}\n\n/***/ },\n/* 56 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar cheapRecreate = __webpack_require__(57);\n\t\n\tvar pureOrderBy = __webpack_require__(58);\n\t\n\tvar reportModified = __webpack_require__(59);\n\t\n\t// sorts by properties of items\n\tmodule.exports = orderBy;\n\tfunction orderBy(keys, orders) {\n\t    var eventOptions = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\t\n\t    if (this.length > 1) {\n\t        cheapRecreate(this, pureOrderBy(this, keys, orders));\n\t\n\t        var _keys,\n\t            _l,\n\t            _i,\n\t            _source,\n\t            _key,\n\t            _result = {};\n\t\n\t        _result.method = 'sort'\n\t        _result.self = this\n\t        _result.added = []\n\t        _result.removed = []\n\t\n\t        for (_source = eventOptions, _keys = Object.keys(_source), _l = _keys.length, _i = 0; _i < _l; _i++) {\n\t            _key = _keys[_i];\n\t            _result[_key] = _source[_key];\n\t        }\n\t\n\t        reportModified(this, _result);\n\t    }\n\t\n\t    return this;\n\t}\n\n/***/ },\n/* 57 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\t// makes cheap array recreation (with no trackBy, with no events, with no item mediator etc)\n\tmodule.exports = cheapRecreate;\n\tfunction cheapRecreate(self) {\n\t    var newItems = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n\t\n\t    var newLength = newItems.length;\n\t    var oldLength = self.length;\n\t    var lengthDiff = newLength - oldLength;\n\t\n\t    for (var i = 0; i < newLength; i++) {\n\t        self[i] = newItems[i];\n\t    }\n\t\n\t    for (var _i = 0; _i < lengthDiff; _i++) {\n\t        delete self[_i + newLength];\n\t    }\n\t\n\t    self.length = newLength;\n\t\n\t    return self;\n\t}\n\n/***/ },\n/* 58 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t// the function orders by given order data any array-like object\n\tmodule.exports = pureOrderBy;\n\tfunction pureOrderBy(arr, givenKeys, orders) {\n\t    if ('length' in arr && typeof arr === 'object') {\n\t        var _ret = function () {\n\t            var defaultOrder = 'asc';\n\t            var commonOrder = void 0;\n\t\n\t            if (!(orders instanceof Array)) {\n\t                commonOrder = orders || defaultOrder;\n\t            }\n\t\n\t            var length = arr.length;\n\t\n\t            var result = Array(length);\n\t\n\t            for (var i = 0; i < length; i++) {\n\t                result[i] = arr[i];\n\t            }\n\t\n\t            if (!givenKeys) {\n\t                return {\n\t                    v: result\n\t                };\n\t            }\n\t\n\t            var keys = givenKeys instanceof Array ? givenKeys : [givenKeys];\n\t\n\t            return {\n\t                v: result.sort(function (a, b) {\n\t                    if (a && b) {\n\t                        for (var _i = 0; _i < keys.length; _i++) {\n\t                            var key = keys[_i];\n\t                            var order = (commonOrder || orders[_i]) !== 'desc' ? -1 : 1;\n\t\n\t                            if (a[key] > b[key]) {\n\t                                return -order;\n\t                            } else if (a[key] < b[key]) {\n\t                                return order;\n\t                            }\n\t                        }\n\t                    }\n\t\n\t                    return 0;\n\t                })\n\t            };\n\t        }();\n\t\n\t        if (typeof _ret === \"object\") return _ret.v;\n\t    }\n\t\n\t    return [];\n\t}\n\n/***/ },\n/* 59 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar defs = __webpack_require__(19);\n\t\n\tvar triggerOne = __webpack_require__(20);\n\t\n\tvar processRendering = __webpack_require__(60);\n\t\n\t// fires events and triggers rendering logic\n\tmodule.exports = reportModified;\n\tfunction reportModified(self, eventOptions) {\n\t    var added = eventOptions.added;\n\t    var removed = eventOptions.removed;\n\t    var silent = eventOptions.silent;\n\t    var method = eventOptions.method;\n\t    var dontRender = eventOptions.dontRender;\n\t\n\t    var addedLength = added.length;\n\t    var removedLength = removed.length;\n\t    var modified = addedLength || removedLength || method === 'sort' || method === 'reverse';\n\t\n\t    var _defs$get = defs.get(self);\n\t\n\t    var events = _defs$get.events;\n\t    var _self$renderIfPossibl = self.renderIfPossible;\n\t    var renderIfPossible = _self$renderIfPossibl === undefined ? true : _self$renderIfPossibl;\n\t\n\t    var asteriskAddEvtName = '_asterisk:add';\n\t    var asteriskRemoveEvtName = '_asterisk:remove';\n\t\n\t    // if something is added and an array has delegated \"asterisk\" events\n\t    // then attatch delegated event handlers to newly added items\n\t    if (addedLength && events[asteriskAddEvtName]) {\n\t        triggerOne(self, asteriskAddEvtName, eventOptions);\n\t    }\n\t\n\t    // if something is removed and an array has delegated \"asterisk\" events\n\t    // then remove delegated event handlers from removed items\n\t    if (removedLength && events[asteriskRemoveEvtName]) {\n\t        triggerOne(self, asteriskRemoveEvtName, eventOptions);\n\t    }\n\t\n\t    if (!silent) {\n\t        // fire additional event name (like \"push\")\n\t        if (events[method]) {\n\t            triggerOne(self, method, eventOptions);\n\t        }\n\t\n\t        // if something is added then fire add and addone events\n\t        if (addedLength) {\n\t            if (events.add) {\n\t                triggerOne(self, 'add', eventOptions);\n\t            }\n\t\n\t            if (events.addone) {\n\t                for (var i = 0; i < addedLength; i++) {\n\t                    triggerOne(self, 'addone', {\n\t                        self: self,\n\t                        addedItem: added[i]\n\t                    });\n\t                }\n\t            }\n\t        }\n\t\n\t        // if something is removed then fire add and addone events\n\t        if (removedLength) {\n\t            if (events.remove) {\n\t                triggerOne(self, 'remove', eventOptions);\n\t            }\n\t\n\t            if (events.removeone) {\n\t                for (var _i = 0; _i < removedLength; _i++) {\n\t                    triggerOne(self, 'removeone', {\n\t                        self: self,\n\t                        removedItem: removed[_i]\n\t                    });\n\t                }\n\t            }\n\t        }\n\t\n\t        // modify event says that something is added or removed\n\t        if (events.modify) {\n\t            triggerOne(self, 'modify', eventOptions);\n\t        }\n\t    }\n\t\n\t    // trigger rendering logic if possible\n\t    if (modified && !dontRender && renderIfPossible) {\n\t        processRendering({\n\t            self: self,\n\t            eventOptions: eventOptions\n\t        });\n\t    }\n\t}\n\n/***/ },\n/* 60 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar defs = __webpack_require__(19);\n\t\n\tvar matreshkaError = __webpack_require__(25);\n\t\n\tvar processPush = __webpack_require__(61);\n\t\n\tvar processUnshift = __webpack_require__(96);\n\t\n\tvar processRecreate = __webpack_require__(97);\n\t\n\tvar processSort = __webpack_require__(99);\n\t\n\tvar processRemove = __webpack_require__(100);\n\t\n\tvar processRerender = __webpack_require__(101);\n\t\n\tvar processSpliceAdd = __webpack_require__(102);\n\t\n\t// makes possible to render array items based on a name of called method\n\tmodule.exports = processRendering;\n\tfunction processRendering(_ref) {\n\t    var self = _ref.self;\n\t    var eventOptions = _ref.eventOptions;\n\t    var method = eventOptions.method;\n\t    var added = eventOptions.added;\n\t    var removed = eventOptions.removed;\n\t    // nodes object always exist at Matreshka instances\n\t\n\t    var container = self.nodes.container || self.nodes.sandbox;\n\t    var selfDef = defs.get(self);\n\t\n\t    if (!container) {\n\t        return;\n\t    }\n\t\n\t    switch (method) {\n\t        case 'fill':\n\t        case 'copyWithin':\n\t            throw matreshkaError('array:method_compat_renderer', { method: method });\n\t        case 'push':\n\t            processPush({\n\t                self: self,\n\t                selfDef: selfDef,\n\t                eventOptions: eventOptions,\n\t                container: container\n\t            });\n\t            break;\n\t        case 'unshift':\n\t            processUnshift({\n\t                self: self,\n\t                selfDef: selfDef,\n\t                eventOptions: eventOptions,\n\t                container: container\n\t            });\n\t            break;\n\t        case 'pull':\n\t        case 'pop':\n\t        case 'shift':\n\t            processRemove({\n\t                self: self,\n\t                selfDef: selfDef,\n\t                eventOptions: eventOptions,\n\t                container: container\n\t            });\n\t            break;\n\t        case 'sort':\n\t        case 'reverse':\n\t            processSort({\n\t                self: self,\n\t                selfDef: selfDef,\n\t                eventOptions: eventOptions,\n\t                container: container\n\t            });\n\t            break;\n\t        case 'rerender':\n\t            processRerender({\n\t                self: self,\n\t                selfDef: selfDef,\n\t                eventOptions: eventOptions,\n\t                container: container\n\t            });\n\t            break;\n\t        case 'recreate':\n\t            processRecreate({\n\t                self: self,\n\t                selfDef: selfDef,\n\t                eventOptions: eventOptions,\n\t                container: container\n\t            });\n\t            break;\n\t        case 'splice':\n\t            if (added.length) {\n\t                processSpliceAdd({\n\t                    self: self,\n\t                    selfDef: selfDef,\n\t                    eventOptions: eventOptions,\n\t                    container: container\n\t                });\n\t            }\n\t\n\t            if (removed.length) {\n\t                processRemove({\n\t                    self: self,\n\t                    selfDef: selfDef,\n\t                    eventOptions: eventOptions,\n\t                    container: container\n\t                });\n\t            }\n\t\n\t            break;\n\t        default:\n\t            return;\n\t    }\n\t}\n\n/***/ },\n/* 61 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar renderItemNode = __webpack_require__(62);\n\t\n\tvar triggerOne = __webpack_require__(20);\n\t\n\tvar checkAlreadyRendered = __webpack_require__(95);\n\t\n\t// this function renders inserted items if possible when push method is called\n\tmodule.exports = processPush;\n\tfunction processPush(_ref) {\n\t    var self = _ref.self;\n\t    var selfDef = _ref.selfDef;\n\t    var eventOptions = _ref.eventOptions;\n\t    var container = _ref.container;\n\t    var added = eventOptions.added;\n\t    var silent = eventOptions.silent;\n\t\n\t    for (var _target = added, _index = 0, item, _l = _target.length; item = _target[_index], _index < _l; _index++) {\n\t        if (item && typeof item === 'object') {\n\t            // if a node of an item is already rendered then throw an error\n\t            checkAlreadyRendered({\n\t                item: item,\n\t                selfDef: selfDef\n\t            });\n\t\n\t            // render\n\t\n\t            var _renderItemNode = renderItemNode({\n\t                selfDef: selfDef,\n\t                self: self,\n\t                item: item,\n\t                eventOptions: eventOptions\n\t            });\n\t\n\t            var node = _renderItemNode.node;\n\t            var itemEventOptions = _renderItemNode.itemEventOptions;\n\t\n\t\n\t            if (node) {\n\t                container.appendChild(node);\n\t                if (!silent) {\n\t                    triggerOne(item, 'afterrender', itemEventOptions);\n\t                }\n\t            }\n\t        }\n\t    }\n\t}\n\n/***/ },\n/* 62 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar parseBindings = __webpack_require__(63);\n\t\n\tvar bindNode = __webpack_require__(82);\n\t\n\tvar unbindNode = __webpack_require__(87);\n\t\n\tvar triggerOne = __webpack_require__(20);\n\t\n\tvar initMK = __webpack_require__(18);\n\t\n\tvar matreshkaError = __webpack_require__(25);\n\t\n\tvar getNodes = __webpack_require__(83);\n\t\n\tvar htmlTestReg = /</;\n\t\n\t// the function makes the main rendering job\n\t// it renders given array item\n\tmodule.exports = renderItemNode;\n\tfunction renderItemNode(_ref) {\n\t    var selfDef = _ref.selfDef;\n\t    var self = _ref.self;\n\t    var item = _ref.item;\n\t    var eventOptions = _ref.eventOptions;\n\t    var renderer = item.renderer;\n\t    var _item$bindRenderedAsS = item.bindRenderedAsSandbox;\n\t    var bindRenderedAsSandbox = _item$bindRenderedAsS === undefined ? true : _item$bindRenderedAsS;\n\t    var itemRenderer = self.itemRenderer;\n\t\n\t    var usedRenderer = renderer || itemRenderer;\n\t    var rendererContext = usedRenderer === renderer ? item : self;\n\t    var selfId = selfDef.id;\n\t    var moveSandbox = eventOptions.moveSandbox;\n\t    var forceRerender = eventOptions.forceRerender;\n\t    var silent = eventOptions.silent;\n\t\n\t    // if renderer is not found return null as a node\n\t\n\t    if (!usedRenderer) {\n\t        return { node: null };\n\t    }\n\t\n\t    var itemDef = initMK(item);\n\t    var _itemDef$renderedInAr = itemDef.renderedInArrays;\n\t    var renderedInArrays = _itemDef$renderedInAr === undefined ? {} : _itemDef$renderedInAr;\n\t\n\t    // if moveSandbox option is truthy then return a sandbox of an item\n\t\n\t    if (moveSandbox) {\n\t        var sandboxPropDef = itemDef.props.sandbox;\n\t        if (sandboxPropDef) {\n\t            var bindings = sandboxPropDef.bindings;\n\t\n\t            var _node = bindings ? bindings[0].node : null;\n\t\n\t            if (_node) {\n\t                for (var i = 0, keys = Object.keys(renderedInArrays); i < keys.length; i++) {\n\t                    var key = keys[i];\n\t\n\t                    if (_node === renderedInArrays[key]) {\n\t                        // delete an information about previous array\n\t                        delete renderedInArrays[key];\n\t                        break;\n\t                    }\n\t                }\n\t\n\t                renderedInArrays[selfId] = _node;\n\t\n\t                // moving sandbox does not fire \"render\" event but it fire \"afterrender\"\n\t                // since \"afterrender\" means \"node is inserted to DOM\"\n\t                return {\n\t                    node: _node,\n\t                    itemEventOptions: {\n\t                        node: _node,\n\t                        self: item,\n\t                        parentArray: self\n\t                    }\n\t                };\n\t            }\n\t        }\n\t    }\n\t\n\t    itemDef.renderedInArrays = renderedInArrays;\n\t\n\t    // if usedRenderer is function then call it\n\t    if (typeof usedRenderer === 'function') {\n\t        usedRenderer = usedRenderer.call(rendererContext, item);\n\t    }\n\t\n\t    // if usedRenderer is string\n\t    if (typeof usedRenderer === 'string') {\n\t        if (!htmlTestReg.test(usedRenderer)) {\n\t            // if usedRenderer is a selector\n\t            var selector = usedRenderer;\n\t\n\t            usedRenderer = getNodes(self, selector);\n\t\n\t            if (usedRenderer.length) {\n\t                // if a node is found by given selector then use its HTML\n\t                usedRenderer = usedRenderer[0].innerHTML.trim();\n\t            } else {\n\t                // if not throw an error\n\t                throw matreshkaError('array:renderer_node_missing', { selector: selector });\n\t            }\n\t        } else {\n\t            // if usedRenderer is HTML string\n\t            usedRenderer = usedRenderer.trim();\n\t        }\n\t    }\n\t\n\t    // pass a node or HTML\n\t    var parsed = parseBindings(item, usedRenderer, eventOptions);\n\t\n\t    // if parseBindings returned more/less than one node then throw an error\n\t    if (parsed.length !== 1) {\n\t        throw matreshkaError('array:rendered_number_nodes', { length: parsed.length });\n\t    }\n\t\n\t    var node = renderedInArrays[selfId] = parsed[0];\n\t\n\t    if (bindRenderedAsSandbox) {\n\t        if (forceRerender) {\n\t            unbindNode(item, 'sandbox', null, null, eventOptions);\n\t        }\n\t\n\t        bindNode(item, 'sandbox', node, null, eventOptions);\n\t    }\n\t\n\t    // if silent is not truthy then fire 'render' event and virtual methods\n\t    if (!silent) {\n\t        var itemEventOptions = {\n\t            node: node,\n\t            self: item,\n\t            parentArray: self\n\t        };\n\t        var onRender = item.onRender;\n\t        var onItemRender = self.onItemRender;\n\t\n\t\n\t        if (onRender) {\n\t            onRender.call(item, itemEventOptions);\n\t        }\n\t\n\t        if (onItemRender) {\n\t            onItemRender.call(self, item, itemEventOptions);\n\t        }\n\t\n\t        triggerOne(item, 'render', itemEventOptions);\n\t\n\t        return { node: node, itemEventOptions: itemEventOptions };\n\t    }\n\t\n\t    return { node: node };\n\t}\n\n/***/ },\n/* 63 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar checkObjectType = __webpack_require__(24);\n\t\n\tvar dom = __webpack_require__(29);\n\t\n\tvar parserData = __webpack_require__(64);\n\t\n\tvar processTextNode = __webpack_require__(81);\n\t\n\tvar processAttribute = __webpack_require__(92);\n\t\n\tvar getNodes = __webpack_require__(83);\n\t\n\t// makes parsing of given node (node, $(nodes), selector, HTML)\n\t// and initializes bindings for attributes and text nodes which contain things like {{foo}}\n\tmodule.exports = parseBindings;\n\tfunction parseBindings(object, givenNodes, eventOptions) {\n\t    if (typeof this === 'object' && this.isMatreshka) {\n\t        // when context is Matreshka instance, use this as an object and shift other args\n\t        /* eslint-disable no-param-reassign */\n\t        eventOptions = givenNodes;\n\t        givenNodes = object;\n\t        object = this;\n\t        /* eslint-enable no-param-reassign */\n\t    } else {\n\t        // throw error when object type is wrong\n\t        checkObjectType(object, 'parseBindings');\n\t    }\n\t\n\t    var extendedEventOptions = {\n\t        // useExactBinder is little optimization\n\t        // without this option used binder is extended by default binder\n\t        useExactBinder: true,\n\t        fromParser: true,\n\t        setValueOnBind: true\n\t    };\n\t\n\t    if (typeof eventOptions === 'object') {\n\t        var _result = extendedEventOptions;\n\t\n\t        for (var _source2 = eventOptions, _keys2 = Object.keys(_source2), _l2 = _keys2.length, _i2 = 0, _key2; _i2 < _l2; _i2++) {\n\t            _key2 = _keys2[_i2];\n\t            _result[_key2] = _source2[_key2];\n\t        }\n\t    }\n\t\n\t    var nodes = void 0;\n\t    var allNodes = [];\n\t    // extract all needed data from parserData\n\t    // check out what is parserData in its module\n\t    var leftBracket = parserData.leftBracket;\n\t    var bindingReg = parserData.bindingReg;\n\t\n\t\n\t    if (typeof givenNodes === 'string') {\n\t        if (~givenNodes.indexOf('<')) {\n\t            // this is HTML\n\t            nodes = dom.$.parseHTML(givenNodes);\n\t            if (!~givenNodes.indexOf(leftBracket)) {\n\t                // if it doesn't include parser bracket then we don't need to check\n\t                // their existence for all included nodes in cycle below\n\t                return nodes;\n\t            }\n\t        } else {\n\t            // this is a selector\n\t            nodes = getNodes(object, givenNodes);\n\t        }\n\t    } else if (typeof givenNodes === 'object') {\n\t        // this is a node, nodeList or something else (eg array, jQuery instance etc)\n\t        nodes = dom.$(givenNodes);\n\t    }\n\t\n\t    // to make possible to not use recursion we're collecting all nodes to allNodes array\n\t\n\t    // on every cycle of array we're adding new descendants to allNodes\n\t    // increasing # of needed iterations\n\t    for (var _target = nodes, _index = 0, node, _l3 = _target.length; node = _target[_index], _index < _l3; _index++) {\n\t        allNodes.push(node)\n\t    }\n\t\n\t    var _loop = function (i) {\n\t        var node = allNodes[i];\n\t        var ELEMENT_NODE = 1;\n\t        var TEXT_NODE = 3;\n\t\n\t        // allow to parse elements only\n\t        if (node.nodeType !== ELEMENT_NODE) {\n\t            return 'continue';\n\t        }\n\t\n\t        var outerHTML = node.outerHTML;\n\t        var innerHTML = node.innerHTML;\n\t        var childNodes = node.childNodes;\n\t        var attributes = node.attributes;\n\t\n\t        // if outerHTML does't contain left bracket, then this node doesn't need to be parsed\n\t        // we may need to check outerHTML existence for older browsers\n\t        // we may need to add !~outerHTML.indexOf(encodeURI(leftBracket) to support old FF\n\t\n\t        if (!~outerHTML.indexOf(leftBracket)) {\n\t            return 'continue';\n\t        }\n\t\n\t        // initialize bindings for attributes if they appear\n\t        if (attributes.length) {\n\t            for (var _target2 = attributes, _index2 = 0, attribute, _l4 = _target2.length; attribute = _target2[_index2], _index2 < _l4; _index2++) {\n\t                if (bindingReg.test(attribute.value)) {\n\t                    processAttribute({\n\t                        node: node,\n\t                        attribute: attribute,\n\t                        object: object,\n\t                        eventOptions: extendedEventOptions\n\t                    });\n\t                }\n\t            }\n\t        }\n\t\n\t        // if innerHTML does't contain left bracket,\n\t        // then children of this node don't need to be parsed\n\t        // we may need to add !~innerHTML.indexOf(encodeURI(leftBracket) to support old FF\n\t        if (!~innerHTML.indexOf(leftBracket)) {\n\t            return 'continue';\n\t        }\n\t\n\t        for (var j = 0; j < childNodes.length; j++) {\n\t            var childNode = childNodes[j];\n\t            var nodeType = childNode.nodeType;\n\t            var textContent = childNode.textContent;\n\t\n\t\n\t            if (nodeType === ELEMENT_NODE) {\n\t                // if childNode is HTML element then add it to the end of allNodes array\n\t                // to check everything on next outer cycle iterations\n\t                allNodes.push(childNode);\n\t            } else if (nodeType === TEXT_NODE) {\n\t                // if childNode is text node which contains things like {{x}}\n\t                // then initialize bindings for this node\n\t                if (bindingReg.test(textContent)) {\n\t                    processTextNode({\n\t                        object: object,\n\t                        node: node,\n\t                        textNode: childNode,\n\t                        eventOptions: extendedEventOptions\n\t                    });\n\t                }\n\t            }\n\t        }\n\t    };\n\t\n\t    for (var i = 0; i < allNodes.length; i++) {\n\t        var _ret = _loop(i);\n\t\n\t        if (_ret === 'continue') continue;\n\t    }\n\t\n\t    return nodes;\n\t}\n\n/***/ },\n/* 64 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar calc = __webpack_require__(65);\n\t\n\tvar parserBrackets = __webpack_require__(11);\n\t\n\tvar parserData = {};\n\t\n\t// since Matreshka allows to change parser brackets via parserBrackets objects\n\t// the parser needs to generate required regular expressions and escaped brackets every time\n\t// when parseBindings is called\n\t// to optimize this behavior parserData object is created\n\t// it calculates needed data every time when parserBrackets are changed\n\t// and when parseBindings function is called it uses previously generated regeps\n\t// from parserData object\n\tcalc(parserData, {\n\t    leftBracket: {\n\t        source: {\n\t            object: parserBrackets,\n\t            key: 'left'\n\t        }\n\t    },\n\t    rightBracket: {\n\t        source: {\n\t            object: parserBrackets,\n\t            key: 'right'\n\t        }\n\t    },\n\t    escLeftBracket: {\n\t        source: 'leftBracket',\n\t        handler: function (left) {\n\t            return left.replace(/(\\[|\\(|\\?)/g, '\\\\$1');\n\t        }\n\t    },\n\t    escRightBracket: {\n\t        source: 'rightBracket',\n\t        handler: function (right) {\n\t            return right.replace(/(\\]|\\)|\\?)/g, '\\\\$1');\n\t        }\n\t    },\n\t    bindingReg: {\n\t        source: ['escLeftBracket', 'escRightBracket'],\n\t        handler: function (left, right) {\n\t            return new RegExp(left + '\\\\s*(.+?)\\\\s*' + right, 'g');\n\t        }\n\t    },\n\t    strictBindingReg: {\n\t        source: ['escLeftBracket', 'escRightBracket'],\n\t        handler: function (left, right) {\n\t            return new RegExp('^' + left + '\\\\s*(.+?)\\\\s*' + right + '$', 'g');\n\t        }\n\t    }\n\t}, {\n\t    debounceCalc: false // we need to get new regexps immediately when brackets are changed\n\t});\n\t\n\tmodule.exports = parserData;\n\n/***/ },\n/* 65 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar initMK = __webpack_require__(18);\n\t\n\tvar checkObjectType = __webpack_require__(24);\n\t\n\tvar matreshkaError = __webpack_require__(25);\n\t\n\tvar debounce = __webpack_require__(66);\n\t\n\tvar addSource = __webpack_require__(67);\n\t\n\tvar createCalcHandler = __webpack_require__(79);\n\t\n\tvar defineProp = __webpack_require__(22);\n\t\n\t// defines a property which is dependend on other properties\n\tmodule.exports = calc;\n\tfunction calc(object, target, sources, givenHandler, eventOptions) {\n\t    if (typeof this === 'object' && this.isMatreshka) {\n\t        // when context is Matreshka instance, use this as an object and shift other args\n\t        /* eslint-disable no-param-reassign */\n\t        eventOptions = givenHandler;\n\t        givenHandler = sources;\n\t        sources = target;\n\t        target = object;\n\t        object = this;\n\t        /* eslint-enable no-param-reassign */\n\t    } else {\n\t        // throw error when object type is wrong\n\t        checkObjectType(object, 'calc');\n\t    }\n\t\n\t    if (target instanceof Object) {\n\t        for (var _target = target, _keys5 = Object.keys(_target), _i5 = 0, itemTarget, _ref, _l5 = _keys5.length; (itemTarget = _keys5[_i5], _ref = _target[itemTarget]), _i5 < _l5; _i5++) {\n\t            var itemSource = _ref.source;\n\t            var itemHandler = _ref.handler;\n\t            var itemEventOptions = _ref.event;\n\t\n\t            var commonEventOptions = sources;\n\t            var mergedEventOptions = {};\n\t\n\t            if (commonEventOptions) {\n\t                var _result = mergedEventOptions;\n\t                // extend event object by \"global\" event\n\t\n\t                for (var _source2 = commonEventOptions, _keys2 = Object.keys(_source2), _l2 = _keys2.length, _i2 = 0, _key2; _i2 < _l2; _i2++) {\n\t                    _key2 = _keys2[_i2];\n\t                    _result[_key2] = _source2[_key2];\n\t                }\n\t            }\n\t\n\t            if (itemEventOptions) {\n\t                var _result2 = mergedEventOptions;\n\t                // extend event object by \"local\" event (\"event\" key of an object)\n\t\n\t                for (var _source4 = itemEventOptions, _keys4 = Object.keys(_source4), _l4 = _keys4.length, _i4 = 0, _key4; _i4 < _l4; _i4++) {\n\t                    _key4 = _keys4[_i4];\n\t                    _result2[_key4] = _source4[_key4];\n\t                }\n\t            }\n\t\n\t            calc(object, itemTarget, itemSource, itemHandler, mergedEventOptions);\n\t        }\n\t        /*\n\t         * accept an object\n\t         * this.calc({target: { source, handler, event } }, commonEventOptions);\n\t         */\n\t\n\t\n\t        return object;\n\t    }\n\t\n\t    if (typeof target !== 'string') {\n\t        throw matreshkaError('calc:target_type', { target: target });\n\t    }\n\t\n\t    eventOptions = eventOptions || {}; // eslint-disable-line no-param-reassign\n\t    var def = initMK(object);\n\t    var _eventOptions = eventOptions;\n\t    var _eventOptions$setOnIn = _eventOptions.setOnInit;\n\t    var setOnInit = _eventOptions$setOnIn === undefined ? true : _eventOptions$setOnIn;\n\t    var _eventOptions$debounc = _eventOptions.debounceCalcOnInit;\n\t    var debounceCalcOnInit = _eventOptions$debounc === undefined ? false : _eventOptions$debounc;\n\t    var _eventOptions$debounc2 = _eventOptions.debounceCalc;\n\t    var debounceCalc = _eventOptions$debounc2 === undefined ? true : _eventOptions$debounc2;\n\t    var _eventOptions$debounc3 = _eventOptions.debounceCalcDelay;\n\t    var debounceCalcDelay = _eventOptions$debounc3 === undefined ? 0 : _eventOptions$debounc3;\n\t    var _eventOptions$isTarge = _eventOptions.isTargetPropertyHidden;\n\t    var isTargetPropertyHidden = _eventOptions$isTarge === undefined ? false : _eventOptions$isTarge;\n\t\n\t    var defaultHandler = function (value) {\n\t        return value;\n\t    };\n\t    var handler = givenHandler || defaultHandler;\n\t    var allSources = [];\n\t    var syncCalcHandler = createCalcHandler({\n\t        object: object,\n\t        eventOptions: eventOptions,\n\t        allSources: allSources,\n\t        target: target,\n\t        def: def,\n\t        handler: handler\n\t    });\n\t\n\t    var debouncedCalcHandler = void 0;\n\t    var calcHandler = void 0;\n\t\n\t    if (debounceCalcOnInit || debounceCalc) {\n\t        debouncedCalcHandler = debounce(syncCalcHandler, debounceCalcDelay);\n\t    }\n\t\n\t    defineProp(object, target, isTargetPropertyHidden);\n\t\n\t    if (!(sources instanceof Array)) {\n\t        sources = [sources]; // eslint-disable-line no-param-reassign\n\t    }\n\t\n\t    if (debounceCalc) {\n\t        calcHandler = debouncedCalcHandler;\n\t    } else {\n\t        calcHandler = syncCalcHandler;\n\t    }\n\t\n\t    for (var _target3 = sources, _index2 = 0, source, _l7 = _target3.length; source = _target3[_index2], _index2 < _l7; _index2++) {\n\t        if (typeof source === 'string') {\n\t            // source object is current object\n\t            addSource({\n\t                calcHandler: calcHandler,\n\t                allSources: allSources,\n\t                sourceKey: source,\n\t                sourceObject: object,\n\t                eventOptions: eventOptions\n\t            });\n\t        } else {\n\t            (function () {\n\t                // source object is external object\n\t                if (!source || typeof source !== 'object') {\n\t                    throw matreshkaError('calc:source_type', { source: source });\n\t                }\n\t\n\t                var sourceKey = source.key;\n\t                var sourceObject = source.object;\n\t                if (sourceKey instanceof Array) {\n\t                    for (var _target2 = sourceKey, _index = 0, sourceKeyItem, _l6 = _target2.length; sourceKeyItem = _target2[_index], _index < _l6; _index++) {\n\t                        addSource({\n\t                            calcHandler: calcHandler,\n\t                            allSources: allSources,\n\t                            sourceKey: sourceKeyItem,\n\t                            sourceObject: sourceObject,\n\t                            eventOptions: eventOptions\n\t                        });\n\t                    }\n\t                    // many keys are passed\n\t\n\t                } else {\n\t                    // one key is passed\n\t                    addSource({\n\t                        calcHandler: calcHandler,\n\t                        allSources: allSources,\n\t                        sourceKey: sourceKey,\n\t                        sourceObject: sourceObject,\n\t                        eventOptions: eventOptions\n\t                    });\n\t                }\n\t            })();\n\t        }\n\t    }\n\t\n\t    if (setOnInit) {\n\t        if (debounceCalcOnInit) {\n\t            debouncedCalcHandler();\n\t        } else {\n\t            syncCalcHandler();\n\t        }\n\t    }\n\t\n\t    return object;\n\t}\n\n/***/ },\n/* 66 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar apply = __webpack_require__(21);\n\t\n\t// Returns a function, that, as long as it continues to be invoked, will not\n\t// be triggered. The function will be called after it stops being called for\n\t// N milliseconds.\n\t// (c) https://davidwalsh.name/javascript-debounce-function\n\t\n\tmodule.exports = debounce;\n\tfunction debounce(func, givenDelay, thisArg) {\n\t    var timeout = void 0;\n\t    var delay = void 0;\n\t    if (typeof givenDelay !== 'number') {\n\t        thisArg = givenDelay; // eslint-disable-line no-param-reassign\n\t        delay = 0;\n\t    } else {\n\t        delay = givenDelay || 0;\n\t    }\n\t\n\t    return function debounced() {\n\t        var args = arguments;\n\t        var callContext = thisArg || this;\n\t\n\t        clearTimeout(timeout);\n\t\n\t        timeout = setTimeout(function () {\n\t            return apply(func, callContext, args);\n\t        }, delay);\n\t    };\n\t}\n\n/***/ },\n/* 67 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar addListener = __webpack_require__(17);\n\t\n\tvar addTreeListener = __webpack_require__(68);\n\t\n\tvar matreshkaError = __webpack_require__(25);\n\t\n\t// adds a source to a source list and adds needed event listener to a it\n\tmodule.exports = addSource;\n\tfunction addSource(_ref) {\n\t    var calcHandler = _ref.calcHandler;\n\t    var allSources = _ref.allSources;\n\t    var sourceKey = _ref.sourceKey;\n\t    var sourceObject = _ref.sourceObject;\n\t    var eventOptions = _ref.eventOptions;\n\t    var _eventOptions$exactKe = eventOptions.exactKey;\n\t    var exactKey = _eventOptions$exactKe === undefined ? false : _eventOptions$exactKe;\n\t\n\t    var isDelegated = false;\n\t\n\t    // source key must be a string\n\t    if (typeof sourceKey !== 'string') {\n\t        throw matreshkaError('calc:source_key_type', { sourceKey: sourceKey });\n\t    }\n\t\n\t    // source object must be an object\n\t    if (!sourceObject || typeof sourceObject !== 'object') {\n\t        throw matreshkaError('calc:source_object_type', { sourceObject: sourceObject });\n\t    }\n\t\n\t    if (!exactKey) {\n\t        var deepPath = sourceKey.split('.');\n\t\n\t        // if something like a.b.c is used as a key\n\t        if (deepPath.length > 1) {\n\t            isDelegated = true;\n\t            // TODO: Avoid collisions with bindings by using another event name\n\t            // ... instead of _change:tree:xxx\n\t            addTreeListener(sourceObject, deepPath, calcHandler);\n\t        } else {\n\t            exactKey = true;\n\t        }\n\t    }\n\t\n\t    if (exactKey) {\n\t        // normal handler\n\t        addListener(sourceObject, '_change:deps:' + sourceKey, calcHandler);\n\t    }\n\t\n\t    allSources.push({\n\t        sourceKey: sourceKey,\n\t        sourceObject: sourceObject,\n\t        isDelegated: isDelegated\n\t    });\n\t}\n\n/***/ },\n/* 68 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar delegateListener = __webpack_require__(69);\n\t\n\tvar removeTreeListener = __webpack_require__(78);\n\t\n\t// creates tree listener\n\tfunction createTreeListener(_ref) {\n\t    var handler = _ref.handler;\n\t    var restPath = _ref.restPath;\n\t\n\t    var newHandler = function treeListener(changeEvent) {\n\t        var _keys,\n\t            _l,\n\t            _i,\n\t            _source,\n\t            _key,\n\t            _result = {};\n\t\n\t        _result.restPath = restPath\n\t\n\t        for (_source = changeEvent, _keys = Object.keys(_source), _l = _keys.length, _i = 0; _i < _l; _i++) {\n\t            _key = _keys[_i];\n\t            _result[_key] = _source[_key];\n\t        }\n\t\n\t        var extendedChangeEvent = _result;\n\t        var previousValue = changeEvent.previousValue;\n\t        var value = changeEvent.value;\n\t\n\t        // removes listener for all branches of the path on old object\n\t\n\t        if (previousValue && typeof previousValue === 'object') {\n\t            removeTreeListener(previousValue, restPath, handler);\n\t        }\n\t\n\t        // adds listener for all branches of \"restPath\" path on newly assigned object\n\t        if (value && typeof value === 'object') {\n\t            addTreeListener(value, restPath, handler);\n\t        }\n\t\n\t        // call original handler\n\t        handler.call(this, extendedChangeEvent);\n\t    };\n\t\n\t    newHandler._callback = handler;\n\t\n\t    return newHandler;\n\t}\n\t\n\t// listens changes for all branches of given path\n\t// TODO: Pass context to addTreeListener\n\t// one of the most hard functions to understand\n\tmodule.exports = addTreeListener;\n\tfunction addTreeListener(object, deepPath, handler) {\n\t    if (typeof deepPath === 'string') {\n\t        deepPath = deepPath.split('.'); // eslint-disable-line no-param-reassign\n\t    }\n\t\n\t    // iterate over all keys and delegate listener for all objects of given branch\n\t    for (var i = 0; i < deepPath.length; i++) {\n\t        // TODO: Array.prototype.slice method is slow\n\t        var listenPath = deepPath.slice(0, i);\n\t        var restPath = deepPath.slice(i + 1);\n\t\n\t        delegateListener(object, listenPath, '_change:tree:' + deepPath[i], createTreeListener({\n\t            handler: handler,\n\t            restPath: restPath\n\t        }));\n\t    }\n\t}\n\n/***/ },\n/* 69 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar addListener = __webpack_require__(17);\n\t\n\tvar defs = __webpack_require__(19);\n\t\n\tvar arrayAddHandler = __webpack_require__(70);\n\t\n\tvar objectSetHandler = __webpack_require__(71);\n\t\n\tvar arrayRemoveHandler = __webpack_require__(72);\n\t\n\tvar objectRemoveHandler = __webpack_require__(76);\n\t\n\tvar changeHandler = __webpack_require__(77);\n\t\n\t// adds delegated event listener to an object by given path\n\tmodule.exports = delegateListener;\n\tfunction delegateListener(object, givenPath, name, callback, context) {\n\t    var info = arguments.length <= 5 || arguments[5] === undefined ? {} : arguments[5];\n\t\n\t    // if typeof path is string and path is not empty string then split it\n\t    var path = typeof givenPath === 'string' && givenPath !== '' ? givenPath.split('.') : givenPath;\n\t\n\t    if (!path || !path.length) {\n\t        // if no path then add simple listener\n\t        addListener(object, name, callback, context, info);\n\t    } else {\n\t        // else do all magic\n\t        var key = path[0];\n\t        var pathStr = void 0; // needed for undelegation\n\t\n\t        if (path.length > 1) {\n\t            var _source = path,\n\t                _l = _source.length,\n\t                _i = 1 || 0,\n\t                _end = null || _l,\n\t                _j = 0,\n\t                _result = Array(_end - _i);\n\t\n\t            while (_i < _end) {\n\t                _result[_j++] = _source[_i++];\n\t            }\n\t\n\t            path = _result;\n\t            pathStr = path.join('.');\n\t        } else {\n\t            path = [];\n\t            pathStr = path[0] || '';\n\t        }\n\t\n\t        var delegatedData = {\n\t            path: path,\n\t            name: name,\n\t            callback: callback,\n\t            context: context,\n\t            info: info,\n\t            object: object\n\t        };\n\t\n\t        if (key === '*') {\n\t            // handling asterisk events\n\t            // { skipChecks: true } allows to use same event name and event handler few times\n\t            if (object.isMatreshkaArray) {\n\t                // the event is triggered when something is added to an array\n\t                addListener(object, '_asterisk:add', arrayAddHandler, null, {\n\t                    delegatedData: delegatedData,\n\t                    pathStr: pathStr,\n\t                    skipChecks: true\n\t                });\n\t\n\t                // the event is triggered when something is removed from an array\n\t                addListener(object, '_asterisk:remove', arrayRemoveHandler, null, {\n\t                    delegatedData: delegatedData,\n\t                    pathStr: pathStr,\n\t                    skipChecks: true\n\t                });\n\t\n\t                // call handler manually to delegate listener for currently existing data props\n\t                arrayAddHandler({\n\t                    added: object\n\t                }, delegatedData);\n\t            } else if (object.isMatreshkaObject) {\n\t                var def = defs.get(object);\n\t\n\t                // the event is triggered when data prop is changed\n\t                addListener(object, '_asterisk:set', objectSetHandler, null, {\n\t                    delegatedData: delegatedData,\n\t                    pathStr: pathStr,\n\t                    skipChecks: true\n\t                });\n\t\n\t                // the event is triggered when data prop is removed\n\t                addListener(object, '_asterisk:remove', objectRemoveHandler, null, {\n\t                    delegatedData: delegatedData,\n\t                    pathStr: pathStr,\n\t                    skipChecks: true\n\t                });\n\t\n\t                // delegate listener for currently existing data props\n\t\n\t                for (var _target = def.keys, _keys = Object.keys(_target), _i2 = 0, defKey, _, _l2 = _keys.length; (defKey = _keys[_i2], _ = _target[defKey]), _i2 < _l2; _i2++) {\n\t                    var item = object[defKey];\n\t                    if (item && typeof item === 'object') {\n\t                        delegateListener(item, path, name, callback, context, info);\n\t                    }\n\t                }\n\t            }\n\t        } else {\n\t            // handling non-asterisk delegated event\n\t\n\t            // the event is triggered by \"set\"\n\t            addListener(object, '_change:delegated:' + key, changeHandler, null, {\n\t                delegatedData: delegatedData,\n\t                pathStr: pathStr\n\t            });\n\t\n\t            // call handler manually\n\t            changeHandler({\n\t                value: object[key]\n\t            }, delegatedData);\n\t        }\n\t    }\n\t}\n\n/***/ },\n/* 70 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar triggerOne = __webpack_require__(20);\n\t\n\t// the function is called when something is added to an array\n\t// it delegates asterisk listener for newly added items\n\tmodule.exports = arrayAddHandler;\n\tfunction arrayAddHandler(_ref) {\n\t    var added = _ref.added;\n\t\n\t    var _ref2 = arguments.length <= 1 || arguments[1] === undefined ? triggerOne.latestEvent.info.delegatedData : arguments[1];\n\t\n\t    var path = _ref2.path;\n\t    var name = _ref2.name;\n\t    var callback = _ref2.callback;\n\t    var context = _ref2.context;\n\t    var info = _ref2.info;\n\t\n\t    for (var _target = added, _index = 0, item, _l = _target.length; item = _target[_index], _index < _l; _index++) {\n\t        if (item && typeof item === 'object') {\n\t            var delegateListener = __webpack_require__(69); // fixing circular ref\n\t\n\t            delegateListener(item, path, name, callback, context, info);\n\t        }\n\t    }\n\t}\n\n/***/ },\n/* 71 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar triggerOne = __webpack_require__(20);\n\t\n\tvar defs = __webpack_require__(19);\n\t\n\t// the function is called when data property is changed in Matreshka.Object\n\t// it delegates asterisk listener for new value\n\tmodule.exports = objectSetHandler;\n\tfunction objectSetHandler(_ref) {\n\t    var key = _ref.key;\n\t\n\t    var _ref2 = arguments.length <= 1 || arguments[1] === undefined ? triggerOne.latestEvent.info.delegatedData : arguments[1];\n\t\n\t    var path = _ref2.path;\n\t    var name = _ref2.name;\n\t    var callback = _ref2.callback;\n\t    var context = _ref2.context;\n\t    var info = _ref2.info;\n\t    var object = _ref2.object;\n\t\n\t    if (key) {\n\t        var item = object[key];\n\t\n\t        if (item && typeof item === 'object') {\n\t            var def = defs.get(object);\n\t            if (key in def.keys) {\n\t                var delegateListener = __webpack_require__(69); // fixing circular ref\n\t\n\t                delegateListener(item, path, name, callback, context, info);\n\t            }\n\t        }\n\t    }\n\t}\n\n/***/ },\n/* 72 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar undelegateListener = __webpack_require__(73);\n\t\n\tvar triggerOne = __webpack_require__(20);\n\t\n\t// the function is called when something is removed from an array\n\t// it undelegates asterisk listener from removed items\n\tmodule.exports = arrayRemoveHandler;\n\tfunction arrayRemoveHandler(_ref) {\n\t    var removed = _ref.removed;\n\t\n\t    var _ref2 = arguments.length <= 1 || arguments[1] === undefined ? triggerOne.latestEvent.info.delegatedData : arguments[1];\n\t\n\t    var path = _ref2.path;\n\t    var name = _ref2.name;\n\t    var callback = _ref2.callback;\n\t    var context = _ref2.context;\n\t    var info = _ref2.info;\n\t\n\t    if (removed && removed.length) {\n\t        for (var _target = removed, _index = 0, item, _l = _target.length; item = _target[_index], _index < _l; _index++) {\n\t            if (item && typeof item === 'object') {\n\t                undelegateListener(item, path, name, callback, context, info);\n\t            }\n\t        }\n\t    }\n\t}\n\n/***/ },\n/* 73 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar defs = __webpack_require__(19);\n\t\n\tvar removeListener = __webpack_require__(74);\n\t\n\t// the function removes internally used events such as _asterisk:add\n\tfunction detatchDelegatedLogic(_ref) {\n\t    var delegatedEventName = _ref.delegatedEventName;\n\t    var pathStr = _ref.pathStr;\n\t    var allEvents = _ref.allEvents;\n\t\n\t    var retain = [];\n\t    var events = allEvents[delegatedEventName];\n\t\n\t    for (var _target = events, _index = 0, event, _l = _target.length; event = _target[_index], _index < _l; _index++) {\n\t        // pathStr is assigned to info in delegateListener\n\t        if (event.info.pathStr !== pathStr) {\n\t            retain.push(event);\n\t        }\n\t    }\n\t\n\t    if (retain.length) {\n\t        allEvents[delegatedEventName] = retain;\n\t    } else {\n\t        delete allEvents[delegatedEventName];\n\t    }\n\t}\n\t\n\t// removes delegated event listener from an object by given path\n\tmodule.exports = undelegateListener;\n\tfunction undelegateListener(object, givenPath, name, callback, context) {\n\t    var info = arguments.length <= 5 || arguments[5] === undefined ? {} : arguments[5];\n\t\n\t    var def = defs.get(object);\n\t\n\t    // if no definition do nothing\n\t    if (!def) {\n\t        return;\n\t    }\n\t\n\t    var allEvents = def.events;\n\t\n\t\n\t    var path = typeof givenPath === 'string' && givenPath !== '' ? givenPath.split('.') : givenPath;\n\t\n\t    if (!path || !path.length) {\n\t        // if no path then remove listener\n\t        removeListener(object, name, callback, context, info);\n\t    } else {\n\t        // else do all magic\n\t        var key = path[0];\n\t        var pathStr = void 0;\n\t\n\t        if (path.length > 1) {\n\t            var _source = path,\n\t                _l2 = _source.length,\n\t                _i = 1 || 0,\n\t                _end = null || _l2,\n\t                _j = 0,\n\t                _result = Array(_end - _i);\n\t\n\t            while (_i < _end) {\n\t                _result[_j++] = _source[_i++];\n\t            }\n\t\n\t            path = _result;\n\t            pathStr = path.join('.');\n\t        } else {\n\t            path = [];\n\t            pathStr = path[0] || '';\n\t        }\n\t\n\t        if (key === '*') {\n\t            // remove asterisk events\n\t            if (object.isMatreshkaArray) {\n\t                var delegatedAddEvtName = '_asterisk:add';\n\t                if (allEvents[delegatedAddEvtName]) {\n\t                    detatchDelegatedLogic({\n\t                        delegatedEventName: delegatedAddEvtName,\n\t                        pathStr: pathStr,\n\t                        allEvents: allEvents\n\t                    });\n\t                }\n\t\n\t                var delegatedRemoveEvtName = '_asterisk:remove';\n\t                if (allEvents[delegatedRemoveEvtName]) {\n\t                    detatchDelegatedLogic({\n\t                        delegatedEventName: delegatedRemoveEvtName,\n\t                        pathStr: pathStr,\n\t                        allEvents: allEvents\n\t                    });\n\t                }\n\t\n\t                // undelegate asterisk events for existing items\n\t                if (object.length) {\n\t                    for (var _target2 = object, _index2 = 0, item, _l3 = _target2.length; item = _target2[_index2], _index2 < _l3; _index2++) {\n\t                        if (item && typeof item === 'object') {\n\t                            undelegateListener(item, path, name, callback, context, info);\n\t                        }\n\t                    }\n\t                }\n\t            } else if (object.isMatreshkaObject) {\n\t                var delegatedSetEvtName = '_asterisk:set';\n\t                if (allEvents[delegatedSetEvtName]) {\n\t                    detatchDelegatedLogic({\n\t                        delegatedEventName: delegatedSetEvtName,\n\t                        pathStr: pathStr,\n\t                        allEvents: allEvents\n\t                    });\n\t                }\n\t\n\t                var _delegatedRemoveEvtName = '_asterisk:remove';\n\t                if (allEvents[_delegatedRemoveEvtName]) {\n\t                    detatchDelegatedLogic({\n\t                        delegatedEventName: _delegatedRemoveEvtName,\n\t                        pathStr: pathStr,\n\t                        allEvents: allEvents\n\t                    });\n\t                }\n\t\n\t                object.each(function (item) {\n\t                    if (item && typeof item === 'object') {\n\t                        undelegateListener(item, path, name, callback, context, info);\n\t                    }\n\t                });\n\t            }\n\t        } else {\n\t            // remove non-asterisk delegated events\n\t\n\t            var delegatedChangeEvtName = '_change:delegated:' + key;\n\t            if (allEvents[delegatedChangeEvtName]) {\n\t                detatchDelegatedLogic({\n\t                    delegatedEventName: delegatedChangeEvtName,\n\t                    pathStr: pathStr,\n\t                    allEvents: allEvents\n\t                });\n\t            }\n\t\n\t            if (typeof object[key] === 'object') {\n\t                undelegateListener(object[key], path, name, callback, context, info);\n\t            }\n\t        }\n\t    }\n\t}\n\n/***/ },\n/* 74 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar defs = __webpack_require__(19);\n\t\n\tvar triggerOne = __webpack_require__(20);\n\t\n\tvar domEventReg = __webpack_require__(27);\n\t\n\t// removes simple event listener from an object\n\tmodule.exports = removeListener;\n\tfunction removeListener(object, name, callback, context, info) {\n\t    var def = defs.get(object);\n\t\n\t    // if no definition do nothing\n\t    if (!def) {\n\t        return false;\n\t    }\n\t\n\t    var allEvents = def.events;\n\t\n\t    var events = allEvents[name];\n\t    var retain = [];\n\t    var noTrigger = name ? name[0] === '_' : false;\n\t    var domEventExecResult = domEventReg.exec(name);\n\t\n\t    if (domEventExecResult) {\n\t        var eventName = domEventExecResult[1];\n\t        var _domEventExecResult$ = domEventExecResult[2];\n\t        var key = _domEventExecResult$ === undefined ? 'sandbox' : _domEventExecResult$;\n\t        var selector = domEventExecResult[3];\n\t        // fixing circular reference issue\n\t\n\t        var removeDomListener = __webpack_require__(75);\n\t\n\t        removeDomListener(object, key, eventName, selector, callback, context, info);\n\t\n\t        return true;\n\t    }\n\t\n\t    // if all events need to be removed\n\t    if (typeof name === 'undefined') {\n\t        if (!noTrigger) {\n\t            for (var _target2 = allEvents, _keys = Object.keys(_target2), _i = 0, allEventsName, allEventsItem, _l2 = _keys.length; (allEventsName = _keys[_i], allEventsItem = _target2[allEventsName]), _i < _l2; _i++) {\n\t                for (var _target = allEventsItem, _index = 0, event, _l = _target.length; event = _target[_index], _index < _l; _index++) {\n\t                    var removeEventData = {\n\t                        allEventsName: allEventsName,\n\t                        callback: event.callback,\n\t                        context: event.context\n\t                    };\n\t\n\t                    triggerOne(object, 'removeevent:' + name, removeEventData);\n\t                    triggerOne(object, 'removeevent', removeEventData);\n\t                }\n\t            }\n\t        }\n\t\n\t        // restore default value of \"events\"\n\t        def.events = {};\n\t    } else if (events) {\n\t        for (var _target3 = events, _index2 = 0, event, _l3 = _target3.length; event = _target3[_index2], _index2 < _l3; _index2++) {\n\t            var argCallback = callback && callback._callback || callback;\n\t            var eventCallback = event.callback._callback || event.callback;\n\t\n\t            if (argCallback && argCallback !== eventCallback || context && context !== event.context) {\n\t                // keep event\n\t                retain.push(event);\n\t            } else {\n\t                var _removeEventData = {\n\t                    name: name,\n\t                    callback: event.callback,\n\t                    context: event.context\n\t                };\n\t\n\t                if (!noTrigger) {\n\t                    triggerOne(object, 'removeevent:' + name, _removeEventData);\n\t                    triggerOne(object, 'removeevent', _removeEventData);\n\t                }\n\t            }\n\t        }\n\t        // if events with given name are found\n\t\n\t\n\t        if (retain.length) {\n\t            allEvents[name] = retain;\n\t        } else {\n\t            delete def.events[name];\n\t        }\n\t    }\n\t\n\t    return false;\n\t}\n\n/***/ },\n/* 75 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar defs = __webpack_require__(19);\n\t\n\tvar removeListener = __webpack_require__(74);\n\t\n\tvar dom = __webpack_require__(29);\n\t\n\t// removes dom listener from nodes bound to given key\n\tmodule.exports = removeDomListener;\n\tfunction removeDomListener(object, key, eventName, selector, callback, context, info) {\n\t    var def = defs.get(object);\n\t\n\t    if (!def) {\n\t        return object;\n\t    }\n\t\n\t    var props = def.props;\n\t\n\t    var propDef = props[key];\n\t\n\t    if (!propDef) {\n\t        return object;\n\t    }\n\t\n\t    var bindings = propDef.bindings;\n\t\n\t\n\t    if (bindings) {\n\t        (function () {\n\t            // collect bound nodes and remove DOM event listener\n\t            var nodes = Array(bindings.length);\n\t            var eventNamespace = def.id + key;\n\t\n\t            for (var _target = bindings, index = 0, binding, _l = _target.length; binding = _target[index], index < _l; index++) {\n\t                nodes[index] = binding.node;\n\t            }\n\t\n\t            dom.$(nodes).off(eventName + '.' + eventNamespace, selector, callback);\n\t        })();\n\t    }\n\t\n\t    // remove bind and unbind listeners from given key\n\t    removeListener(object, 'bind:' + key, callback, context, info);\n\t    removeListener(object, 'unbind:' + key, callback, context, info);\n\t\n\t    return object;\n\t}\n\n/***/ },\n/* 76 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar undelegateListener = __webpack_require__(73);\n\t\n\tvar triggerOne = __webpack_require__(20);\n\t\n\t// the function is called when data property is removed from Matreshka.Object\n\t// it undelegates asterisk listener from removed object\n\tmodule.exports = objectRemoveHandler;\n\tfunction objectRemoveHandler(_ref) {\n\t    var item = _ref.value;\n\t\n\t    var _ref2 = arguments.length <= 1 || arguments[1] === undefined ? triggerOne.latestEvent.info.delegatedData : arguments[1];\n\t\n\t    var path = _ref2.path;\n\t    var name = _ref2.name;\n\t    var callback = _ref2.callback;\n\t    var context = _ref2.context;\n\t    var info = _ref2.info;\n\t\n\t    if (item && typeof item === 'object') {\n\t        undelegateListener(item, path, name, callback, context, info);\n\t    }\n\t}\n\n/***/ },\n/* 77 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar undelegateListener = __webpack_require__(73);\n\t\n\tvar triggerOne = __webpack_require__(20);\n\t\n\t// the function is called when some part of a path is changed\n\t// it delegates event listener for new branch of an object and undelegates it for old one\n\t// used for non-asterisk events\n\tmodule.exports = changeHandler;\n\tfunction changeHandler(_ref) {\n\t    var previousValue = _ref.previousValue;\n\t    var value = _ref.value;\n\t\n\t    var _ref2 = arguments.length <= 1 || arguments[1] === undefined ? triggerOne.latestEvent.info.delegatedData : arguments[1];\n\t\n\t    var path = _ref2.path;\n\t    var name = _ref2.name;\n\t    var callback = _ref2.callback;\n\t    var context = _ref2.context;\n\t    var info = _ref2.info;\n\t\n\t    if (value && typeof value === 'object') {\n\t        var delegateListener = __webpack_require__(69); // fixing circular ref\n\t\n\t        delegateListener(value, path, name, callback, context, info);\n\t    }\n\t\n\t    if (previousValue && typeof previousValue === 'object') {\n\t        undelegateListener(previousValue, path, name, callback, context, info);\n\t    }\n\t}\n\n/***/ },\n/* 78 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar undelegateListener = __webpack_require__(73);\n\t\n\t// removes tree listener from all object tree of fiven path\n\t// TODO: Pass context to removeTreeListener\n\tmodule.exports = removeTreeListener;\n\tfunction removeTreeListener(object, deepPath, handler) {\n\t    if (typeof deepPath === 'string') {\n\t        deepPath = deepPath.split('.'); // eslint-disable-line no-param-reassign\n\t    }\n\t\n\t    // iterate over keys of the path and undelegate given handler (can be undefined)\n\t    for (var i = 0; i < deepPath.length; i++) {\n\t        // TODO: Array.prototype.slice is slow\n\t        var listenedPath = deepPath.slice(0, i);\n\t\n\t        undelegateListener(object, listenedPath, '_change:tree:' + deepPath[i], handler);\n\t    }\n\t}\n\n/***/ },\n/* 79 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar set = __webpack_require__(23);\n\t\n\tvar deepFind = __webpack_require__(80);\n\t\n\tvar apply = __webpack_require__(21);\n\t\n\t// creates event handler for target object which will be fired when a source is changed\n\tmodule.exports = createCalcHandler;\n\tfunction createCalcHandler(_ref) {\n\t    var object = _ref.object;\n\t    var eventOptions = _ref.eventOptions;\n\t    var allSources = _ref.allSources;\n\t    var target = _ref.target;\n\t    var def = _ref.def;\n\t    var handler = _ref.handler;\n\t\n\t    return function calcHandler() {\n\t        var changeEvent = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t        var values = [];\n\t        var _changeEvent$protecto = changeEvent.protector;\n\t        var protector = _changeEvent$protecto === undefined ? {} : _changeEvent$protecto;\n\t\n\t        var protectKey = target + def.id;\n\t\n\t        var _keys,\n\t            _l,\n\t            _i,\n\t            _source,\n\t            _key,\n\t            _result = {};\n\t\n\t        _result.protector = protector\n\t\n\t        for (_source = eventOptions, _keys = Object.keys(_source), _l = _keys.length, _i = 0; _i < _l; _i++) {\n\t            _key = _keys[_i];\n\t            _result[_key] = _source[_key];\n\t        }\n\t\n\t        for (_source = changeEvent, _keys = Object.keys(_source), _l = _keys.length, _i = 0; _i < _l; _i++) {\n\t            _key = _keys[_i];\n\t            _result[_key] = _source[_key];\n\t        }\n\t\n\t        var setEventOptions = _result;\n\t\n\t        if (protectKey in protector) {\n\t            return;\n\t        }\n\t\n\t        protector[protectKey] = true;\n\t\n\t        for (var _target = allSources, _index = 0, _ref2, _l2 = _target.length; _ref2 = _target[_index], _index < _l2; _index++) {\n\t            var sourceObject = _ref2.sourceObject;\n\t            var sourceKey = _ref2.sourceKey;\n\t            var isDelegated = _ref2.isDelegated;\n\t\n\t            var value = isDelegated ? deepFind(sourceObject, sourceKey) : sourceObject[sourceKey];\n\t            values.push(value);\n\t        }\n\t\n\t        var targetValue = apply(handler, object, values);\n\t        set(object, target, targetValue, setEventOptions);\n\t    };\n\t}\n\n/***/ },\n/* 80 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t// gets value of a property in nested object\n\t// eg \"d\" from a.b.c.d\n\tmodule.exports = deepFind;\n\tfunction deepFind(obj, givenPath) {\n\t    var paths = typeof givenPath === 'string' ? givenPath.split('.') : givenPath;\n\t    var current = obj;\n\t\n\t    for (var i = 0; i < paths.length; ++i) {\n\t        if (typeof current[paths[i]] === 'undefined') {\n\t            return undefined;\n\t        }\n\t\n\t        current = current[paths[i]];\n\t    }\n\t\n\t    return current;\n\t}\n\n/***/ },\n/* 81 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar parserData = __webpack_require__(64);\n\t\n\tvar bindNode = __webpack_require__(82);\n\t\n\tvar textNodeBinder = {\n\t    setValue: function (value) {\n\t        this.textContent = typeof value === 'undefined' ? '' : value;\n\t    }\n\t};\n\t\n\t// adds binding for text node\n\t// it splits up one text node into \"simple text nodes\"\n\t// and \"bound text nodes\" and removes original text node\n\tmodule.exports = processTextNode;\n\tfunction processTextNode(_ref) {\n\t    var object = _ref.object;\n\t    var node = _ref.node;\n\t    var textNode = _ref.textNode;\n\t    var eventOptions = _ref.eventOptions;\n\t    var bindingReg = parserData.bindingReg;\n\t    var textContent = textNode.textContent;\n\t    var _window = window;\n\t    var document = _window.document;\n\t\n\t\n\t    bindingReg.lastIndex = 0;\n\t\n\t    // tokens variable contains normal text as odd items\n\t    // and bound keys as even items\n\t    // 'foo{{x}}bar{{y}}baz{{z}}' -> ['foo', 'x', 'bar', 'y', 'baz', 'z', '']\n\t    var tokens = textContent.split(bindingReg);\n\t\n\t    // fragment contains all new text nodes\n\t    var fragment = document.createDocumentFragment();\n\t\n\t    for (var _target = tokens, index = 0, token, _l = _target.length; token = _target[index], index < _l; index++) {\n\t        if (token) {\n\t            var newTextNode = document.createTextNode(token);\n\t            fragment.appendChild(newTextNode);\n\t\n\t            // if tokens item is even then it is a key\n\t            // which needs to be bound to newly created text node\n\t            if (index % 2 !== 0) {\n\t                bindNode(object, token, newTextNode, textNodeBinder, eventOptions);\n\t            }\n\t        }\n\t    }\n\t\n\t    node.insertBefore(fragment, textNode);\n\t    node.removeChild(textNode);\n\t}\n\n/***/ },\n/* 82 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar initMK = __webpack_require__(18);\n\t\n\tvar defineProp = __webpack_require__(22);\n\t\n\tvar getNodes = __webpack_require__(83);\n\t\n\tvar createBindingSwitcher = __webpack_require__(86);\n\t\n\tvar bindSingleNode = __webpack_require__(89);\n\t\n\tvar checkObjectType = __webpack_require__(24);\n\t\n\tvar matreshkaError = __webpack_require__(25);\n\t\n\tvar addTreeListener = __webpack_require__(68);\n\t\n\t// initializes binsing between a property of an object to HTML node\n\tmodule.exports = bindNode;\n\tfunction bindNode(object, key, node, binder, eventOptions) {\n\t    if (typeof this === 'object' && this.isMatreshka) {\n\t        // when context is Matreshka instance, use this as an object and shift other args\n\t        /* eslint-disable no-param-reassign */\n\t        eventOptions = binder;\n\t        binder = node;\n\t        node = key;\n\t        key = object;\n\t        object = this;\n\t        /* eslint-enable no-param-reassign */\n\t    } else {\n\t        // throw error when object type is wrong\n\t        checkObjectType(object, 'bindNode');\n\t    }\n\t\n\t    eventOptions = eventOptions || {}; // eslint-disable-line no-param-reassign\n\t    binder = binder || {}; // eslint-disable-line no-param-reassign\n\t\n\t    initMK(object);\n\t\n\t    var temporaryOptionalFlag = bindNode.temporaryOptionalFlag;\n\t\n\t\n\t    delete bindNode.temporaryOptionalFlag;\n\t\n\t    // throw an error when key is falsy\n\t    if (!key) {\n\t        throw matreshkaError('binding:falsy_key');\n\t    }\n\t\n\t    if (key instanceof Array) {\n\t        if (typeof key[0] === 'string') {\n\t            /*\n\t             * accept array of keys\n\t             * this.bindNode(['a', 'b', 'c'], node)\n\t             */\n\t            if (temporaryOptionalFlag) {\n\t                var _keys,\n\t                    _l,\n\t                    _i,\n\t                    _source,\n\t                    _key,\n\t                    _result = {};\n\t\n\t                for (_source = eventOptions, _keys = Object.keys(_source), _l = _keys.length, _i = 0; _i < _l; _i++) {\n\t                    _key = _keys[_i];\n\t                    _result[_key] = _source[_key];\n\t                }\n\t\n\t                _result.optional = true\n\t\n\t                // eslint-disable-next-line no-param-reassign\n\t                eventOptions = _result;\n\t            }\n\t\n\t            for (var _target = key, _index = 0, itemKey, _l2 = _target.length; itemKey = _target[_index], _index < _l2; _index++) {\n\t                bindNode(object, itemKey, node, binder, eventOptions)\n\t            }\n\t        } else {\n\t            for (var _target2 = key, _index2 = 0, _ref, _l7 = _target2.length; _ref = _target2[_index2], _index2 < _l7; _index2++) {\n\t                var itemKey = _ref.key;\n\t                var itemNode = _ref.node;\n\t                var itemBinder = _ref.binder;\n\t                var itemEventOptions = _ref.event;\n\t\n\t                var commonEventOptions = node;\n\t                var mergedEventOptions = {};\n\t\n\t                if (temporaryOptionalFlag) {\n\t                    mergedEventOptions.optional = true;\n\t                }\n\t\n\t                if (commonEventOptions) {\n\t                    var _result2 = mergedEventOptions;\n\t                    // extend event object by \"global\" event\n\t\n\t                    for (var _source3 = commonEventOptions, _keys3 = Object.keys(_source3), _l4 = _keys3.length, _i3 = 0, _key3; _i3 < _l4; _i3++) {\n\t                        _key3 = _keys3[_i3];\n\t                        _result2[_key3] = _source3[_key3];\n\t                    }\n\t                }\n\t\n\t                if (itemEventOptions) {\n\t                    var _result3 = mergedEventOptions;\n\t                    // extend event object by \"local\" event (\"event\" key of an object)\n\t\n\t                    for (var _source5 = itemEventOptions, _keys5 = Object.keys(_source5), _l6 = _keys5.length, _i5 = 0, _key5; _i5 < _l6; _i5++) {\n\t                        _key5 = _keys5[_i5];\n\t                        _result3[_key5] = _source5[_key5];\n\t                    }\n\t                }\n\t\n\t                bindNode(object, itemKey, itemNode, itemBinder, mergedEventOptions);\n\t            }\n\t            /*\n\t             * accept array of objects\n\t             * this.bindNode([{key, node, binder, event}], { silent: true });\n\t             */\n\t\n\t        }\n\t\n\t        return object;\n\t    }\n\t\n\t    if (typeof key === 'object') {\n\t        for (var _target4 = key, _keys7 = Object.keys(_target4), _i7 = 0, keyObjKey, keyObjValue, _l10 = _keys7.length; (keyObjKey = _keys7[_i7], keyObjValue = _target4[keyObjKey]), _i7 < _l10; _i7++) {\n\t            // binder means eventOptions\n\t            if (temporaryOptionalFlag) {\n\t                var _keys6,\n\t                    _l8,\n\t                    _i6,\n\t                    _source6,\n\t                    _key6,\n\t                    _result4 = {};\n\t\n\t                for (_source6 = binder, _keys6 = Object.keys(_source6), _l8 = _keys6.length, _i6 = 0; _i6 < _l8; _i6++) {\n\t                    _key6 = _keys6[_i6];\n\t                    _result4[_key6] = _source6[_key6];\n\t                }\n\t\n\t                _result4.optional = true\n\t\n\t                // eslint-disable-next-line no-param-reassign\n\t                eventOptions = binder ? _result4 : { optional: true };\n\t            } else {\n\t                eventOptions = binder; // eslint-disable-line no-param-reassign\n\t            }\n\t\n\t            if (keyObjValue && keyObjValue.constructor === Object && 'node' in keyObjValue) {\n\t                // this.bindNode({ key: { node: $(), binder } ) }, { on: 'evt' }, { silent: true });\n\t                bindNode(object, keyObjKey, keyObjValue.node, keyObjValue.binder || node, eventOptions);\n\t            } else if (keyObjValue && keyObjValue.constructor === Array && keyObjValue.length && keyObjValue[0].constructor === Object && 'node' in keyObjValue[0]) {\n\t                for (var _target3 = keyObjValue, _index3 = 0, keyObjValueItem, _l9 = _target3.length; keyObjValueItem = _target3[_index3], _index3 < _l9; _index3++) {\n\t                    bindNode(object, keyObjKey, keyObjValueItem.node, keyObjValueItem.binder || node, eventOptions);\n\t                }\n\t                // this.bindNode({ key: [{\n\t                //   node: $(),\n\t                //   binder\n\t                // }] ) }, { on: 'evt' }, { silent: true });\n\t\n\t            } else {\n\t                // this.bindNode({ key: $() }, { on: 'evt' }, { silent: true });\n\t                bindNode(object, keyObjKey, keyObjValue, node, eventOptions);\n\t            }\n\t        }\n\t\n\t        return object;\n\t    }\n\t\n\t    var _eventOptions = eventOptions;\n\t    var _eventOptions$optiona = _eventOptions.optional;\n\t    var optional = _eventOptions$optiona === undefined ? temporaryOptionalFlag || false : _eventOptions$optiona;\n\t    var _eventOptions$exactKe = _eventOptions.exactKey;\n\t    var exactKey = _eventOptions$exactKe === undefined ? false : _eventOptions$exactKe;\n\t\n\t    var $nodes = getNodes(object, node);\n\t\n\t    // check node existence\n\t    if (!$nodes.length) {\n\t        if (optional) {\n\t            return object;\n\t        }\n\t\n\t        throw matreshkaError('binding:node_missing', { key: key, node: node });\n\t    }\n\t\n\t    if (!exactKey) {\n\t        var deepPath = key.split('.');\n\t        var deepPathLength = deepPath.length;\n\t\n\t        if (deepPathLength > 1) {\n\t            // handle binding when key arg includes dots (eg \"a.b.c.d\")\n\t            var bindingSwitcher = createBindingSwitcher({\n\t                object: object,\n\t                deepPath: deepPath,\n\t                $nodes: $nodes,\n\t                binder: binder,\n\t                eventOptions: eventOptions,\n\t                bindNode: bindNode\n\t            });\n\t\n\t            addTreeListener(object, deepPath.slice(0, deepPathLength - 1), bindingSwitcher);\n\t\n\t            bindingSwitcher();\n\t\n\t            return object;\n\t        }\n\t    }\n\t\n\t    var propDef = defineProp(object, key);\n\t\n\t    if (object.isMatreshka) {\n\t        // if an object is Matreshka instance then extend \"$nodes\" and \"nodes\" objects\n\t        var _object = object;\n\t        var $allNodes = _object.$nodes;\n\t        var allNodes = _object.nodes;\n\t\n\t\n\t        if (!$allNodes || !allNodes) {\n\t            throw matreshkaError('binding:instance_nodes_missing', {\n\t                $nodes: $allNodes,\n\t                nodes: allNodes\n\t            });\n\t        }\n\t\n\t        $allNodes[key] = $allNodes[key] && $allNodes[key].length ? $allNodes[key].add($nodes) : $nodes;\n\t\n\t        allNodes[key] = $allNodes[key][0];\n\t    }\n\t\n\t    // handle binding for every node separately\n\t\n\t    for (var _target5 = $nodes, _index4 = 0, oneNode, _l11 = _target5.length; oneNode = _target5[_index4], _index4 < _l11; _index4++) {\n\t        bindSingleNode(object, {\n\t            $nodes: $nodes,\n\t            node: oneNode,\n\t            key: key,\n\t            eventOptions: eventOptions,\n\t            binder: binder,\n\t            propDef: propDef\n\t        })\n\t    }\n\t\n\t    return object;\n\t}\n\n/***/ },\n/* 83 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar selectNodes = __webpack_require__(84);\n\t\n\tvar dom = __webpack_require__(29);\n\t\n\tvar htmlReg = /</;\n\tvar customSelectorReg = /:sandbox|:bound\\(([^(]*)\\)/;\n\t\n\t// the function works just like DOM library accepting any kind of arg\n\t// (HTML string, Node, NodeList etc) bu allows to pass custom selector\n\t// eg :bound(KEY) and :sandbox\n\tmodule.exports = getNodes;\n\tfunction getNodes(object, selector) {\n\t    var nodes = void 0;\n\t\n\t    if (typeof selector === 'string' && !htmlReg.test(selector) && customSelectorReg.test(selector)) {\n\t        nodes = selectNodes(object, selector);\n\t    } else {\n\t        nodes = dom.$(selector);\n\t    }\n\t\n\t    return nodes;\n\t}\n\n/***/ },\n/* 84 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar defs = __webpack_require__(19);\n\t\n\tvar toArray = __webpack_require__(85);\n\t\n\tvar dom = __webpack_require__(29);\n\t\n\tvar customSelectorReg = /\\s*:bound\\(([^(]*)\\)\\s*([\\S\\s]*)\\s*|\\s*:sandbox\\s*([\\S\\s]*)\\s*/;\n\t\n\t// the function selects nodes based on a selector (including custom values, eg :sandbox)\n\t// TODO: selectNodes looks not good, it needs to be refactored and accelerated if possible\n\tmodule.exports = selectNodes;\n\tfunction selectNodes(object, givenSelector) {\n\t    var _defs$get = defs.get(object);\n\t\n\t    var props = _defs$get.props;\n\t\n\t    var selectors = givenSelector.split(',');\n\t    var result = dom.$();\n\t\n\t    for (var _target4 = selectors, _index3 = 0, selector, _l4 = _target4.length; selector = _target4[_index3], _index3 < _l4; _index3++) {\n\t        var execResult = customSelectorReg.exec(selector);\n\t        if (execResult) {\n\t            (function () {\n\t                var boundKey = execResult[3] !== undefined ? 'sandbox' : execResult[1];\n\t                var subSelector = execResult[3] !== undefined ? execResult[3] : execResult[2];\n\t                var propDef = props[boundKey];\n\t\n\t                if (propDef) {\n\t                    var bindings = propDef.bindings;\n\t\n\t                    if (bindings) {\n\t                        (function () {\n\t                            var boundNodes = Array(bindings.length);\n\t\n\t                            // if native selector passed after :bound(KEY) is not empty string\n\t                            // for example \":bound(KEY) .my-selector\"\n\t                            for (var _target = bindings, i = 0, binding, _l = _target.length; binding = _target[i], i < _l; i++) {\n\t                                boundNodes[i] = binding.node;\n\t                            }\n\t\n\t                            if (subSelector) {\n\t                                // if native selector contains children selector\n\t                                // for example \":bound(KEY) > .my-selector\"\n\t                                if (subSelector.indexOf('>') === 0) {\n\t                                    for (var _target2 = boundNodes, _index = 0, node, _l2 = _target2.length; node = _target2[_index], _index < _l2; _index++) {\n\t                                        var randomAttr = ('m' + Math.random()).replace('.', '');\n\t\n\t                                        node.setAttribute(randomAttr, randomAttr);\n\t                                        var selected = node.querySelectorAll('[' + randomAttr + '=\"' + randomAttr + '\"] ' + subSelector);\n\t                                        result = result.add(toArray(selected));\n\t                                        node.removeAttribute(randomAttr);\n\t                                    }\n\t                                    // selecting children\n\t\n\t                                } else {\n\t                                    for (var _target3 = boundNodes, _index2 = 0, node, _l3 = _target3.length; node = _target3[_index2], _index2 < _l3; _index2++) {\n\t                                        var selected = node.querySelectorAll(subSelector);\n\t                                        result = result.add(toArray(selected));\n\t                                    }\n\t                                    // if native selector doesn't contain children selector\n\t\n\t                                }\n\t                            } else {\n\t                                // if native selector is empty string just add bound nodes to result\n\t                                result = result.add(boundNodes);\n\t                            }\n\t                        })();\n\t                    }\n\t                }\n\t            })();\n\t        } else {\n\t            // if it's native selector (no custom things)\n\t            result = result.add(selector);\n\t        }\n\t    }\n\t\n\t    return result;\n\t}\n\n/***/ },\n/* 85 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\t// cheap conversion of an array-like object to Array instance\n\tmodule.exports = toArray;\n\tfunction toArray(object) {\n\t    var start = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n\t    var length = object.length;\n\t\n\t    var array = Array(length);\n\t\n\t    for (var i = start; i < length; i++) {\n\t        array[i - start] = object[i];\n\t    }\n\t\n\t    return array;\n\t}\n\n/***/ },\n/* 86 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar unbindNode = __webpack_require__(87);\n\t\n\t// returns a function which re-adds binding when object branch is changed\n\t// the function is called by bindNode when something like\n\t// 'foo.bar.baz' is passed to it as key argument value\n\t// this is one of the hardest things in the framework to understand\n\tmodule.exports = createBindingSwitcher;\n\tfunction createBindingSwitcher(_ref) {\n\t    var object = _ref.object;\n\t    var deepPath = _ref.deepPath;\n\t    var $nodes = _ref.$nodes;\n\t    var binder = _ref.binder;\n\t    var eventOptions = _ref.eventOptions;\n\t    var bindNode = _ref.bindNode;\n\t\n\t    return function bindingSwitcher() {\n\t        var changeEvent = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t        var deepPathLength = deepPath.length;\n\t        var lastDeepPathItem = deepPath[deepPathLength - 1];\n\t        var value = changeEvent.value;\n\t        var previousValue = changeEvent.previousValue;\n\t        var restPath = changeEvent.restPath;\n\t\n\t        var target = void 0; // an object to call bindNode\n\t        var previousTarget = void 0; // an object to call unbindNode\n\t\n\t\n\t        if (value && typeof value === 'object' && restPath) {\n\t            // if rest path is given and new value is an object\n\t            target = value;\n\t            for (var i = 0; i < restPath.length; i++) {\n\t                target = target[restPath[i]];\n\t                if (!target) {\n\t                    break;\n\t                }\n\t            }\n\t        } else {\n\t            // if rest path is not given\n\t            target = object;\n\t            for (var _i = 0; _i < deepPathLength - 1; _i++) {\n\t                target = target[deepPath[_i]];\n\t                if (!target) {\n\t                    break;\n\t                }\n\t            }\n\t        }\n\t\n\t        // if rest path is given and previous value is an object\n\t        if (previousValue && typeof previousValue === 'object' && restPath) {\n\t            previousTarget = previousValue;\n\t            for (var _i2 = 0; _i2 < restPath.length; _i2++) {\n\t                previousTarget = previousTarget[restPath[_i2]];\n\t                if (!previousTarget) {\n\t                    break;\n\t                }\n\t            }\n\t        }\n\t\n\t        // add binding for new target\n\t        if (target && typeof target === 'object') {\n\t            bindNode(target, lastDeepPathItem, $nodes, binder, eventOptions);\n\t        }\n\t\n\t        // remove binding for previously used object\n\t        if (previousTarget && typeof previousTarget === 'object') {\n\t            unbindNode(previousTarget, lastDeepPathItem, $nodes);\n\t        }\n\t    };\n\t}\n\n/***/ },\n/* 87 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar checkObjectType = __webpack_require__(24);\n\t\n\tvar defs = __webpack_require__(19);\n\t\n\tvar getNodes = __webpack_require__(83);\n\t\n\tvar removeTreeListener = __webpack_require__(78);\n\t\n\tvar removeBinding = __webpack_require__(88);\n\t\n\tvar dom = __webpack_require__(29);\n\t\n\t// unbinds a node\n\tmodule.exports = unbindNode;\n\tfunction unbindNode(object, key, node, eventOptions) {\n\t    if (typeof this === 'object' && this.isMatreshka) {\n\t        // when context is Matreshka instance, use this as an object and shift other args\n\t        /* eslint-disable no-param-reassign */\n\t        eventOptions = node;\n\t        node = key;\n\t        key = object;\n\t        object = this;\n\t        /* eslint-enable no-param-reassign */\n\t    } else {\n\t        // throw error when object type is wrong\n\t        checkObjectType(object, 'unbindNode');\n\t    }\n\t\n\t    if (key instanceof Array) {\n\t        if (typeof key[0] === 'string') {\n\t            for (var _target = key, _index = 0, itemKey, _l = _target.length; itemKey = _target[_index], _index < _l; _index++) {\n\t                unbindNode(object, itemKey, node, eventOptions)\n\t            }\n\t            /*\n\t             * accept array of keys\n\t             * this.unbindNode(['a', 'b', 'c'], node)\n\t             */\n\t        } else {\n\t            for (var _target2 = key, _index2 = 0, _ref, _l6 = _target2.length; _ref = _target2[_index2], _index2 < _l6; _index2++) {\n\t                var itemKey = _ref.key;\n\t                var itemNode = _ref.node;\n\t                var itemEventOptions = _ref.event;\n\t\n\t                var commonEventOptions = node;\n\t                var mergedEventOptions = {};\n\t\n\t                if (commonEventOptions) {\n\t                    var _result = mergedEventOptions;\n\t                    // extend event object by \"global\" event\n\t\n\t                    for (var _source2 = commonEventOptions, _keys2 = Object.keys(_source2), _l3 = _keys2.length, _i2 = 0, _key2; _i2 < _l3; _i2++) {\n\t                        _key2 = _keys2[_i2];\n\t                        _result[_key2] = _source2[_key2];\n\t                    }\n\t                }\n\t\n\t                if (itemEventOptions) {\n\t                    var _result2 = mergedEventOptions;\n\t                    // extend event object by \"local\" event (\"event\" key of an object)\n\t\n\t                    for (var _source4 = itemEventOptions, _keys4 = Object.keys(_source4), _l5 = _keys4.length, _i4 = 0, _key4; _i4 < _l5; _i4++) {\n\t                        _key4 = _keys4[_i4];\n\t                        _result2[_key4] = _source4[_key4];\n\t                    }\n\t                }\n\t\n\t                unbindNode(object, itemKey, itemNode, mergedEventOptions);\n\t            }\n\t            /*\n\t             * acept array of objects\n\t             * this.unbindNode([{ key, node, binder, event }], { silent: true });\n\t             */\n\t\n\t        }\n\t\n\t        return object;\n\t    }\n\t\n\t    if (key && typeof key === 'object') {\n\t        for (var _target4 = key, _keys5 = Object.keys(_target4), _i5 = 0, keyObjKey, keyObjValue, _l8 = _keys5.length; (keyObjKey = _keys5[_i5], keyObjValue = _target4[keyObjKey]), _i5 < _l8; _i5++) {\n\t            if (keyObjValue.constructor === Object && 'node' in keyObjValue) {\n\t                // this.unbindNode({ key: { node: $(), binder } ) }, { silent: true });\n\t                unbindNode(object, keyObjKey, keyObjValue.node, node);\n\t            } else if (keyObjValue.constructor === Array && keyObjValue.length && keyObjValue[0].constructor === Object && 'node' in keyObjValue[0]) {\n\t                for (var _target3 = keyObjValue, _index3 = 0, keyObjValueItem, _l7 = _target3.length; keyObjValueItem = _target3[_index3], _index3 < _l7; _index3++) {\n\t                    unbindNode(object, keyObjKey, keyObjValueItem.node, node);\n\t                }\n\t                // this.unbindNode({ key: [{ node: $(), binder }] ) }, { silent: true });\n\t\n\t            } else {\n\t                // this.unbindNode({ key: $() }, { silent: true });\n\t                unbindNode(object, keyObjKey, keyObjValue, node);\n\t            }\n\t        }\n\t\n\t        return object;\n\t    }\n\t\n\t    eventOptions = eventOptions || {}; // eslint-disable-line no-param-reassign\n\t    var _eventOptions = eventOptions;\n\t    var deep = _eventOptions.deep;\n\t\n\t    var def = defs.get(object);\n\t\n\t    if (!def) {\n\t        return object;\n\t    }\n\t\n\t    var props = def.props;\n\t\n\t    // allow to pass null or undefined as key\n\t    // if passed then remove bindings of all keys for given object\n\t\n\t    if (key === null || typeof key === 'undefined') {\n\t        for (var _target5 = props, _keys6 = Object.keys(_target5), _i6 = 0, propsKey, propsItem, _l9 = _keys6.length; (propsKey = _keys6[_i6], propsItem = _target5[propsKey]), _i6 < _l9; _i6++) {\n\t            unbindNode(object, propsKey, null, eventOptions);\n\t        }\n\t\n\t        return object;\n\t    }\n\t\n\t    // remove delegated binding\n\t    if (deep !== false) {\n\t        var deepPath = key.split('.');\n\t        var deepPathLength = deepPath.length;\n\t\n\t        if (deepPathLength > 1) {\n\t            var target = object;\n\t\n\t            for (var i = 0; i < deepPathLength - 1; i++) {\n\t                // TODO: Do we need to throw an error when a target is falsy?\n\t                target = target[deepPath[i]];\n\t            }\n\t\n\t            // TODO: Potential bug! This may undelegate listener for all bindings with the same path\n\t            // ...(cannot reproduce)\n\t            removeTreeListener(object, deepPath.slice(0, deepPathLength - 2));\n\t\n\t            unbindNode(target, deepPath[deepPathLength - 1], node, eventOptions);\n\t\n\t            return object;\n\t        }\n\t    }\n\t\n\t    var propDef = props[key];\n\t\n\t    // when no propdef do nothing\n\t    if (!propDef) {\n\t        return object;\n\t    }\n\t\n\t    var bindings = propDef.bindings;\n\t\n\t    // if the property doesn't have any bindings do nothing\n\t\n\t    if (!bindings) {\n\t        return object;\n\t    }\n\t\n\t    // if no node is pased remove all bindings for given key\n\t    if (!node) {\n\t        for (var _target6 = bindings, _index4 = 0, binding, _l10 = _target6.length; binding = _target6[_index4], _index4 < _l10; _index4++) {\n\t            removeBinding({ object: object, key: key, eventOptions: eventOptions, binding: binding });\n\t        }\n\t\n\t        propDef.bindings = null;\n\t\n\t        // update nodes and $nodes for Matreshka instance\n\t        if (object.isMatreshka) {\n\t            delete object.nodes[key];\n\t            delete object.$nodes[key];\n\t        }\n\t\n\t        return object;\n\t    }\n\t\n\t    var $nodes = getNodes(object, node);\n\t    var retainBindings = [];\n\t    var retainNodes = [];\n\t\n\t    // iterate over all bindngs and compare their node with given nodes\n\t\n\t    // update nodes and $nodes for Matreshka instance\n\t    for (var _target8 = $nodes, _index6 = 0, nodesItem, _l12 = _target8.length; nodesItem = _target8[_index6], _index6 < _l12; _index6++) {\n\t        for (var _target7 = bindings, _index5 = 0, binding, _l11 = _target7.length; binding = _target7[_index5], _index5 < _l11; _index5++) {\n\t            if (binding.node === nodesItem) {\n\t                removeBinding({ object: object, key: key, eventOptions: eventOptions, binding: binding });\n\t            } else {\n\t                retainBindings.push(binding);\n\t                retainNodes.push(nodesItem);\n\t            }\n\t        }\n\t    }\n\t\n\t    if (object.isMatreshka) {\n\t        if (retainNodes.length) {\n\t            object.nodes[key] = retainNodes[0];\n\t            object.$nodes[key] = dom.$(retainNodes);\n\t        } else {\n\t            delete object.nodes[key];\n\t            delete object.$nodes[key];\n\t        }\n\t    }\n\t\n\t    // update bindings object\n\t    if (retainBindings.length) {\n\t        propDef.bindings = retainBindings;\n\t    } else {\n\t        propDef.bindings = null;\n\t    }\n\t\n\t    return object;\n\t}\n\n/***/ },\n/* 88 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar removeListener = __webpack_require__(74);\n\t\n\tvar triggerOne = __webpack_require__(20);\n\t\n\tvar spaceReg = /\\s+/;\n\t\n\t// the function removes single binding for single object\n\t// called by unbindNode\n\tmodule.exports = removeBinding;\n\tfunction removeBinding(_ref) {\n\t    var object = _ref.object;\n\t    var key = _ref.key;\n\t    var eventOptions = _ref.eventOptions;\n\t    var binding = _ref.binding;\n\t    var bindingOptions = binding.bindingOptions;\n\t    var binder = binding.binder;\n\t    var node = binding.node;\n\t    var nodeHandler = binding.nodeHandler;\n\t    var objectHandler = binding.objectHandler;\n\t    var destroy = binder.destroy;\n\t    var on = binder.on;\n\t    var silent = eventOptions.silent;\n\t\n\t    // if \"on\" is a function then disable it\n\t    // we cannot \"turn off\" custom listener defined by a programmer\n\t    // programmer needs to remove custom listener maually inside binder.destroy\n\t\n\t    if (typeof on === 'function') {\n\t        nodeHandler.disabled = true;\n\t    } else if (typeof on === 'string') {\n\t        for (var _target = on.split(spaceReg), _index = 0, evtName, _l = _target.length; evtName = _target[_index], _index < _l; _index++) {\n\t            node.removeEventListener(evtName, nodeHandler)\n\t        }\n\t        // remove DOM event listener\n\t        // removeEventListener is faster than \"on\" method from any DOM library\n\t\n\t    }\n\t\n\t    // remove object event listener\n\t    removeListener(object, '_change:bindings:' + key, objectHandler);\n\t\n\t    // if binder.destroy is given call it\n\t    if (destroy) {\n\t        destroy.call(node, bindingOptions);\n\t    }\n\t\n\t    // fire events\n\t    if (!silent) {\n\t        var _keys,\n\t            _l2,\n\t            _i,\n\t            _source,\n\t            _key,\n\t            _result = {};\n\t\n\t        _result.key = key\n\t        _result.node = node\n\t\n\t        for (_source = eventOptions, _keys = Object.keys(_source), _l2 = _keys.length, _i = 0; _i < _l2; _i++) {\n\t            _key = _keys[_i];\n\t            _result[_key] = _source[_key];\n\t        }\n\t\n\t        var extendedEventOptions = _result;\n\t\n\t        triggerOne(object, 'unbind:' + key, extendedEventOptions);\n\t        triggerOne(object, 'unbind', extendedEventOptions);\n\t    }\n\t}\n\n/***/ },\n/* 89 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar lookForBinder = __webpack_require__(10);\n\t\n\tvar createNodeHandler = __webpack_require__(90);\n\t\n\tvar createObjectHandler = __webpack_require__(91);\n\t\n\tvar triggerOne = __webpack_require__(20);\n\t\n\tvar addListener = __webpack_require__(17);\n\t\n\tvar debounce = __webpack_require__(66);\n\t\n\tvar matreshkaError = __webpack_require__(25);\n\t\n\tvar spaceReg = /\\s+/;\n\t\n\t// handles binding for single property & node\n\t// the function is used at bindNode\n\tmodule.exports = bindSingleNode;\n\tfunction bindSingleNode(object, _ref) {\n\t    var givenBinder = _ref.binder;\n\t    var key = _ref.key;\n\t    var $nodes = _ref.$nodes;\n\t    var node = _ref.node;\n\t    var eventOptions = _ref.eventOptions;\n\t    var propDef = _ref.propDef;\n\t    var silent = eventOptions.silent;\n\t    var getValueOnBind = eventOptions.getValueOnBind;\n\t    var setValueOnBind = eventOptions.setValueOnBind;\n\t    var _eventOptions$debounc = eventOptions.debounceSetValue;\n\t    var debounceSetValue = _eventOptions$debounc === undefined ? true : _eventOptions$debounc;\n\t    var _eventOptions$debounc2 = eventOptions.debounceGetValue;\n\t    var debounceGetValue = _eventOptions$debounc2 === undefined ? true : _eventOptions$debounc2;\n\t    var _eventOptions$debounc3 = eventOptions.debounceSetValueOnBind;\n\t    var debounceSetValueOnBind = _eventOptions$debounc3 === undefined ? false : _eventOptions$debounc3;\n\t    var _eventOptions$debounc4 = eventOptions.debounceGetValueOnBind;\n\t    var debounceGetValueOnBind = _eventOptions$debounc4 === undefined ? false : _eventOptions$debounc4;\n\t    var _eventOptions$debounc5 = eventOptions.debounceSetValueDelay;\n\t    var debounceSetValueDelay = _eventOptions$debounc5 === undefined ? 0 : _eventOptions$debounc5;\n\t    var _eventOptions$debounc6 = eventOptions.debounceGetValueDelay;\n\t    var debounceGetValueDelay = _eventOptions$debounc6 === undefined ? 0 : _eventOptions$debounc6;\n\t    var _eventOptions$useExac = eventOptions.useExactBinder;\n\t    var useExactBinder = _eventOptions$useExac === undefined ? false : _eventOptions$useExac;\n\t    // create bindings array in property definition object\n\t\n\t    var bindings = propDef.bindings = propDef.bindings || [];\n\t    var value = propDef.value;\n\t\n\t    var bindingOptions = {\n\t        self: object,\n\t        key: key,\n\t        value: value,\n\t        $nodes: $nodes,\n\t        node: node\n\t    };\n\t    var isUndefined = typeof value === 'undefined';\n\t    var binder = void 0;\n\t    var objectHandler = void 0;\n\t    var nodeHandler = void 0;\n\t\n\t    // do not allow to bind more than 2 nodes to \"sandbox\" (for all nodes)\n\t    // and \"container\" (for Matreshka.Array)\n\t    if (bindings.length && (key === 'sandbox' || object.isMatreshkaArray && key === 'container')) {\n\t        throw matreshkaError('binding:magic_props_nodes_length');\n\t    }\n\t\n\t    // get actual binder\n\t    if (givenBinder !== null) {\n\t        // by default binder passed to bindNode is extended by default binder\n\t        // useExactBinder turns this behavior off\n\t        if (useExactBinder) {\n\t            binder = givenBinder;\n\t        } else {\n\t            // getting default binder\n\t            var foundBinder = lookForBinder(node);\n\t\n\t            // if default binder is found\n\t            if (foundBinder) {\n\t                // extend found binder by given binder\n\t                if (givenBinder) {\n\t                    var _result = foundBinder;\n\t\n\t                    for (var _source2 = givenBinder, _keys2 = Object.keys(_source2), _l2 = _keys2.length, _i2 = 0, _key2; _i2 < _l2; _i2++) {\n\t                        _key2 = _keys2[_i2];\n\t                        _result[_key2] = _source2[_key2];\n\t                    }\n\t                }\n\t\n\t                binder = foundBinder;\n\t            } else {\n\t                // default binder is not found\n\t                binder = givenBinder || {};\n\t            }\n\t        }\n\t    }\n\t\n\t    var _binder = binder;\n\t    var getValue = _binder.getValue;\n\t    var setValue = _binder.setValue;\n\t    var on = _binder.on;\n\t    var initialize = _binder.initialize;\n\t\n\t    // call binder.initialize\n\t\n\t    if (initialize) {\n\t        initialize.call(node, bindingOptions);\n\t    }\n\t\n\t    // add needed event handlers to given node when getValue is given\n\t    if (getValue) {\n\t        var syncNodeHandler = createNodeHandler({\n\t            object: object,\n\t            key: key,\n\t            node: node,\n\t            propDef: propDef,\n\t            binder: binder,\n\t            bindingOptions: bindingOptions\n\t        });\n\t\n\t        var debouncedNodeHandler = void 0;\n\t\n\t        if (debounceGetValue || debounceGetValueOnBind) {\n\t            debouncedNodeHandler = debounce(syncNodeHandler, debounceGetValueDelay);\n\t        }\n\t\n\t        if (debounceGetValue) {\n\t            nodeHandler = debouncedNodeHandler;\n\t        } else {\n\t            nodeHandler = syncNodeHandler;\n\t        }\n\t\n\t        // TODO: Throw error when \"on\" and maybe other binder properties has wrong type\n\t        if (typeof on === 'function') {\n\t            on.call(node, nodeHandler, bindingOptions);\n\t        } else if (typeof on === 'string') {\n\t            for (var _target = on.split(spaceReg), _index = 0, evtName, _l3 = _target.length; evtName = _target[_index], _index < _l3; _index++) {\n\t                node.addEventListener(evtName, nodeHandler)\n\t            }\n\t            // addEventListener is faster than \"on\" method from any DOM library\n\t\n\t        }\n\t\n\t        if (isUndefined && getValueOnBind !== false || getValueOnBind === true) {\n\t            if (debounceGetValueOnBind) {\n\t                debouncedNodeHandler();\n\t            } else {\n\t                syncNodeHandler();\n\t            }\n\t        }\n\t\n\t        isUndefined = typeof propDef.value === 'undefined';\n\t    }\n\t\n\t    // add needed event handlers to the object when setValue is given\n\t    if (setValue) {\n\t        var syncObjectHandler = createObjectHandler({\n\t            node: node,\n\t            propDef: propDef,\n\t            binder: binder,\n\t            bindingOptions: bindingOptions,\n\t            eventOptions: eventOptions\n\t        });\n\t\n\t        var debouncedObjectHandler = void 0;\n\t\n\t        if (debounceSetValue || debounceSetValueOnBind) {\n\t            debouncedObjectHandler = debounce(syncObjectHandler, debounceSetValueDelay);\n\t        }\n\t\n\t        if (debounceSetValue) {\n\t            objectHandler = debouncedObjectHandler;\n\t        } else {\n\t            objectHandler = syncObjectHandler;\n\t        }\n\t\n\t        // TODO: Is it possible to get previous value of a property?\n\t        addListener(object, '_change:bindings:' + key, objectHandler, null, { skipChecks: true });\n\t\n\t        if (!isUndefined && setValueOnBind !== false || setValueOnBind === true) {\n\t            if (debounceSetValueOnBind) {\n\t                debouncedObjectHandler();\n\t            } else {\n\t                syncObjectHandler();\n\t            }\n\t        }\n\t    }\n\t\n\t    // add binding data to bindings array\n\t    bindings.push({\n\t        on: on,\n\t        node: node,\n\t        binder: binder,\n\t        objectHandler: objectHandler,\n\t        nodeHandler: nodeHandler,\n\t        bindingOptions: bindingOptions\n\t    });\n\t\n\t    // fire events\n\t    if (!silent) {\n\t        var _keys3,\n\t            _l4,\n\t            _i3,\n\t            _source3,\n\t            _key3,\n\t            _result2 = {};\n\t\n\t        _result2.key = key\n\t        _result2.node = node\n\t\n\t        for (_source3 = eventOptions, _keys3 = Object.keys(_source3), _l4 = _keys3.length, _i3 = 0; _i3 < _l4; _i3++) {\n\t            _key3 = _keys3[_i3];\n\t            _result2[_key3] = _source3[_key3];\n\t        }\n\t\n\t        var extendedEventOptions = _result2;\n\t\n\t        triggerOne(object, 'bind:' + key, extendedEventOptions);\n\t        triggerOne(object, 'bind', extendedEventOptions);\n\t    }\n\t}\n\n/***/ },\n/* 90 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar is = __webpack_require__(26);\n\t\n\tvar set = __webpack_require__(23);\n\t\n\t// returns a function which called when bound node state is changed (eg DOM event is fired)\n\tmodule.exports = createNodeHandler;\n\tfunction createNodeHandler(_ref) {\n\t    var object = _ref.object;\n\t    var key = _ref.key;\n\t    var node = _ref.node;\n\t    var propDef = _ref.propDef;\n\t    var binder = _ref.binder;\n\t    var bindingOptions = _ref.bindingOptions;\n\t\n\t    return function nodeHandler() {\n\t        var domEvent = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t        // nodeHandler.disabled = true is set in unbindNode\n\t        // we cannot \"turn off\" binder.on when its value is a function\n\t        // developer needs to clean memory (\"turn off\" callback) manualy in binder.destroy\n\t        if (nodeHandler.disabled) {\n\t            return;\n\t        }\n\t\n\t        var previousValue = propDef.value;\n\t        var which = domEvent.which;\n\t        var target = domEvent.target;\n\t        var ctrlKey = domEvent.ctrlKey;\n\t        var altKey = domEvent.altKey;\n\t        var getValue = binder.getValue;\n\t\n\t        var _keys,\n\t            _l,\n\t            _i,\n\t            _source,\n\t            _key,\n\t            _result = {};\n\t\n\t        _result.previousValue = previousValue\n\t        _result.domEvent = domEvent\n\t        _result.originalEvent = domEvent.originalEvent || domEvent\n\t\n\t        _result.preventDefault = function () {\n\t            return domEvent.preventDefault();\n\t        }\n\t\n\t        _result.stopPropagation = function () {\n\t            return domEvent.stopPropagation();\n\t        }\n\t\n\t        _result.which = which\n\t        _result.target = target\n\t        _result.ctrlKey = ctrlKey\n\t        _result.altKey = altKey\n\t\n\t        for (_source = bindingOptions, _keys = Object.keys(_source), _l = _keys.length, _i = 0; _i < _l; _i++) {\n\t            _key = _keys[_i];\n\t            _result[_key] = _source[_key];\n\t        }\n\t\n\t        var value = getValue.call(node, _result);\n\t\n\t        if (!is(value, previousValue)) {\n\t            set(object, key, value, {\n\t                fromNode: true,\n\t                // the following properties are needed to avoid circular changes\n\t                // they are used at objectHandler\n\t                changedNode: node,\n\t                onChangeValue: value,\n\t                binder: binder\n\t            });\n\t        }\n\t    };\n\t}\n\n/***/ },\n/* 91 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t// returns a function which is called when property value is changed\n\tmodule.exports = createObjectHandler;\n\tfunction createObjectHandler(_ref) {\n\t    var node = _ref.node;\n\t    var propDef = _ref.propDef;\n\t    var binder = _ref.binder;\n\t    var bindingOptions = _ref.bindingOptions;\n\t\n\t    return function objectHandler() {\n\t        var eventOptions = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t        var value = propDef.value;\n\t        var onChangeValue = eventOptions.onChangeValue;\n\t        var changedNode = eventOptions.changedNode;\n\t        var evtBinder = eventOptions.binder;\n\t        var setValue = binder.setValue;\n\t        // dirty hack for https://github.com/matreshkajs/matreshka/issues/19\n\t\n\t        var dirtyHackValue = onChangeValue === 'string' && typeof value === 'number' ? '' + value : value;\n\t\n\t        // don't call setValue if a property is changed via getValue of the same binder\n\t        if (changedNode === node && onChangeValue === dirtyHackValue && evtBinder === binder) {\n\t            return;\n\t        }\n\t\n\t        var _keys,\n\t            _l,\n\t            _i,\n\t            _source,\n\t            _key,\n\t            _result = {};\n\t\n\t        _result.value = value\n\t\n\t        for (_source = bindingOptions, _keys = Object.keys(_source), _l = _keys.length, _i = 0; _i < _l; _i++) {\n\t            _key = _keys[_i];\n\t            _result[_key] = _source[_key];\n\t        }\n\t\n\t        setValue.call(node, value, _result);\n\t    };\n\t}\n\n/***/ },\n/* 92 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar getBindingKey = __webpack_require__(93);\n\t\n\tvar bindNode = __webpack_require__(82);\n\t\n\tvar lookForBinder = __webpack_require__(10);\n\t\n\t// a binder for instance of Attr\n\tvar attributeBinder = {\n\t    setValue: function (value) {\n\t        this.value = value;\n\t    }\n\t};\n\t\n\t// adds binding for an attribute\n\t// its logic is much harder than for text node\n\t// check out imported modules for more info\n\tmodule.exports = processAttribute;\n\tfunction processAttribute(_ref) {\n\t    var node = _ref.node;\n\t    var attribute = _ref.attribute;\n\t    var object = _ref.object;\n\t    var eventOptions = _ref.eventOptions;\n\t    var name = attribute.name;\n\t    var value = attribute.value;\n\t    var type = node.type;\n\t    // get a key which will be actually bound to an attribute\n\t    // getBindingKey analyzes given value, creates computable property and returns its key\n\t\n\t    var key = getBindingKey({\n\t        object: object,\n\t        text: value\n\t    });\n\t    var probablyValueInput = name === 'value' && type !== 'checkbox' && type !== 'radio';\n\t    var probablyCheckableInput = name === 'checked' && (type === 'checkbox' || type === 'radio');\n\t\n\t    var defaultBinder = void 0;\n\t\n\t    if (probablyValueInput || probablyCheckableInput) {\n\t        defaultBinder = lookForBinder(node);\n\t    }\n\t\n\t    if (defaultBinder) {\n\t        // if deault binder is found then this is default HTML5 form element\n\t        // remove the attribute and use found binder\n\t        node.setAttribute(name, '');\n\t        bindNode(object, key, node, defaultBinder, eventOptions);\n\t    } else {\n\t        // simply bind an attribute\n\t        bindNode(object, key, attribute, attributeBinder, eventOptions);\n\t    }\n\t}\n\n/***/ },\n/* 93 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar parserData = __webpack_require__(64);\n\t\n\tvar defineHiddenContentProperty = __webpack_require__(94);\n\t\n\t// analyzes string and returns only one key which will be actually bound to an attribute\n\tmodule.exports = getBindingKey;\n\tfunction getBindingKey(_ref) {\n\t    var object = _ref.object;\n\t    var text = _ref.text;\n\t    var strictBindingReg = parserData.strictBindingReg;\n\t    var bindingReg = parserData.bindingReg;\n\t\n\t    var keys = [];\n\t\n\t    var execResult = void 0;\n\t    var key = void 0;\n\t\n\t    strictBindingReg.lastIndex = 0;\n\t    bindingReg.lastIndex = 0;\n\t\n\t    // extract keys given in parser brackers\n\t    // '{{x}} {{y}}' -> ['x', 'y']\n\t    while (execResult = bindingReg.exec(text)) {\n\t        keys.push(execResult[1]);\n\t    }\n\t\n\t    if (keys.length === 1 && strictBindingReg.test(text)) {\n\t        // if there is only one key and if only binding substring is present in a text\n\t        // in other words '{{x}}' is given instead of '{{x}} {{y}}' or '{{x}}foo'\n\t        // then don't create computable property and use that key (eg 'x') for binding\n\t        key = keys[0];\n\t    } else {\n\t        // create hidden computable property\n\t        key = defineHiddenContentProperty({\n\t            object: object,\n\t            keys: keys,\n\t            text: text\n\t        });\n\t    }\n\t\n\t    return key;\n\t}\n\n/***/ },\n/* 94 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar calc = __webpack_require__(65);\n\t\n\tvar parserData = __webpack_require__(64);\n\t\n\tvar hiddenPropertyPrefix = ('' + Math.random()).replace('0.', 'hidden');\n\tvar hiddenPropertyIndex = 0;\n\t\n\t// defines hiden (without accessors) computed property\n\t// that dependent on given properties ('keys') as text template describes\n\t// for example if text='{{x}} blah {{y}}', x='foo', y='bar'\n\t// then the new property should have value 'foo blah bar'\n\tmodule.exports = defineHiddenContentProperty;\n\tfunction defineHiddenContentProperty(_ref) {\n\t    var object = _ref.object;\n\t    var keys = _ref.keys;\n\t    var text = _ref.text;\n\t\n\t    var key = '' + hiddenPropertyPrefix + hiddenPropertyIndex;\n\t    var regs = {};\n\t    var escLeftBracket = parserData.escLeftBracket;\n\t    var escRightBracket = parserData.escRightBracket;\n\t\n\t\n\t    hiddenPropertyIndex += 1;\n\t\n\t    // create and cache regular expressions which will help us to\n\t    // change target property value quickly when sources are changed\n\t    for (var i = 0; i < keys.length; i++) {\n\t        regs[keys[i]] = new RegExp(escLeftBracket + keys[i] + escRightBracket, 'g');\n\t    }\n\t\n\t    calc(object, key, keys, function calcHandler() {\n\t        var value = text;\n\t\n\t        // replace things like {{x}} by actual values\n\t        for (var _i = 0; _i < keys.length; _i++) {\n\t            value = value.replace(regs[keys[_i]], arguments[_i]);\n\t        }\n\t\n\t        return value;\n\t    }, {\n\t        isTargetPropertyHidden: true,\n\t        debounceCalc: false\n\t    });\n\t\n\t    return key;\n\t}\n\n/***/ },\n/* 95 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar defs = __webpack_require__(19);\n\t\n\tvar matreshkaError = __webpack_require__(25);\n\t\n\t// checks is item already rendered in an array\n\t// selfDef is given instead of itself (array) for perf optimisation\n\tmodule.exports = checkAlreadyRendered;\n\tfunction checkAlreadyRendered(_ref) {\n\t    var item = _ref.item;\n\t    var selfDef = _ref.selfDef;\n\t\n\t    var itemDef = defs.get(item);\n\t    var selfId = selfDef.id;\n\t\n\t    // if item object is defined in object defs\n\t\n\t    if (itemDef) {\n\t        var renderedInArrays = itemDef.renderedInArrays;\n\t\n\t        // if item's node is already rendered for an array\n\t        // then throw an error\n\t\n\t        if (renderedInArrays && renderedInArrays[selfId]) {\n\t            throw matreshkaError('array:add_render_twice');\n\t        }\n\t    }\n\t}\n\n/***/ },\n/* 96 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar renderItemNode = __webpack_require__(62);\n\t\n\tvar triggerOne = __webpack_require__(20);\n\t\n\tvar checkAlreadyRendered = __webpack_require__(95);\n\t\n\t// this function renders inserted items if possible when unshift or push method is called\n\tmodule.exports = processUnshift;\n\tfunction processUnshift(_ref) {\n\t    var self = _ref.self;\n\t    var selfDef = _ref.selfDef;\n\t    var eventOptions = _ref.eventOptions;\n\t    var container = _ref.container;\n\t    var added = eventOptions.added;\n\t    var silent = eventOptions.silent;\n\t\n\t    // iterate over all added items in opposite order\n\t\n\t    for (var i = added.length - 1; i + 1; i--) {\n\t        var item = added[i];\n\t        if (item && typeof item === 'object') {\n\t            // if a node of an item is already rendered then throw an error\n\t            checkAlreadyRendered({\n\t                item: item,\n\t                selfDef: selfDef\n\t            });\n\t\n\t            var _renderItemNode = renderItemNode({\n\t                selfDef: selfDef,\n\t                self: self,\n\t                item: item,\n\t                eventOptions: eventOptions\n\t            });\n\t\n\t            var node = _renderItemNode.node;\n\t            var itemEventOptions = _renderItemNode.itemEventOptions;\n\t\n\t\n\t            if (node) {\n\t                if (container.firstChild) {\n\t                    container.insertBefore(node, container.firstChild);\n\t                } else {\n\t                    container.appendChild(node);\n\t                }\n\t\n\t                if (!silent) {\n\t                    triggerOne(item, 'afterrender', itemEventOptions);\n\t                }\n\t            }\n\t        }\n\t    }\n\t}\n\n/***/ },\n/* 97 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar renderItemNode = __webpack_require__(62);\n\t\n\tvar triggerOne = __webpack_require__(20);\n\t\n\tvar defs = __webpack_require__(19);\n\t\n\tvar matreshkaError = __webpack_require__(25);\n\t\n\tvar getAlreadyRendered = __webpack_require__(98);\n\t\n\t// this function renders inserted items if possible when recreate method is called\n\tmodule.exports = processRecreate;\n\tfunction processRecreate(_ref) {\n\t    var self = _ref.self;\n\t    var selfDef = _ref.selfDef;\n\t    var eventOptions = _ref.eventOptions;\n\t    var container = _ref.container;\n\t    var removed = eventOptions.removed;\n\t    var silent = eventOptions.silent;\n\t    var selfId = selfDef.id;\n\t\n\t    // iterate over removed items and remove their nodes\n\t\n\t    for (var _target = removed, _index = 0, item, _l = _target.length; item = _target[_index], _index < _l; _index++) {\n\t        var itemDef = defs.get(item);\n\t\n\t        if (itemDef) {\n\t            var renderedInArrays = itemDef.renderedInArrays;\n\t\n\t            var node = renderedInArrays && renderedInArrays[selfId];\n\t            if (node) {\n\t                delete itemDef.renderedInArrays[selfId];\n\t                container.removeChild(node);\n\t            }\n\t        }\n\t    }\n\t\n\t    var alreadyRenderedMap = {};\n\t\n\t    // iterate over all items\n\t    // the following approach allows to throw an error when two added objects are the same\n\t    // (not only compare existing items with old ones)\n\t\n\t    for (var _target2 = self, _index2 = 0, item, _l2 = _target2.length; item = _target2[_index2], _index2 < _l2; _index2++) {\n\t        if (item && typeof item === 'object') {\n\t            var itemDef = defs.get(item);\n\t            var alreadyRenderedNode = void 0;\n\t\n\t            if (itemDef) {\n\t                alreadyRenderedNode = getAlreadyRendered({\n\t                    item: item,\n\t                    selfDef: selfDef\n\t                });\n\t            }\n\t\n\t            if (alreadyRenderedNode) {\n\t                // if an item is already rendered (old item)\n\t                if (itemDef.id in alreadyRenderedMap) {\n\t                    // if an item is rendered twice throw an error\n\t                    throw matreshkaError('array:add_render_twice');\n\t                }\n\t\n\t                alreadyRenderedMap[itemDef.id] = true;\n\t\n\t                container.appendChild(alreadyRenderedNode);\n\t            } else {\n\t                // this is newly added item\n\t                var _renderItemNode = renderItemNode({\n\t                    selfDef: selfDef,\n\t                    self: self,\n\t                    item: item,\n\t                    eventOptions: eventOptions\n\t                });\n\t\n\t                var node = _renderItemNode.node;\n\t                var itemEventOptions = _renderItemNode.itemEventOptions;\n\t\n\t\n\t                if (node) {\n\t                    // itemDef is defined at renderItemNode if not defined before\n\t                    // reload this variable\n\t                    itemDef = itemDef || defs.get(item);\n\t\n\t                    if (itemDef.id in alreadyRenderedMap) {\n\t                        // if newly added item is rendered twice throw an error\n\t                        throw matreshkaError('array:add_render_twice');\n\t                    }\n\t\n\t                    alreadyRenderedMap[itemDef.id] = true;\n\t\n\t                    container.appendChild(node);\n\t\n\t                    if (!silent) {\n\t                        triggerOne(item, 'afterrender', itemEventOptions);\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\t}\n\n/***/ },\n/* 98 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar defs = __webpack_require__(19);\n\t\n\t// returns already rendered node of an object in given array\n\t// selfDef is given instead of  itself (array) for perf optimisation\n\tmodule.exports = getAlreadyRendered;\n\tfunction getAlreadyRendered(_ref) {\n\t    var item = _ref.item;\n\t    var selfDef = _ref.selfDef;\n\t\n\t    var itemDef = defs.get(item);\n\t    var selfId = selfDef.id;\n\t\n\t    // if item object is defined in object defs\n\t\n\t    if (itemDef) {\n\t        var renderedInArrays = itemDef.renderedInArrays;\n\t\n\t        // if item's node is already rendered for an array then return it\n\t\n\t        if (renderedInArrays && renderedInArrays[selfId]) {\n\t            return renderedInArrays[selfId];\n\t        }\n\t    }\n\t\n\t    return undefined;\n\t}\n\n/***/ },\n/* 99 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar getAlreadyRendered = __webpack_require__(98);\n\t\n\t// this function gets called when array is sorted (via sort, orderBy or reverse)\n\tmodule.exports = processSort;\n\tfunction processSort(_ref) {\n\t    var self = _ref.self;\n\t    var selfDef = _ref.selfDef;\n\t    var container = _ref.container;\n\t    // just re-insert rendered nodes in new order\n\t\n\t    for (var _target = self, _index = 0, item, _l = _target.length; item = _target[_index], _index < _l; _index++) {\n\t        if (item && typeof item === 'object') {\n\t            var node = getAlreadyRendered({\n\t                item: item,\n\t                selfDef: selfDef\n\t            });\n\t\n\t            if (node) {\n\t                container.appendChild(node);\n\t            }\n\t        }\n\t    }\n\t}\n\n/***/ },\n/* 100 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar defs = __webpack_require__(19);\n\t\n\t// this function removes DOM nodes of removed items\n\t// called on splice, pull, pop and shift\n\tmodule.exports = processRemove;\n\tfunction processRemove(_ref) {\n\t    var selfDef = _ref.selfDef;\n\t    var eventOptions = _ref.eventOptions;\n\t    var container = _ref.container;\n\t    var removed = eventOptions.removed;\n\t    var selfId = selfDef.id;\n\t\n\t    for (var _target = removed, _index = 0, item, _l = _target.length; item = _target[_index], _index < _l; _index++) {\n\t        if (item && typeof item === 'object') {\n\t            var itemDef = defs.get(item);\n\t            if (itemDef) {\n\t                var renderedInArrays = itemDef.renderedInArrays;\n\t\n\t                var node = renderedInArrays && renderedInArrays[selfId];\n\t                if (node) {\n\t                    delete renderedInArrays[selfId];\n\t                    container.removeChild(node);\n\t                }\n\t            }\n\t        }\n\t    }\n\t}\n\n/***/ },\n/* 101 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar getAlreadyRendered = __webpack_require__(98);\n\t\n\tvar renderItemNode = __webpack_require__(62);\n\t\n\tvar triggerOne = __webpack_require__(20);\n\t\n\t// this function re-inserts rendered DOM nodes of items\n\t// if they are rendered and forceRerender is falsy\n\t// and renders array items from scratch if they aren't rendered yet or forceRerender is truthy\n\tmodule.exports = processRerender;\n\tfunction processRerender(_ref) {\n\t    var self = _ref.self;\n\t    var selfDef = _ref.selfDef;\n\t    var eventOptions = _ref.eventOptions;\n\t    var container = _ref.container;\n\t    var forceRerender = eventOptions.forceRerender;\n\t    var silent = eventOptions.silent;\n\t\n\t    // iterate over all items\n\t\n\t    for (var i = 0; i < self.length; i++) {\n\t        var item = self[i];\n\t        if (item && typeof item === 'object') {\n\t            var alreadyRenderedNode = getAlreadyRendered({\n\t                item: item,\n\t                selfDef: selfDef\n\t            });\n\t\n\t            // if item is already rendered and forceRerender is falsy then re-insert DOM node\n\t            // go to the next cycle iteration then\n\t            if (!forceRerender && alreadyRenderedNode) {\n\t                container.appendChild(alreadyRenderedNode);\n\t                continue;\n\t            }\n\t\n\t            // node removal is called when an item is rendered\n\t            // and forceRerender is truty\n\t            if (alreadyRenderedNode) {\n\t                if (container.contains(alreadyRenderedNode)) {\n\t                    container.removeChild(alreadyRenderedNode);\n\t                }\n\t            }\n\t\n\t            // render new node\n\t\n\t            var _renderItemNode = renderItemNode({\n\t                selfDef: selfDef,\n\t                self: self,\n\t                item: item,\n\t                eventOptions: eventOptions\n\t            });\n\t\n\t            var node = _renderItemNode.node;\n\t            var itemEventOptions = _renderItemNode.itemEventOptions;\n\t\n\t\n\t            if (node) {\n\t                container.appendChild(node);\n\t\n\t                if (!silent) {\n\t                    triggerOne(item, 'afterrender', itemEventOptions);\n\t                }\n\t            }\n\t        }\n\t    }\n\t}\n\n/***/ },\n/* 102 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar renderItemNode = __webpack_require__(62);\n\t\n\tvar triggerOne = __webpack_require__(20);\n\t\n\tvar checkAlreadyRendered = __webpack_require__(95);\n\t\n\tvar getAlreadyRendered = __webpack_require__(98);\n\t\n\t// the function handles rendering of added items passed as third and rest arguments to splice method\n\tmodule.exports = processSpliceAdd;\n\tfunction processSpliceAdd(_ref) {\n\t    var self = _ref.self;\n\t    var selfDef = _ref.selfDef;\n\t    var eventOptions = _ref.eventOptions;\n\t    var container = _ref.container;\n\t    var added = eventOptions.added;\n\t    var silent = eventOptions.silent;\n\t\n\t    var nextIndex = self.lastIndexOf(added[added.length - 1]) + 1;\n\t    var next = self[nextIndex];\n\t    var nextNode = void 0;\n\t\n\t    // get a node of an item which is placed next to the last added item\n\t    // it is needed to insert newly rendered items before\n\t    if (next && typeof next === 'object') {\n\t        nextNode = getAlreadyRendered({\n\t            item: next,\n\t            selfDef: selfDef\n\t        });\n\t    }\n\t\n\t    for (var _target = added, _index = 0, item, _l = _target.length; item = _target[_index], _index < _l; _index++) {\n\t        if (item && typeof item === 'object') {\n\t            // throw an error if node of an item is alread rendered\n\t            checkAlreadyRendered({\n\t                item: item,\n\t                selfDef: selfDef\n\t            });\n\t\n\t            var _renderItemNode = renderItemNode({\n\t                selfDef: selfDef,\n\t                self: self,\n\t                item: item,\n\t                eventOptions: eventOptions\n\t            });\n\t\n\t            var node = _renderItemNode.node;\n\t            var itemEventOptions = _renderItemNode.itemEventOptions;\n\t\n\t\n\t            if (node) {\n\t                if (nextNode) {\n\t                    container.insertBefore(node, nextNode);\n\t                } else {\n\t                    container.appendChild(node);\n\t                }\n\t\n\t                if (!silent) {\n\t                    triggerOne(item, 'afterrender', itemEventOptions);\n\t                }\n\t            }\n\t        }\n\t    }\n\t}\n\n/***/ },\n/* 103 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar reportModified = __webpack_require__(59);\n\t\n\tvar matreshkaError = __webpack_require__(25);\n\t\n\t// removes array item by given index\n\tfunction shift(arr, index) {\n\t    for (var i = index; i < arr.length; i++) {\n\t        arr[i] = arr[i + 1];\n\t    }\n\t    delete arr[arr.length - 1];\n\t    arr.length -= 1;\n\t}\n\t\n\t// finds array item that equals to given value and removes it\n\t// returns removed value\n\tfunction pullByValue(arr, value) {\n\t    for (var i = 0; i < arr.length; i++) {\n\t        if (arr[i] === value) {\n\t            shift(arr, i);\n\t            return value;\n\t        }\n\t    }\n\t\n\t    return undefined;\n\t}\n\t\n\t// removes array item by given index if the index is not over array length\n\t// returns removed value\n\tfunction pullByIndex(arr, index) {\n\t    if (index < arr.length) {\n\t        var value = arr[index];\n\t        shift(arr, index);\n\t        return value;\n\t    }\n\t\n\t    return undefined;\n\t}\n\t\n\t// removes an array item by index (if number is given) or by value (if object is given)\n\tmodule.exports = pull;\n\tfunction pull(toRemove) {\n\t    var eventOptions = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\n\t    var typeofToRemove = typeof toRemove;\n\t    var removed = void 0;\n\t\n\t    if (toRemove && typeofToRemove === 'object') {\n\t        removed = pullByValue(this, toRemove);\n\t    } else if (typeofToRemove === 'number') {\n\t        removed = pullByIndex(this, toRemove);\n\t    } else {\n\t        throw matreshkaError('pull:to_remove_type', { toRemove: toRemove });\n\t    }\n\t\n\t    if (typeof removed !== 'undefined') {\n\t        var _keys,\n\t            _l,\n\t            _i,\n\t            _source,\n\t            _key,\n\t            _result = {};\n\t\n\t        _result.method = 'pull'\n\t        _result.self = this\n\t        _result.added = []\n\t        _result.removed = [removed]\n\t\n\t        for (_source = eventOptions, _keys = Object.keys(_source), _l = _keys.length, _i = 0; _i < _l; _i++) {\n\t            _key = _keys[_i];\n\t            _result[_key] = _source[_key];\n\t        }\n\t\n\t        reportModified(this, _result);\n\t    }\n\t\n\t    return removed;\n\t}\n\n/***/ },\n/* 104 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar initMK = __webpack_require__(18);\n\t\n\tvar reportModified = __webpack_require__(59);\n\t\n\tvar updateTracked = __webpack_require__(105);\n\t\n\t// recreates an array\n\tmodule.exports = recreate;\n\tfunction recreate() {\n\t    var givenNewItems = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\n\t    var eventOptions = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\n\t    var def = initMK(this);\n\t    var itemMediator = def.itemMediator;\n\t\n\t    var newLength = givenNewItems.length;\n\t    var oldLength = this.length;\n\t    var lengthDiff = oldLength - newLength;\n\t    var was = this.toJSON(false);\n\t    var trackBy = this.trackBy;\n\t    var skipItemMediator = eventOptions.skipItemMediator;\n\t    var silent = eventOptions.silent;\n\t    var dontRender = eventOptions.dontRender;\n\t\n\t    var added = void 0;\n\t    var removed = void 0;\n\t    var newItems = void 0;\n\t\n\t    if (trackBy) {\n\t        // if trackBy property is given then update givenNewItems array\n\t        newItems = updateTracked({\n\t            arr: this,\n\t            givenNewItems: givenNewItems,\n\t            trackBy: trackBy\n\t        });\n\t    } else {\n\t        // if trackBy is not given then use given new items as is\n\t        newItems = givenNewItems;\n\t    }\n\t\n\t    // call item mediator for every new item (but don't modify passed newItems)\n\t    if (itemMediator && !skipItemMediator) {\n\t        var toMediate = newItems;\n\t        newItems = Array(newLength);\n\t        for (var i = 0; i < newLength; i++) {\n\t            newItems[i] = itemMediator(toMediate[i], i);\n\t        }\n\t    }\n\t\n\t    // update array indexes with new values\n\t    for (var _i = 0; _i < newLength; _i++) {\n\t        this[_i] = newItems[_i];\n\t    }\n\t\n\t    // remove old items that is out of new length\n\t    for (var _i2 = 0; _i2 < lengthDiff; _i2++) {\n\t        delete this[_i2 + newLength];\n\t    }\n\t\n\t    // update length\n\t    this.length = newLength;\n\t\n\t    if (silent && dontRender) {\n\t        return this;\n\t    }\n\t\n\t    // create an array of removed items\n\t    // TODO: Optimize creation of \"added\" and \"removed\" options in recreate method\n\t    // ... (do not use indexOf)\n\t    if (newLength) {\n\t        if (oldLength) {\n\t            removed = [];\n\t            for (var _i3 = 0; _i3 < oldLength; _i3++) {\n\t                if (!~newItems.indexOf(was[_i3])) {\n\t                    removed.push(was[_i3]);\n\t                }\n\t            }\n\t        } else {\n\t            removed = [];\n\t        }\n\t    } else {\n\t        removed = was;\n\t    }\n\t\n\t    // create an array of added items\n\t    if (oldLength) {\n\t        if (newLength) {\n\t            added = [];\n\t            for (var _i4 = 0; _i4 < newLength; _i4++) {\n\t                if (!~was.indexOf(newItems[_i4])) {\n\t                    added.push(newItems[_i4]);\n\t                }\n\t            }\n\t        } else {\n\t            added = [];\n\t        }\n\t    } else {\n\t        added = newItems;\n\t    }\n\t\n\t    var _keys,\n\t        _l,\n\t        _i5,\n\t        _source,\n\t        _key,\n\t        _result = {};\n\t\n\t    _result.added = added\n\t    _result.removed = removed\n\t    _result.method = 'recreate'\n\t    _result.self = this\n\t\n\t    for (_source = eventOptions, _keys = Object.keys(_source), _l = _keys.length, _i5 = 0; _i5 < _l; _i5++) {\n\t        _key = _keys[_i5];\n\t        _result[_key] = _source[_key];\n\t    }\n\t\n\t    reportModified(this, _result);\n\t\n\t    return this;\n\t}\n\n/***/ },\n/* 105 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar updateObject = __webpack_require__(106);\n\t\n\t// the function gets called to update new items passed to recreate method when trackBy is present\n\t// TODO: Throw an error when two or more items of one array has the same value of trackBy\n\tmodule.exports = updateTracked;\n\tfunction updateTracked(_ref) {\n\t    var givenNewItems = _ref.givenNewItems;\n\t    var arr = _ref.arr;\n\t    var trackBy = _ref.trackBy;\n\t\n\t    var newLength = givenNewItems.length;\n\t    var oldLength = arr.length;\n\t    var newItems = Array(newLength);\n\t\n\t    if (trackBy === '$index') {\n\t        // simply update items with the same index\n\t        for (var i = 0; i < newLength; i++) {\n\t            var item = arr[i];\n\t            var newItem = givenNewItems[i];\n\t\n\t            if (item && typeof item === 'object' && newItem && typeof newItem === 'object') {\n\t                newItems[i] = updateObject(item, newItem);\n\t            } else {\n\t                newItems[i] = newItem;\n\t            }\n\t        }\n\t    } else {\n\t        var trackMap = {};\n\t\n\t        // fill trackMap object where keys are values of trackBy and values are corresponding items\n\t        for (var _i = 0; _i < oldLength; _i++) {\n\t            var _item = arr[_i];\n\t\n\t            if (_item && typeof _item === 'object') {\n\t                if (trackBy in _item) {\n\t                    trackMap[_item[trackBy]] = _item;\n\t                }\n\t            }\n\t        }\n\t\n\t        for (var _i2 = 0; _i2 < newLength; _i2++) {\n\t            var _newItem = givenNewItems[_i2];\n\t\n\t            if (_newItem && typeof _newItem === 'object') {\n\t                var _item2 = arr[_i2];\n\t\n\t                if (_item2 && typeof _item2 === 'object' && _newItem[trackBy] in trackMap) {\n\t                    // if an item exists at trackMap then update it\n\t                    newItems[_i2] = updateObject(trackMap[_newItem[trackBy]], _newItem);\n\t                } else {\n\t                    // if not then use new value as is\n\t                    newItems[_i2] = _newItem;\n\t                }\n\t            } else {\n\t                // newItem is not an object\n\t                newItems[_i2] = _newItem;\n\t            }\n\t        }\n\t    }\n\t\n\t    return newItems;\n\t}\n\n/***/ },\n/* 106 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\t// updates one single object by new data\n\t// for Matreshka.Array instance call recreate method\n\t// for Matreshka.Object instance call setData method\n\t// for other objects just extend them by properties of data parameter\n\tmodule.exports = updateObject;\n\tfunction updateObject(instance, data) {\n\t    if (instance.isMatreshkaArray) {\n\t        instance.recreate(data);\n\t    } else if (instance.isMatreshkaObject) {\n\t        // QUESTION: Is it OK to just extend but not replace instance data?\n\t        instance.setData(data);\n\t    } else {\n\t        for (var _target = data, _keys = Object.keys(_target), _i = 0, key, value, _l = _keys.length; (key = _keys[_i], value = _target[key]), _i < _l; _i++) {\n\t            instance[key] = value;\n\t        }\n\t    }\n\t\n\t    return instance;\n\t}\n\n/***/ },\n/* 107 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar processRendering = __webpack_require__(60);\n\t\n\t// rerenders not rendered items in an array\n\t// force rerender when forceRerender event option is truthy\n\tmodule.exports = rerender;\n\tfunction rerender() {\n\t    var eventOptions = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t    var _renderIfPossible = this.renderIfPossible;\n\t    var renderIfPossible = _renderIfPossible === undefined ? true : _renderIfPossible;\n\t\n\t    if (renderIfPossible) {\n\t        var _keys,\n\t            _l,\n\t            _i,\n\t            _source,\n\t            _key,\n\t            _result = {};\n\t\n\t        _result.method = 'rerender'\n\t        _result.added = []\n\t        _result.removed = []\n\t\n\t        for (_source = eventOptions, _keys = Object.keys(_source), _l = _keys.length, _i = 0; _i < _l; _i++) {\n\t            _key = _keys[_i];\n\t            _result[_key] = _source[_key];\n\t        }\n\t\n\t        processRendering({\n\t            self: this,\n\t            eventOptions: _result\n\t        });\n\t    }\n\t\n\t    return this;\n\t}\n\n/***/ },\n/* 108 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar initMK = __webpack_require__(18);\n\t\n\tvar matreshkaError = __webpack_require__(25);\n\t\n\tvar bindNode = __webpack_require__(82);\n\t\n\tvar triggerOne = __webpack_require__(20);\n\t\n\tvar getNodes = __webpack_require__(83);\n\t\n\t// restores Matreshka.Array from external nodes\n\tmodule.exports = restore;\n\tfunction restore(selector) {\n\t    var _this = this;\n\t\n\t    var eventOptions = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\n\t    var selfDef = initMK(this);\n\t    var Model = this.Model;\n\t    var silent = eventOptions.silent;\n\t\n\t    var newItems = [];\n\t    var nodes = void 0;\n\t\n\t    if (typeof selector === 'string') {\n\t        // get nodes by selector\n\t        nodes = getNodes(this, selector);\n\t    } else {\n\t        // get nodes from rendering container\n\t        var container = this.nodes.container || this.nodes.sandbox;\n\t\n\t        if (container) {\n\t            nodes = container.children;\n\t        } else {\n\t            // no container is bound, throw an error\n\t            throw matreshkaError('restore:no_nodes');\n\t        }\n\t    }\n\t\n\t    // recreate an array but don't render newly added items\n\t    for (var _target = nodes, index = 0, node, _l = _target.length; node = _target[index], index < _l; index++) {\n\t        var _itemDef$renderedInAr;\n\t\n\t        var item = Model ? new Model({}, _this, index) : {}; // create new item\n\t        var bindRenderedAsSandbox = item.bindRenderedAsSandbox;\n\t\n\t        var itemDef = initMK(item);\n\t\n\t        itemDef.renderedInArrays = (_itemDef$renderedInAr = {}, _itemDef$renderedInAr[selfDef.id] = node, _itemDef$renderedInAr);\n\t\n\t        if (bindRenderedAsSandbox !== false) {\n\t            bindNode(item, 'sandbox', node, null, eventOptions);\n\t        }\n\t\n\t        if (!silent) {\n\t            // trigger needed events\n\t            var itemEventOptions = {\n\t                node: node,\n\t                self: item,\n\t                parentArray: _this\n\t            };\n\t\n\t            var onRender = item.onRender;\n\t            var onItemRender = _this.onItemRender;\n\t\n\t\n\t            if (onRender) {\n\t                onRender.call(item, itemEventOptions);\n\t            }\n\t\n\t            if (onItemRender) {\n\t                onItemRender.call(_this, item, itemEventOptions);\n\t            }\n\t\n\t            triggerOne(item, 'render', itemEventOptions);\n\t\n\t            // call afterrender immediately because a node already exists in DOM tree\n\t            triggerOne(item, 'afterrender', itemEventOptions);\n\t        }\n\t\n\t        newItems.push(item);\n\t    }\n\t\n\t    var _keys,\n\t        _l2,\n\t        _i,\n\t        _source,\n\t        _key,\n\t        _result = {};\n\t\n\t    _result.dontRender = true\n\t\n\t    for (_source = eventOptions, _keys = Object.keys(_source), _l2 = _keys.length, _i = 0; _i < _l2; _i++) {\n\t        _key = _keys[_i];\n\t        _result[_key] = _source[_key];\n\t    }\n\t\n\t    return this.recreate(newItems, _result);\n\t}\n\n/***/ },\n/* 109 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t// converts Matreshka.Array instance to ordinary array\n\tmodule.exports = toJSON;\n\tfunction toJSON() {\n\t    var recursive = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];\n\t\n\t    var result = new Array(this.length);\n\t\n\t    for (var _target = this, index = 0, item, _l = _target.length; item = _target[index], index < _l; index++) {\n\t        // when recursive is true and when an item has toJSON method then call it recusively\n\t        if (recursive && item && typeof item.toJSON === 'function') {\n\t            result[index] = item.toJSON(true);\n\t        } else {\n\t            result[index] = item;\n\t        }\n\t    }\n\t\n\t    return result;\n\t}\n\n/***/ },\n/* 110 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar createPseudoNativeMethod = __webpack_require__(111);\n\t\n\tvar concat = __webpack_require__(119);\n\t\n\tvar keys = __webpack_require__(120);\n\t\n\tvar values = __webpack_require__(121);\n\t\n\tvar entries = __webpack_require__(122);\n\t\n\tvar splitBySpaceReg = /\\s+/;\n\tvar methods = { concat: concat, keys: keys, values: values, entries: entries };\n\t\n\t'push pop unshift shift sort reverse splice map filter slice every some reduce reduceRight\\nforEach join indexOf lastIndexOf copyWithin fill includes find findIndex'.split(splitBySpaceReg).forEach(function (name) {\n\t    methods[name] = createPseudoNativeMethod(name);\n\t});\n\t\n\t'push pop unshift shift sort reverse splice copyWithin fill'.split(splitBySpaceReg).forEach(function (name) {\n\t    methods[name + '_'] = createPseudoNativeMethod(name, true);\n\t});\n\t\n\tmodule.exports = methods;\n\n/***/ },\n/* 111 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar toMatreshkaArray = __webpack_require__(112);\n\t\n\tvar createSortingMethod = __webpack_require__(113);\n\t\n\tvar createRemovingMethod = __webpack_require__(114);\n\t\n\tvar createAddingMethod = __webpack_require__(115);\n\t\n\tvar createSplice = __webpack_require__(116);\n\t\n\tvar createCopyWithin = __webpack_require__(117);\n\t\n\tvar createFill = __webpack_require__(118);\n\t\n\tvar apply = __webpack_require__(21);\n\t\n\tvar matreshkaError = __webpack_require__(25);\n\t\n\tvar arrayPrototype = Array.prototype;\n\t\n\t// creates pseudo native method and returns it (push, push_, sort, sort_...)\n\tmodule.exports = createPseudoNativeMethod;\n\tfunction createPseudoNativeMethod(name) {\n\t    var hasOptions = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];\n\t\n\t    switch (name) {\n\t        case 'forEach':\n\t            return function pseudoNativeMethod(callback, thisArg) {\n\t                arrayPrototype[name].call(this, callback, thisArg);\n\t                // return this for nicer chain calls\n\t                return this;\n\t            };\n\t        case 'map':\n\t        case 'filter':\n\t        case 'slice':\n\t            // TODO: Improve readability of pseudoNativeMethod, arguments \"a, b\" look not good\n\t            return function pseudoNativeMethod(a, b) {\n\t                return toMatreshkaArray(arrayPrototype[name].call(this, a, b));\n\t            };\n\t        case 'every':\n\t        case 'some':\n\t        case 'findIndex':\n\t        case 'find':\n\t            return function pseudoNativeMethod(callback, thisArg) {\n\t                var originalMethod = arrayPrototype[name];\n\t\n\t                /* istanbul ignore if  */\n\t                if (typeof originalMethod !== 'function') {\n\t                    throw matreshkaError('array:nonexistent_method', { method: name });\n\t                }\n\t                return originalMethod.call(this, callback, thisArg);\n\t            };\n\t        case 'join':\n\t            return function pseudoNativeMethod() {\n\t                var separator = arguments.length <= 0 || arguments[0] === undefined ? ',' : arguments[0];\n\t\n\t                return arrayPrototype[name].call(this, separator);\n\t            };\n\t        case 'indexOf':\n\t        case 'lastIndexOf':\n\t        case 'includes':\n\t            return function pseudoNativeMethod(searchElement, fromIndex) {\n\t                var originalMethod = arrayPrototype[name];\n\t\n\t                /* istanbul ignore if  */\n\t                if (typeof originalMethod !== 'function') {\n\t                    throw matreshkaError('array:nonexistent_method', { method: name });\n\t                }\n\t\n\t                if (typeof fromIndex === 'undefined') {\n\t                    return originalMethod.call(this, searchElement);\n\t                }\n\t\n\t                return originalMethod.call(this, searchElement, fromIndex);\n\t            };\n\t        case 'reduce':\n\t        case 'reduceRight':\n\t            return function pseudoNativeMethod() {\n\t                return apply(arrayPrototype[name], this, arguments);\n\t            };\n\t        case 'sort':\n\t        case 'reverse':\n\t            return createSortingMethod(name, hasOptions);\n\t        case 'pop':\n\t        case 'shift':\n\t            return createRemovingMethod(name, hasOptions);\n\t        case 'push':\n\t        case 'unshift':\n\t            return createAddingMethod(name, hasOptions);\n\t        case 'splice':\n\t            return createSplice(hasOptions);\n\t        case 'copyWithin':\n\t            return createCopyWithin(hasOptions);\n\t        case 'fill':\n\t            return createFill(hasOptions);\n\t        default:\n\t            return undefined;\n\t    }\n\t}\n\n/***/ },\n/* 112 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t// converts array-like to Matreshka.Array instance\n\tmodule.exports = toMatreshkaArray;\n\tfunction toMatreshkaArray(arrayLike) {\n\t    // fix circular dependency issue\n\t    var MatreshkaArray = __webpack_require__(52);\n\t\n\t    var result = new MatreshkaArray(arrayLike.length);\n\t\n\t    for (var _target = arrayLike, index = 0, item, _l = _target.length; item = _target[index], index < _l; index++) {\n\t        result[index] = item;\n\t    }\n\t\n\t    return result;\n\t}\n\n/***/ },\n/* 113 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar initMK = __webpack_require__(18);\n\t\n\tvar reportModified = __webpack_require__(59);\n\t\n\t// creates sorting method and returns it (sort, reverse, sort_, reverse_)\n\tmodule.exports = createSortingMethod;\n\tfunction createSortingMethod(name, hasOptions) {\n\t    return function pseudoNativeMethod(sortCallback) {\n\t        if (this.length < 2) return this;\n\t        initMK(this);\n\t\n\t        var givenEventOptions = hasOptions ? arguments[arguments.length - 1] : null;\n\t        var method = Array.prototype[name];\n\t\n\t        var eventOptions = {\n\t            method: name,\n\t            self: this,\n\t            added: [],\n\t            removed: []\n\t        };\n\t\n\t        // call original method\n\t        if (name === 'sort' && typeof sortCallback === 'function') {\n\t            method.call(this, sortCallback);\n\t        } else {\n\t            method.call(this);\n\t        }\n\t\n\t        // extend event options by custom event options if they are given\n\t        if (hasOptions) {\n\t            if (givenEventOptions && typeof givenEventOptions === 'object') {\n\t                var _result = eventOptions;\n\t\n\t                for (var _source2 = givenEventOptions, _keys2 = Object.keys(_source2), _l2 = _keys2.length, _i2 = 0, _key2; _i2 < _l2; _i2++) {\n\t                    _key2 = _keys2[_i2];\n\t                    _result[_key2] = _source2[_key2];\n\t                }\n\t            }\n\t        }\n\t\n\t        reportModified(this, eventOptions);\n\t\n\t        return this;\n\t    };\n\t}\n\n/***/ },\n/* 114 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar initMK = __webpack_require__(18);\n\t\n\tvar reportModified = __webpack_require__(59);\n\t\n\t// creates removing method and returns it (pop, shift, pop_, shift_)\n\tmodule.exports = createRemovingMethod;\n\tfunction createRemovingMethod(name, hasOptions) {\n\t    return function pseudoNativeMethod(givenEventOptions) {\n\t        if (!this.length) {\n\t            return undefined;\n\t        }\n\t        initMK(this);\n\t\n\t        // call original method\n\t        var returns = Array.prototype[name].call(this);\n\t        var eventOptions = {\n\t            method: name,\n\t            self: this,\n\t            added: [],\n\t            removed: [returns]\n\t        };\n\t\n\t        // extend event options by custom event options if they are given\n\t        if (hasOptions) {\n\t            if (givenEventOptions && typeof givenEventOptions === 'object') {\n\t                var _result = eventOptions;\n\t\n\t                for (var _source2 = givenEventOptions, _keys2 = Object.keys(_source2), _l2 = _keys2.length, _i2 = 0, _key2; _i2 < _l2; _i2++) {\n\t                    _key2 = _keys2[_i2];\n\t                    _result[_key2] = _source2[_key2];\n\t                }\n\t            }\n\t        }\n\t\n\t        reportModified(this, eventOptions);\n\t\n\t        return returns;\n\t    };\n\t}\n\n/***/ },\n/* 115 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar initMK = __webpack_require__(18);\n\t\n\tvar reportModified = __webpack_require__(59);\n\t\n\t// creates methods: push, unshift, push_, unshift_\n\tmodule.exports = createAddingMethod;\n\tfunction createAddingMethod(name, hasOptions) {\n\t    return function pseudoNativeMethod() {\n\t        var _initMK = initMK(this);\n\t\n\t        var itemMediator = _initMK.itemMediator;\n\t        // +hasOptions is converted to 0 or 1 depending on its value (false/true)\n\t\n\t        var argsLength = arguments.length - +hasOptions;\n\t        var args = Array(argsLength);\n\t        var givenEventOptions = hasOptions ? arguments[arguments.length - 1] : null;\n\t        var useMediator = typeof itemMediator === 'function' && (!givenEventOptions || !givenEventOptions.skipItemMediator);\n\t        var isPush = name === 'push';\n\t        var length = this.length;\n\t\n\t        // if no arguments are passed\n\t\n\t        if (!argsLength) {\n\t            return length;\n\t        }\n\t\n\t        // convert arguments to array and call item mediator on every item if it's possible\n\t        for (var i = 0; i < argsLength; i++) {\n\t            var arg = arguments[i];\n\t            if (useMediator) {\n\t                var index = isPush ? i + length : i;\n\t                args[i] = itemMediator(arg, index);\n\t            } else {\n\t                args[i] = arg;\n\t            }\n\t        }\n\t\n\t        if (isPush) {\n\t            // insert new items to the end of array\n\t            for (var _i = 0; _i < argsLength; _i++) {\n\t                this[length + _i] = args[_i];\n\t            }\n\t        } else {\n\t            // move current items to new indexes\n\t            for (var _i2 = length - 1; _i2 >= 0; _i2--) {\n\t                this[argsLength + _i2] = this[_i2];\n\t            }\n\t            // insert new items to the begin of array\n\t            for (var _i3 = 0; _i3 < argsLength; _i3++) {\n\t                this[_i3] = args[_i3];\n\t            }\n\t        }\n\t\n\t        // update length\n\t        length += argsLength;\n\t        this.length = length;\n\t\n\t        var eventOptions = {\n\t            method: name,\n\t            self: this,\n\t            added: args,\n\t            removed: []\n\t        };\n\t\n\t        // extend event options by custom event options if they are given\n\t        if (hasOptions) {\n\t            if (givenEventOptions && typeof givenEventOptions === 'object') {\n\t                var _result = eventOptions;\n\t\n\t                for (var _source2 = givenEventOptions, _keys2 = Object.keys(_source2), _l2 = _keys2.length, _i5 = 0, _key2; _i5 < _l2; _i5++) {\n\t                    _key2 = _keys2[_i5];\n\t                    _result[_key2] = _source2[_key2];\n\t                }\n\t            }\n\t        }\n\t\n\t        reportModified(this, eventOptions);\n\t\n\t        return length;\n\t    };\n\t}\n\n/***/ },\n/* 116 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar initMK = __webpack_require__(18);\n\t\n\tvar reportModified = __webpack_require__(59);\n\t\n\tvar toMatreshkaArray = __webpack_require__(112);\n\t\n\tvar apply = __webpack_require__(21);\n\t\n\t// creates splice or splice_ method and returns it\n\t// TODO: Improve readability of createSplice function\n\tmodule.exports = createSplice;\n\tfunction createSplice(hasOptions) {\n\t    return function pseudoNativeMethod() {\n\t        var _initMK = initMK(this);\n\t\n\t        var itemMediator = _initMK.itemMediator;\n\t\n\t        var functionArguments = arguments;\n\t        var argsLength = functionArguments.length - +hasOptions;\n\t        var args = Array(argsLength);\n\t        var givenEventOptions = hasOptions ? functionArguments[functionArguments.length - 1] : null;\n\t        var useMediator = typeof itemMediator === 'function' && (!givenEventOptions || !givenEventOptions.skipItemMediator);\n\t        var added = [];\n\t        var start = args[0];\n\t        var length = this.length;\n\t\n\t\n\t        start = start < 0 ? length + start : start;\n\t\n\t        // convert arguments to array and call item mediator on every new item if it's possible\n\t        args[0] = functionArguments[0];\n\t        args[1] = functionArguments[1];\n\t        for (var i = 2; i < argsLength; i++) {\n\t            var arg = functionArguments[i];\n\t            if (useMediator) {\n\t                args[i] = itemMediator(arg, start + (i - 2));\n\t            } else {\n\t                args[i] = arg;\n\t            }\n\t\n\t            added[i - 2] = args[i];\n\t        }\n\t\n\t        // call original method\n\t        // TODO: Change array manually in splice method for better performance\n\t        var returns = apply(Array.prototype.splice, this, args);\n\t        // removed items mean returned items\n\t        var removed = returns;\n\t\n\t        // if something is added or removed\n\t        if (added.length || removed.length) {\n\t            var eventOptions = {\n\t                added: added,\n\t                removed: removed,\n\t                method: 'splice',\n\t                self: this\n\t            };\n\t\n\t            // extend event options by custom event options if they are given\n\t            if (hasOptions) {\n\t                if (givenEventOptions && typeof givenEventOptions === 'object') {\n\t                    var _result = eventOptions;\n\t\n\t                    for (var _source2 = givenEventOptions, _keys2 = Object.keys(_source2), _l2 = _keys2.length, _i2 = 0, _key2; _i2 < _l2; _i2++) {\n\t                        _key2 = _keys2[_i2];\n\t                        _result[_key2] = _source2[_key2];\n\t                    }\n\t                }\n\t            }\n\t\n\t            reportModified(this, eventOptions);\n\t        }\n\t\n\t        return toMatreshkaArray(returns);\n\t    };\n\t}\n\n/***/ },\n/* 117 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar apply = __webpack_require__(21);\n\t\n\tvar reportModified = __webpack_require__(59);\n\t\n\tvar matreshkaError = __webpack_require__(25);\n\t\n\tmodule.exports = createCopyWithin;\n\tfunction createCopyWithin(hasOptions) {\n\t    return function copyWithin() {\n\t        var originalCopyWithin = Array.prototype.copyWithin;\n\t\n\t        /* istanbul ignore if  */\n\t        if (typeof originalCopyWithin !== 'function') {\n\t            throw matreshkaError('array:nonexistent_method', { method: 'copyWithin' });\n\t        }\n\t        // +hasOptions is converted to 0 or 1 depending on its value (false/true)\n\t        var argsLength = arguments.length - +hasOptions;\n\t        var args = Array(argsLength);\n\t        var givenEventOptions = hasOptions ? arguments[arguments.length - 1] : null;\n\t\n\t        for (var i = 0; i < argsLength; i++) {\n\t            args[i] = arguments[i];\n\t        }\n\t\n\t        apply(originalCopyWithin, this, args);\n\t\n\t        var eventOptions = {\n\t            method: 'copyWithin',\n\t            self: this,\n\t            added: [],\n\t            removed: []\n\t        };\n\t\n\t        // extend event options by custom event options if they are given\n\t        if (hasOptions) {\n\t            if (givenEventOptions && typeof givenEventOptions === 'object') {\n\t                var _result = eventOptions;\n\t\n\t                for (var _source2 = givenEventOptions, _keys2 = Object.keys(_source2), _l2 = _keys2.length, _i2 = 0, _key2; _i2 < _l2; _i2++) {\n\t                    _key2 = _keys2[_i2];\n\t                    _result[_key2] = _source2[_key2];\n\t                }\n\t            }\n\t        }\n\t\n\t        reportModified(this, eventOptions);\n\t\n\t        return this;\n\t    };\n\t}\n\n/***/ },\n/* 118 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar apply = __webpack_require__(21);\n\t\n\tvar reportModified = __webpack_require__(59);\n\t\n\tvar matreshkaError = __webpack_require__(25);\n\t\n\tmodule.exports = createFill;\n\tfunction createFill(hasOptions) {\n\t    return function fill(value) {\n\t        var originalFill = Array.prototype.fill;\n\t\n\t        /* istanbul ignore if  */\n\t        if (typeof originalFill !== 'function') {\n\t            throw matreshkaError('array:nonexistent_method', { method: 'fill' });\n\t        }\n\t        // +hasOptions is converted to 0 or 1 depending on its value (false/true)\n\t        var argsLength = arguments.length - +hasOptions;\n\t        var args = Array(argsLength);\n\t        var givenEventOptions = hasOptions ? arguments[arguments.length - 1] : null;\n\t\n\t        for (var i = 0; i < argsLength; i++) {\n\t            args[i] = arguments[i];\n\t        }\n\t\n\t        apply(originalFill, this, args);\n\t\n\t        var eventOptions = {\n\t            method: 'fill',\n\t            self: this,\n\t            added: [value],\n\t            removed: []\n\t        };\n\t\n\t        // extend event options by custom event options if they are given\n\t        if (hasOptions) {\n\t            if (givenEventOptions && typeof givenEventOptions === 'object') {\n\t                var _result = eventOptions;\n\t\n\t                for (var _source2 = givenEventOptions, _keys2 = Object.keys(_source2), _l2 = _keys2.length, _i2 = 0, _key2; _i2 < _l2; _i2++) {\n\t                    _key2 = _keys2[_i2];\n\t                    _result[_key2] = _source2[_key2];\n\t                }\n\t            }\n\t        }\n\t\n\t        reportModified(this, eventOptions);\n\t\n\t        return this;\n\t    };\n\t}\n\n/***/ },\n/* 119 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar apply = __webpack_require__(21);\n\t\n\t// the method works just like Array.prototype.concat but\n\t// - flattens both Array and Matreshka.Array\n\t// - returns Matreshka.Array\n\tmodule.exports = concat;\n\tfunction concat() {\n\t    // fix circular dependency issue\n\t    var MatreshkaArray = __webpack_require__(52);\n\t\n\t    var args = Array(arguments.length);\n\t\n\t    // convert all instances of Matreshka.Array to Array\n\t\n\t    // call original concat method\n\t    for (var _target = arguments, index = 0, arg, _l = _target.length; arg = _target[index], index < _l; index++) {\n\t        if (arg && typeof arg === 'object' && arg.isMatreshkaArray) {\n\t            args[index] = arg.toJSON(false);\n\t        } else {\n\t            args[index] = arg;\n\t        }\n\t    }\n\t\n\t    var nativeCallResult = apply(Array.prototype.concat, this.toJSON(false), args);\n\t\n\t    // convert returned value to Matreshka.Array\n\t    var result = new MatreshkaArray();\n\t\n\t    for (var _target2 = nativeCallResult, index = 0, item, _l2 = _target2.length; item = _target2[index], index < _l2; index++) {\n\t        result[index] = item;\n\t    }\n\t\n\t    result.length = nativeCallResult.length;\n\t\n\t    return result;\n\t}\n\n/***/ },\n/* 120 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\t// returns indexes\n\tmodule.exports = keys;\n\tfunction keys() {\n\t    var length = this.length;\n\t\n\t    var result = new Array(length);\n\t\n\t    for (var i = 0; i < length; i++) {\n\t        result[i] = i;\n\t    }\n\t\n\t    return result;\n\t}\n\n/***/ },\n/* 121 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\t// returns values\n\tmodule.exports = values;\n\tfunction values() {\n\t    var length = this.length;\n\t\n\t    var result = new Array(length);\n\t\n\t    for (var i = 0; i < length; i++) {\n\t        result[i] = this[i];\n\t    }\n\t\n\t    return result;\n\t}\n\n/***/ },\n/* 122 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\t// returns pairs like [index, value]\n\tmodule.exports = values;\n\tfunction values() {\n\t    var length = this.length;\n\t\n\t    var result = new Array(length);\n\t\n\t    for (var i = 0; i < length; i++) {\n\t        result[i] = [i, this[i]];\n\t    }\n\t\n\t    return result;\n\t}\n\n/***/ },\n/* 123 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\t// Symbol.iterator of Matreshka.Array instances\n\tmodule.exports = matreshkaArrayIterator;\n\tfunction matreshkaArrayIterator() {\n\t    var _this = this;\n\t\n\t    var i = 0;\n\t\n\t    return {\n\t        next: function () {\n\t            if (i > _this.length - 1) {\n\t                return {\n\t                    done: true\n\t                };\n\t            }\n\t\n\t            return {\n\t                done: false,\n\t                value: _this[i++] // eslint-disable-line no-plusplus\n\t            };\n\t        }\n\t    };\n\t}\n\n/***/ },\n/* 124 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar from = __webpack_require__(125);\n\t\n\tvar of = __webpack_require__(126);\n\t\n\tmodule.exports = {\n\t    of: of,\n\t    from: from\n\t}; // lol\n\n/***/ },\n/* 125 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar cheapRecreate = __webpack_require__(57);\n\t\n\t// creates a new Matreshka.Array instance from an array-like or iterable object\n\tmodule.exports = from;\n\tfunction from(arrayLike, mapFn, thisArg) {\n\t    // allow to inherit this method by child classes\n\t    // require('./') fixes circular ref issue\n\t    var ParentClass = this || __webpack_require__(52);\n\t\n\t    var result = new ParentClass();\n\t    var length = arrayLike.length;\n\t    var arrayFrom = Array.from;\n\t    var newItems = void 0;\n\t\n\t    /* istanbul ignore else */\n\t    if (typeof arrayFrom === 'function') {\n\t        // if Array.from exist, let it do all the job (work with iterable objects etc)\n\t        newItems = arrayFrom(arrayLike, mapFn, thisArg);\n\t    } else {\n\t        // convert array-like object for older browsers\n\t        // @IE\n\t        newItems = Array(length);\n\t\n\t        for (var i = 0; i < length; i++) {\n\t            if (typeof mapFn === 'function') {\n\t                newItems[i] = mapFn.call(thisArg, arrayLike[i], i, arrayLike);\n\t            } else {\n\t                newItems[i] = arrayLike[i];\n\t            }\n\t        }\n\t    }\n\t\n\t    return cheapRecreate(result, newItems);\n\t}\n\n/***/ },\n/* 126 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar cheapRecreate = __webpack_require__(57);\n\t\n\t// creates a new Matreshka.Array instance with a variable number of arguments,\n\t// regardless of number or type of the arguments\n\tmodule.exports = of;\n\tfunction of() {\n\t    var _arguments = arguments;\n\t\n\t    // allow to inherit this method by child classes\n\t    // require('./') fixes circular ref issue\n\t    var ParentClass = this || __webpack_require__(52);\n\t\n\t    var result = new ParentClass();\n\t    var newItems = Array(arguments.length);\n\t\n\t    for (var _target = arguments, index = 0, item, _l = _target.length; item = _target[index], index < _l; index++) {\n\t        newItems[index] = _arguments[index];\n\t    }\n\t\n\t    return cheapRecreate(result, newItems);\n\t}\n\n/***/ },\n/* 127 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar html = __webpack_require__(128);\n\t\n\tvar display = __webpack_require__(129);\n\t\n\tvar className = __webpack_require__(130);\n\t\n\tvar prop = __webpack_require__(132);\n\t\n\tvar attr = __webpack_require__(133);\n\t\n\tvar input = __webpack_require__(5);\n\t\n\tvar output = __webpack_require__(9);\n\t\n\tvar textarea = __webpack_require__(6);\n\t\n\tvar select = __webpack_require__(7);\n\t\n\tvar progress = __webpack_require__(8);\n\t\n\tvar text = __webpack_require__(134);\n\t\n\tvar style = __webpack_require__(135);\n\t\n\tvar dataset = __webpack_require__(136);\n\t\n\texports.html = html;\n\texports.display = display;\n\texports.className = className;\n\texports.prop = prop;\n\texports.attr = attr;\n\texports.input = input;\n\texports.output = output;\n\texports.textarea = textarea;\n\texports.select = select;\n\texports.progress = progress;\n\texports.text = text;\n\texports.style = style;\n\texports.dataset = dataset;\n\n/***/ },\n/* 128 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t// returns a binder for innerHTML of an element\n\tmodule.exports = html;\n\tfunction html() {\n\t    return {\n\t        on: 'input', // the event name fires only in contenteditable mode\n\t        getValue: function () {\n\t            return this.innerHTML;\n\t        },\n\t        setValue: function (value) {\n\t            this.innerHTML = '' + value;\n\t        }\n\t    };\n\t}\n\n/***/ },\n/* 129 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t//  returns a binder to switch visibility of an element\n\tmodule.exports = display;\n\tfunction display() {\n\t    var switcher = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];\n\t\n\t    return {\n\t        on: null,\n\t        getValue: function () {\n\t            var value = this.style.display || window.getComputedStyle(this).getPropertyValue('display');\n\t            var none = value === 'none';\n\t            return switcher ? !none : none;\n\t        },\n\t        setValue: function (value) {\n\t            var style = this.style;\n\t\n\t            if (switcher) {\n\t                style.display = value ? '' : 'none';\n\t            } else {\n\t                style.display = value ? 'none' : '';\n\t            }\n\t        }\n\t    };\n\t}\n\n/***/ },\n/* 130 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _classlistJs = __webpack_require__(131);\n\t\n\tvar toggle = _classlistJs.toggle;\n\tvar contains = _classlistJs.contains;\n\t\n\t\n\t// returns a binder for className of an element\n\t// switcher makes possible to turn property value\n\tmodule.exports = className;\n\tfunction className(elementClassName) {\n\t    var switcher = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];\n\t\n\t    return {\n\t        on: null,\n\t        getValue: function () {\n\t            var value = contains(this, elementClassName);\n\t            return switcher ? value : !value;\n\t        },\n\t        setValue: function (value) {\n\t            toggle(this, elementClassName, switcher ? !!value : !value);\n\t        }\n\t    };\n\t}\n\n/***/ },\n/* 131 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t// @IE9\n\t\n\tvar add = void 0;\n\tvar remove = void 0;\n\tvar contains = void 0; // eslint-disable-line import/no-mutable-exports\n\t\n\t/* istanbul ignore else */\n\tif (window.document.createElement('div').classList) {\n\t    add = function (node, name) {\n\t        return node.classList.add(name);\n\t    };\n\t    remove = function (node, name) {\n\t        return node.classList.remove(name);\n\t    };\n\t    contains = function (node, name) {\n\t        return node.classList.contains(name);\n\t    };\n\t} else {\n\t    add = function (node, name) {\n\t        var re = new RegExp('(^|\\\\s)' + name + '(\\\\s|$)', 'g');\n\t        if (!re.test(node.className)) {\n\t            node.className = (node.className + ' ' + name).replace(/\\s+/g, ' ').replace(/(^ | $)/g, '');\n\t        }\n\t    };\n\t\n\t    remove = function (node, name) {\n\t        var re = new RegExp('(^|\\\\s)' + name + '(\\\\s|$)', 'g');\n\t        node.className = node.className.replace(re, '$1').replace(/\\s+/g, ' ').replace(/(^ | $)/g, '');\n\t    };\n\t\n\t    contains = function (node, name) {\n\t        return new RegExp('(\\\\s|^)' + name + '(\\\\s|$)').test(node.className);\n\t    };\n\t}\n\t\n\tvar toggle = function (node, name, switcher) {\n\t    if (switcher) {\n\t        add(node, name);\n\t    } else {\n\t        remove(node, name);\n\t    }\n\t};\n\t\n\texports.toggle = toggle;\n\texports.contains = contains;\n\n/***/ },\n/* 132 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\t// returns a binder to change properties of an element\n\tmodule.exports = prop;\n\tfunction prop(propertyName) {\n\t    return {\n\t        on: null,\n\t        getValue: function () {\n\t            return this[propertyName];\n\t        },\n\t        setValue: function (value) {\n\t            // in case when you're trying to set read-only property\n\t            try {\n\t                this[propertyName] = value;\n\t            } catch (e) {\n\t                // cannot set given property (eg tagName)\n\t            }\n\t        }\n\t    };\n\t}\n\n/***/ },\n/* 133 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\t// returns a binder for element attribute\n\tmodule.exports = attr;\n\tfunction attr(attributeName) {\n\t    return {\n\t        on: null,\n\t        getValue: function () {\n\t            return this.getAttribute(attributeName);\n\t        },\n\t        setValue: function (value) {\n\t            this.setAttribute(attributeName, value);\n\t        }\n\t    };\n\t}\n\n/***/ },\n/* 134 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t// returns a binder for textContent of an element\n\tmodule.exports = text;\n\tfunction text() {\n\t    return {\n\t        on: 'input', // the event name fires only in contenteditable mode\n\t        getValue: function () {\n\t            return this.textContent;\n\t        },\n\t        setValue: function (value) {\n\t            this.textContent = '' + value;\n\t        }\n\t    };\n\t}\n\n/***/ },\n/* 135 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\t// returns a binder for style properties\n\tmodule.exports = style;\n\tfunction style(property) {\n\t    return {\n\t        on: null,\n\t        getValue: function () {\n\t            return this.style[property] || window.getComputedStyle(this).getPropertyValue(property);\n\t        },\n\t        setValue: function (value) {\n\t            this.style[property] = value;\n\t        }\n\t    };\n\t}\n\n/***/ },\n/* 136 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\t// replace namesLikeThis with names-like-this\n\tvar replacer = function (u) {\n\t    return \"-\" + u.toLowerCase();\n\t};\n\tvar toDashed = function (name) {\n\t    return \"data-\" + name.replace(/([A-Z])/g, replacer);\n\t};\n\t\n\t//  returns a binder for dataset of an element\n\t// old browsers are also supported @IE9 @IE10\n\tmodule.exports = dataset;\n\tfunction dataset(prop) {\n\t    return {\n\t        on: null,\n\t        getValue: function () {\n\t            if (this.dataset) {\n\t                return this.dataset[prop];\n\t            }\n\t\n\t            return this.getAttribute(toDashed(prop));\n\t        },\n\t        setValue: function (value) {\n\t            if (this.dataset) {\n\t                this.dataset[prop] = value;\n\t            } else {\n\t                this.setAttribute(toDashed(prop), value);\n\t            }\n\t        }\n\t    };\n\t}\n\n/***/ },\n/* 137 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar on = __webpack_require__(138);\n\t\n\tvar once = __webpack_require__(140);\n\t\n\tvar onDebounce = __webpack_require__(142);\n\t\n\tvar off = __webpack_require__(141);\n\t\n\tvar trigger = __webpack_require__(143);\n\t\n\tvar calc = __webpack_require__(65);\n\t\n\tvar bindNode = __webpack_require__(82);\n\t\n\tvar unbindNode = __webpack_require__(87);\n\t\n\tvar bindOptionalNode = __webpack_require__(146);\n\t\n\tvar bindSandbox = __webpack_require__(147);\n\t\n\tvar parseBindings = __webpack_require__(63);\n\t\n\tvar select = __webpack_require__(148);\n\t\n\tvar selectAll = __webpack_require__(149);\n\t\n\tvar set = __webpack_require__(23);\n\t\n\tvar remove = __webpack_require__(150);\n\t\n\tvar instantiate = __webpack_require__(151);\n\t\n\tvar mediate = __webpack_require__(152);\n\t\n\t// the following methods can be used as static methods and as instance methods\n\texports.on = on;\n\texports.once = once;\n\texports.onDebounce = onDebounce;\n\texports.off = off;\n\texports.trigger = trigger;\n\texports.calc = calc;\n\texports.bindNode = bindNode;\n\texports.unbindNode = unbindNode;\n\texports.bindOptionalNode = bindOptionalNode;\n\texports.bindSandbox = bindSandbox;\n\texports.parseBindings = parseBindings;\n\texports.select = select;\n\texports.selectAll = selectAll;\n\texports.set = set;\n\texports.remove = remove;\n\texports.instantiate = instantiate;\n\texports.mediate = mediate;\n\n/***/ },\n/* 138 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar splitBySpaceReg = __webpack_require__(139);\n\t\n\tvar checkObjectType = __webpack_require__(24);\n\t\n\tvar matreshkaError = __webpack_require__(25);\n\t\n\tvar addListener = __webpack_require__(17);\n\t\n\tvar delegateListener = __webpack_require__(69);\n\t\n\t// adds event listener\n\tmodule.exports = on;\n\tfunction on(object, givenNames, callback, triggerOnInit, context) {\n\t    if (typeof this === 'object' && this.isMatreshka) {\n\t        // when context is Matreshka instance, use this as an object and shift other args\n\t        /* eslint-disable no-param-reassign */\n\t        context = triggerOnInit;\n\t        triggerOnInit = callback;\n\t        callback = givenNames;\n\t        givenNames = object;\n\t        object = this;\n\t        /* eslint-enable no-param-reassign */\n\t    } else {\n\t        // throw error when object type is wrong\n\t        checkObjectType(object, 'on');\n\t    }\n\t\n\t    var isNamesVarArray = givenNames instanceof Array;\n\t\n\t    // allow to pass name-handler object\n\t    if (givenNames && typeof givenNames === 'object' && !isNamesVarArray) {\n\t        for (var _target = givenNames, _keys = Object.keys(_target), _i = 0, namesObjName, namesObjCallback, _l = _keys.length; (namesObjName = _keys[_i], namesObjCallback = _target[namesObjName]), _i < _l; _i++) {\n\t            on(object, namesObjName, namesObjCallback, callback, triggerOnInit)\n\t        }\n\t\n\t        return object;\n\t    }\n\t\n\t    if (typeof givenNames !== 'string' && !isNamesVarArray) {\n\t        throw matreshkaError('on:names_type', { names: givenNames });\n\t    }\n\t\n\t    // split by spaces\n\t    // TODO: Array of names passed to on method is non-documented feature\n\t    var names = isNamesVarArray ? givenNames : givenNames.split(splitBySpaceReg);\n\t\n\t    // flip triggerOnInit and context when triggerOnInit is not boolean\n\t    if (typeof triggerOnInit !== 'boolean' && typeof triggerOnInit !== 'undefined') {\n\t        var _ref = [triggerOnInit, context];\n\t        // eslint-disable-next-line no-param-reassign\n\t\n\t        context = _ref[0];\n\t        triggerOnInit = _ref[1];\n\t    }\n\t\n\t    // call callback immediatelly if triggerOnInit is true\n\t    for (var _target2 = names, _index = 0, name, _l2 = _target2.length; name = _target2[_index], _index < _l2; _index++) {\n\t        var delegatedEventParts = name.split('@');\n\t\n\t        if (delegatedEventParts.length > 1) {\n\t            // if @ exists in event name then this is delegated event\n\t            var path = delegatedEventParts[0];\n\t            var delegatedName = delegatedEventParts[1];\n\t\n\t            delegateListener(object, path, delegatedName, callback, context || object);\n\t        } else {\n\t            // if not, this is simple event\n\t            addListener(object, name, callback, context);\n\t        }\n\t    }\n\t\n\t    if (triggerOnInit === true) {\n\t        callback.call(context || object, { triggerOnInit: triggerOnInit });\n\t    }\n\t\n\t    return object;\n\t}\n\n/***/ },\n/* 139 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\t// allows to split by spaces not inclusing ones inside of brackers\n\tmodule.exports = /\\s+(?![^(]*\\))/g;\n\n/***/ },\n/* 140 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar on = __webpack_require__(138);\n\t\n\tvar checkObjectType = __webpack_require__(24);\n\t\n\tvar off = __webpack_require__(141);\n\t\n\tvar apply = __webpack_require__(21);\n\t\n\t// adds event listener which will be removed immediately after its first call\n\tmodule.exports = once;\n\tfunction once(object, names, givenCallback, context) {\n\t    if (typeof this === 'object' && this.isMatreshka) {\n\t        // when context is Matreshka instance, use this as an object and shift other args\n\t        /* eslint-disable no-param-reassign */\n\t        context = givenCallback;\n\t        givenCallback = names;\n\t        names = object;\n\t        object = this;\n\t        /* eslint-enable no-param-reassign */\n\t    } else {\n\t        // throw error when object type is wrong\n\t        checkObjectType(object, 'once');\n\t    }\n\t\n\t    var isNamesVarArray = names instanceof Array;\n\t\n\t    // allow to pass name-handler object\n\t    if (names && typeof names === 'object' && !isNamesVarArray) {\n\t        for (var _target = names, _keys = Object.keys(_target), _i = 0, namesObjName, namesObjCallback, _l = _keys.length; (namesObjName = _keys[_i], namesObjCallback = _target[namesObjName]), _i < _l; _i++) {\n\t            once(object, namesObjName, namesObjCallback, givenCallback)\n\t        }\n\t\n\t        return object;\n\t    }\n\t\n\t    var callback = function onceCallback() {\n\t        apply(givenCallback, this, arguments);\n\t        // remove event listener after its call\n\t        off(object, names, onceCallback, context);\n\t    };\n\t\n\t    // allow to remove event listener py passing original callback to \"off\"\n\t    callback._callback = givenCallback;\n\t\n\t    return on(object, names, callback, context);\n\t}\n\n/***/ },\n/* 141 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar splitBySpaceReg = __webpack_require__(139);\n\t\n\tvar checkObjectType = __webpack_require__(24);\n\t\n\tvar defs = __webpack_require__(19);\n\t\n\tvar removeListener = __webpack_require__(74);\n\t\n\tvar undelegateListener = __webpack_require__(73);\n\t\n\t// removes event listener\n\tmodule.exports = off;\n\tfunction off(object, givenNames, callback, context) {\n\t    if (typeof this === 'object' && this.isMatreshka) {\n\t        // when context is Matreshka instance, use this as an object and shift other args\n\t        /* eslint-disable no-param-reassign */\n\t        context = callback;\n\t        callback = givenNames;\n\t        givenNames = object;\n\t        object = this;\n\t        /* eslint-enable no-param-reassign */\n\t    } else {\n\t        // throw error when object type is wrong\n\t        checkObjectType(object, 'off');\n\t    }\n\t\n\t    var isNamesVarArray = givenNames instanceof Array;\n\t    var def = defs.get(object);\n\t\n\t    // allow to pass name-handler object\n\t    // TODO: Name-handler object passed to off method is non-documented feature\n\t    if (givenNames && typeof givenNames === 'object' && !isNamesVarArray) {\n\t        for (var _target = givenNames, _keys = Object.keys(_target), _i = 0, namesObjName, namesObjCallback, _l = _keys.length; (namesObjName = _keys[_i], namesObjCallback = _target[namesObjName]), _i < _l; _i++) {\n\t            off(object, namesObjName, namesObjCallback, callback)\n\t        }\n\t\n\t        return object;\n\t    }\n\t\n\t    if (!givenNames && !callback && !context) {\n\t        def.events = {};\n\t        return object;\n\t    }\n\t\n\t    // TODO: Array of names passed to off method is non-documented feature\n\t    // split by spaces\n\t    var names = isNamesVarArray ? givenNames : givenNames.split(splitBySpaceReg);\n\t\n\t    for (var _target2 = names, _index = 0, name, _l2 = _target2.length; name = _target2[_index], _index < _l2; _index++) {\n\t        var delegatedEventParts = name.split('@');\n\t        if (delegatedEventParts.length > 1) {\n\t            var path = delegatedEventParts[0];\n\t            var delegatedName = delegatedEventParts[1];\n\t\n\t            undelegateListener(object, path, delegatedName, callback, context);\n\t        } else {\n\t            removeListener(object, name, callback, context);\n\t        }\n\t    }\n\t\n\t    return object;\n\t}\n\n/***/ },\n/* 142 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar on = __webpack_require__(138);\n\t\n\tvar checkObjectType = __webpack_require__(24);\n\t\n\tvar debounce = __webpack_require__(66);\n\t\n\t// adds debounced event listener\n\tmodule.exports = onDebounce;\n\tfunction onDebounce(object, names, givenCallback, givenDelay, triggerOnInit, context) {\n\t    if (typeof this === 'object' && this.isMatreshka) {\n\t        // when context is Matreshka instance, use this as an object and shift other args\n\t        /* eslint-disable no-param-reassign */\n\t        context = triggerOnInit;\n\t        triggerOnInit = givenDelay;\n\t        givenDelay = givenCallback;\n\t        givenCallback = names;\n\t        names = object;\n\t        object = this;\n\t        /* eslint-enable no-param-reassign */\n\t    } else {\n\t        // throw error when object type is wrong\n\t        checkObjectType(object, 'onDebounce');\n\t    }\n\t\n\t    var isNamesVarArray = names instanceof Array;\n\t\n\t    // allow to pass name-handler object\n\t    if (names && typeof names === 'object' && !isNamesVarArray) {\n\t        for (var _target = names, _keys = Object.keys(_target), _i = 0, namesObjName, namesObjCallback, _l = _keys.length; (namesObjName = _keys[_i], namesObjCallback = _target[namesObjName]), _i < _l; _i++) {\n\t            onDebounce(object, namesObjName, namesObjCallback, givenCallback, givenDelay, triggerOnInit)\n\t        }\n\t\n\t        return object;\n\t    }\n\t\n\t    var delay = typeof givenDelay === 'number' ? givenDelay : 0;\n\t\n\t    var callback = debounce(givenCallback, delay);\n\t\n\t    // allow to remove event listener py passing original callback to \"off\"\n\t    callback._callback = givenCallback;\n\t\n\t    return on(object, names, callback, triggerOnInit, context);\n\t}\n\n/***/ },\n/* 143 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar domEventReg = __webpack_require__(27);\n\t\n\tvar checkObjectType = __webpack_require__(24);\n\t\n\tvar matreshkaError = __webpack_require__(25);\n\t\n\tvar splitBySpaceReg = __webpack_require__(139);\n\t\n\tvar defs = __webpack_require__(19);\n\t\n\tvar triggerOne = __webpack_require__(20);\n\t\n\tvar triggerDomEvent = __webpack_require__(144);\n\t\n\t// triggers an event\n\tmodule.exports = trigger;\n\tfunction trigger() {\n\t    var object = void 0;\n\t    var givenNames = void 0;\n\t    var triggerArgs = void 0;\n\t\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t        args[_key] = arguments[_key];\n\t    }\n\t\n\t    if (typeof this === 'object' && this.isMatreshka) {\n\t        givenNames = args[0];\n\t        // when context is Matreshka instance, use this as an object and shift other args\n\t\n\t        triggerArgs = args.slice(1);\n\t\n\t        object = this;\n\t    } else {\n\t        // throw error when object type is wrong\n\t        object = args[0];\n\t        givenNames = args[1];\n\t        triggerArgs = args.slice(2);\n\t        checkObjectType(object, 'trigger');\n\t    }\n\t    var names = void 0;\n\t\n\t    // allow to use strings only as event name\n\t    if (typeof givenNames === 'string') {\n\t        names = givenNames.split(splitBySpaceReg);\n\t    } else {\n\t        throw matreshkaError('trigger:names_type', { names: givenNames });\n\t    }\n\t\n\t    var def = defs.get(object);\n\t\n\t    // if no definition do nothing\n\t    if (!def) {\n\t        return object;\n\t    }\n\t\n\t    var allEvents = def.events;\n\t\n\t\n\t    if (!allEvents) {\n\t        return object;\n\t    }\n\t\n\t    for (var _target = names, _index = 0, name, _l = _target.length; name = _target[_index], _index < _l; _index++) {\n\t        var domEvtExecResult = domEventReg.exec(name);\n\t\n\t        if (domEvtExecResult) {\n\t            // if EVT::KEY(SELECTOR) ia passed as event name then trigger DOM event\n\t            var eventName = domEvtExecResult[1];\n\t            var _domEvtExecResult$ = domEvtExecResult[2];\n\t            var key = _domEvtExecResult$ === undefined ? 'sandbox' : _domEvtExecResult$;\n\t            var selector = domEvtExecResult[3];\n\t\n\t            triggerDomEvent(object, key, eventName, selector, triggerArgs);\n\t        } else {\n\t            // trigger ordinary event\n\t            triggerOne(object, name, triggerArgs);\n\t        }\n\t    }\n\t\n\t    return object;\n\t}\n\n/***/ },\n/* 144 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar triggerOneDOMEvent = __webpack_require__(145);\n\t\n\tvar defs = __webpack_require__(19);\n\t\n\t// triggers DOM event on bound nodes\n\tmodule.exports = triggerDOMEvent;\n\tfunction triggerDOMEvent(object, key, eventName, selector, triggerArgs) {\n\t    var def = defs.get(object);\n\t\n\t    if (!def) {\n\t        return;\n\t    }\n\t\n\t    var props = def.props;\n\t\n\t    var propDef = props[key];\n\t\n\t    if (!propDef) {\n\t        return;\n\t    }\n\t\n\t    var bindings = propDef.bindings;\n\t\n\t\n\t    if (!bindings) {\n\t        return;\n\t    }\n\t\n\t    for (var _target2 = bindings, _index2 = 0, _ref, _l2 = _target2.length; _ref = _target2[_index2], _index2 < _l2; _index2++) {\n\t        var node = _ref.node;\n\t\n\t        if (selector) {\n\t            // if selector is given trigger an event on all node descendants\n\t            var descendants = node.querySelectorAll(selector);\n\t\n\t            for (var _target = descendants, _index = 0, descendant, _l = _target.length; descendant = _target[_index], _index < _l; _index++) {\n\t                triggerOneDOMEvent({\n\t                    node: descendant,\n\t                    eventName: eventName,\n\t                    triggerArgs: triggerArgs\n\t                });\n\t            }\n\t        } else {\n\t            // trigger an event for single node\n\t            triggerOneDOMEvent({\n\t                node: node,\n\t                eventName: eventName,\n\t                triggerArgs: triggerArgs\n\t            });\n\t        }\n\t    }\n\t\n\t    return;\n\t}\n\n/***/ },\n/* 145 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t// triggers given DOM event on given node\n\tmodule.exports = triggerOneDOMEvent;\n\tfunction triggerOneDOMEvent(_ref) {\n\t    var node = _ref.node;\n\t    var eventName = _ref.eventName;\n\t    var triggerArgs = _ref.triggerArgs;\n\t    var _window = window;\n\t    var document = _window.document;\n\t    var Event = _window.Event;\n\t\n\t    var event = void 0;\n\t\n\t    // polyfill for older browsers\n\t    if (document.createEvent) {\n\t        /* istanbul ignore next */\n\t        event = document.createEvent('Event');\n\t        event.initEvent(eventName, true, true);\n\t    } else if (typeof Event !== 'undefined') {\n\t        event = new Event(eventName, {\n\t            bubbles: true,\n\t            cancelable: true\n\t        });\n\t    }\n\t\n\t    // matreshkaTriggerArgs will be used in a handler created by addDOMListener\n\t    event.matreshkaTriggerArgs = triggerArgs;\n\t\n\t    node.dispatchEvent(event);\n\t}\n\n/***/ },\n/* 146 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar bindNode = __webpack_require__(82);\n\t\n\tvar apply = __webpack_require__(21);\n\t\n\t// TODO: Adds a binding, not throwing an error when a node is missing\n\tmodule.exports = bindOptionalNode;\n\tfunction bindOptionalNode() {\n\t    // this hack allows to keep bindOptionalNode as compact as possible\n\t    // and doesn't require to flip args and support all bindNode variations\n\t    bindNode.temporaryOptionalFlag = true;\n\t    return apply(bindNode, this, arguments);\n\t}\n\n/***/ },\n/* 147 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar bindNode = __webpack_require__(82);\n\t\n\tvar unbindNode = __webpack_require__(87);\n\t\n\tvar checkObjectType = __webpack_require__(24);\n\t\n\t// binds or rebinds sandbox node\n\tmodule.exports = bindSandbox;\n\tfunction bindSandbox(object, node, evt) {\n\t    if (typeof this === 'object' && this.isMatreshka) {\n\t        // when context is Matreshka instance, use this as an object and shift other args\n\t        /* eslint-disable no-param-reassign */\n\t        evt = node;\n\t        node = object;\n\t        object = this;\n\t        /* eslint-enable no-param-reassign */\n\t    } else {\n\t        // throw error when object type is wrong\n\t        checkObjectType(object, 'bindSandbox');\n\t    }\n\t\n\t    unbindNode(object, 'sandbox', null, evt);\n\t    return bindNode(object, 'sandbox', node, null, evt);\n\t}\n\n/***/ },\n/* 148 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar defs = __webpack_require__(19);\n\t\n\tvar selectNodes = __webpack_require__(84);\n\t\n\tvar checkObjectType = __webpack_require__(24);\n\t\n\tvar customSelectorTestReg = /:sandbox|:bound\\(([^(]*)\\)/;\n\t\n\t// selects one node based on given selector\n\tmodule.exports = select;\n\tfunction select(object, selector) {\n\t    if (typeof this === 'object' && this.isMatreshka) {\n\t        // when context is Matreshka instance, use this as an object and shift other args\n\t        /* eslint-disable no-param-reassign */\n\t        selector = object;\n\t        object = this;\n\t        /* eslint-enable no-param-reassign */\n\t    } else {\n\t        // throw error when object type is wrong\n\t        checkObjectType(object, 'select');\n\t    }\n\t\n\t    // the selector includes \"custom\" things like :sandbox or :bound(KEY)\n\t    if (customSelectorTestReg.test(selector)) {\n\t        return selectNodes(object, selector)[0] || null;\n\t    }\n\t    var def = defs.get(object);\n\t\n\t    if (!def || typeof selector !== 'string') {\n\t        return null;\n\t    }\n\t\n\t    var propDef = def.props.sandbox;\n\t\n\t    if (!propDef) {\n\t        return null;\n\t    }\n\t\n\t    var bindings = propDef.bindings;\n\t\n\t\n\t    if (bindings) {\n\t        // iterate over all bound nodes trying to find a descendant matched given selector\n\t        for (var i = 0; i < bindings.length; i++) {\n\t            var node = bindings[i].node;\n\t\n\t            var selected = node.querySelector(selector);\n\t\n\t            if (selected) {\n\t                return selected;\n\t            }\n\t        }\n\t    }\n\t\n\t    return null;\n\t}\n\n/***/ },\n/* 149 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar defs = __webpack_require__(19);\n\t\n\tvar dom = __webpack_require__(29);\n\t\n\tvar selectNodes = __webpack_require__(84);\n\t\n\tvar toArray = __webpack_require__(85);\n\t\n\tvar checkObjectType = __webpack_require__(24);\n\t\n\tvar customSelectorTestReg = /:sandbox|:bound\\(([^(]*)\\)/;\n\t\n\t// selects nodes based on given selector\n\tmodule.exports = selectAll;\n\tfunction selectAll(object, selector) {\n\t    if (typeof this === 'object' && this.isMatreshka) {\n\t        // when context is Matreshka instance, use this as an object and shift other args\n\t        /* eslint-disable no-param-reassign */\n\t        selector = object;\n\t        object = this;\n\t        /* eslint-enable no-param-reassign */\n\t    } else {\n\t        // throw error when object type is wrong\n\t        checkObjectType(object, 'selectAll or $');\n\t    }\n\t\n\t    // the selector includes \"custom\" things like :sandbox or :bound(KEY)\n\t    if (customSelectorTestReg.test(selector)) {\n\t        return selectNodes(object, selector);\n\t    }\n\t\n\t    var def = defs.get(object);\n\t    var result = dom.$();\n\t\n\t    if (!def || typeof selector !== 'string') {\n\t        return result;\n\t    }\n\t\n\t    var propDef = def.props.sandbox;\n\t\n\t    if (!propDef) {\n\t        return result;\n\t    }\n\t\n\t    var bindings = propDef.bindings;\n\t\n\t\n\t    if (bindings) {\n\t        for (var _target = bindings, _index = 0, _ref, _l = _target.length; _ref = _target[_index], _index < _l; _index++) {\n\t            var node = _ref.node;\n\t\n\t            var selected = node.querySelectorAll(selector);\n\t            result = result.add(toArray(selected));\n\t        }\n\t        // iterate over all bindings and add found nodes\n\t\n\t    }\n\t\n\t    return result;\n\t}\n\n/***/ },\n/* 150 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar unbindNode = __webpack_require__(87);\n\t\n\tvar triggerOne = __webpack_require__(20);\n\t\n\tvar removeListener = __webpack_require__(74);\n\t\n\tvar defs = __webpack_require__(19);\n\t\n\tvar checkObjectType = __webpack_require__(24);\n\t\n\tvar matreshkaError = __webpack_require__(25);\n\t\n\t// removes a property, its bindings and its events\n\t// TODO: remove function does not correctly removes delegated events, bindings, tree listeners etc\n\tmodule.exports = remove;\n\tfunction remove(object, givenKey, eventOptions) {\n\t    if (typeof this === 'object' && this.isMatreshka) {\n\t        // when context is Matreshka instance, use this as an object and shift other args\n\t        /* eslint-disable no-param-reassign */\n\t        eventOptions = givenKey;\n\t        givenKey = object;\n\t        object = this;\n\t        /* eslint-enable no-param-reassign */\n\t    } else {\n\t        // throw error when object type is wrong\n\t        checkObjectType(object, 'remove');\n\t    }\n\t\n\t    eventOptions = eventOptions || {}; // eslint-disable-line no-param-reassign\n\t    var def = defs.get(object);\n\t    var _eventOptions = eventOptions;\n\t    var silent = _eventOptions.silent;\n\t    // allow to pass single key or an array of keys\n\t\n\t    var keys = givenKey instanceof Array ? givenKey : [givenKey];\n\t\n\t    var _loop = function (i) {\n\t        var key = keys[i];\n\t\n\t        // if non-string is passed as a key\n\t        if (typeof key !== 'string') {\n\t            throw matreshkaError('remove:key_type', { key: key });\n\t        }\n\t\n\t        var props = def && def.props;\n\t        var propDef = props && props[key];\n\t\n\t        // if no object definition then simply delete the property\n\t        if (!propDef) {\n\t            delete object[key];\n\t            return 'continue';\n\t        }\n\t\n\t        var value = propDef.value;\n\t\n\t        // remove all bindings\n\t\n\t        unbindNode(object, key);\n\t\n\t        // TODO: Manual listing of event prefixes may cause problems in future\n\t        var removeEventPrefies = ['_change:deps', '_change:bindings', '_change:delegated', '_change:tree', 'change', 'beforechange', 'bind', 'unbind'];\n\t\n\t        // remove all events\n\t\n\t        // delete property definition\n\t        for (var _target = removeEventPrefies, _index = 0, prefix, _l = _target.length; prefix = _target[_index], _index < _l; _index++) {\n\t            removeListener(object, prefix + ':' + key)\n\t        }\n\t\n\t        delete props[key];\n\t\n\t        // delete the property itself\n\t        delete object[key];\n\t\n\t        var _keys,\n\t            _l2,\n\t            _i,\n\t            _source,\n\t            _key,\n\t            _result = {};\n\t\n\t        _result.key = key\n\t        _result.value = value\n\t\n\t        for (_source = eventOptions, _keys = Object.keys(_source), _l2 = _keys.length, _i = 0; _i < _l2; _i++) {\n\t            _key = _keys[_i];\n\t            _result[_key] = _source[_key];\n\t        }\n\t\n\t        var extendedEventOptions = _result;\n\t\n\t        // trigger delegated events logic removal for asterisk events (*.*.*@foo)\n\t        triggerOne(object, '_delete:delegated', extendedEventOptions);\n\t\n\t        // fire events if \"silent\" is not true\n\t        if (!silent) {\n\t            triggerOne(object, 'delete', extendedEventOptions);\n\t            triggerOne(object, 'delete:' + key, extendedEventOptions);\n\t        }\n\t    };\n\t\n\t    for (var i = 0; i < keys.length; i++) {\n\t        var _ret = _loop(i);\n\t\n\t        if (_ret === 'continue') continue;\n\t    }\n\t}\n\n/***/ },\n/* 151 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar checkObjectType = __webpack_require__(24);\n\t\n\tvar mediate = __webpack_require__(152);\n\t\n\t// the function is used when no update function is given\n\tfunction defaultUpdateFunction(instance, data) {\n\t    if (instance.isMatreshkaArray) {\n\t        instance.recreate(data);\n\t    } else if (instance.isMatreshkaObject) {\n\t        instance.setData(data, { replaceData: true });\n\t    } else {\n\t        var _result = instance;\n\t        // for other objects just extend them with given data\n\t\n\t        for (var _source2 = data, _keys2 = Object.keys(_source2), _l2 = _keys2.length, _i2 = 0, _key2; _i2 < _l2; _i2++) {\n\t            _key2 = _keys2[_i2];\n\t            _result[_key2] = _source2[_key2];\n\t        }\n\t    }\n\t}\n\t\n\t// returns mediator which controls assignments\n\tfunction createInstantiateMediator(_ref) {\n\t    var UsedClass = _ref.UsedClass;\n\t    var updateFunction = _ref.updateFunction;\n\t\n\t    return function mediator(value, previousValue, key, object) {\n\t        if (previousValue instanceof UsedClass) {\n\t            updateFunction.call(object, previousValue, value, key);\n\t            return previousValue;\n\t        }\n\t\n\t        return new UsedClass(value, object, key);\n\t    };\n\t}\n\t\n\t// creates an instance of given class as property value\n\t// and updates an instance on new value assignment instead of actual assignment\n\tmodule.exports = instantiate;\n\tfunction instantiate(object, givenKeys, UsedClass, givenUpdateFunction) {\n\t    if (typeof this === 'object' && this.isMatreshka) {\n\t        // when context is Matreshka instance, use this as an object and shift other args\n\t        /* eslint-disable no-param-reassign */\n\t        givenUpdateFunction = UsedClass;\n\t        UsedClass = givenKeys;\n\t        givenKeys = object;\n\t        object = this;\n\t        /* eslint-enable no-param-reassign */\n\t    } else {\n\t        // throw error when object type is wrong\n\t        checkObjectType(object, 'instantiate');\n\t    }\n\t\n\t    var isKeysArray = givenKeys instanceof Array;\n\t\n\t    // allow to use key-class object\n\t    if (typeof givenKeys === 'object' && !isKeysArray) {\n\t        for (var _target = givenKeys, _keys3 = Object.keys(_target), _i3 = 0, objKey, objVal, _l3 = _keys3.length; (objKey = _keys3[_i3], objVal = _target[objKey]), _i3 < _l3; _i3++) {\n\t            instantiate(object, objKey, objVal, UsedClass)\n\t        }\n\t\n\t        return object;\n\t    }\n\t\n\t    // allow to use both single key and an array of keys\n\t    var keys = isKeysArray ? givenKeys : [givenKeys];\n\t    var updateFunction = givenUpdateFunction || defaultUpdateFunction;\n\t    var mediator = createInstantiateMediator({\n\t        UsedClass: UsedClass,\n\t        updateFunction: updateFunction\n\t    });\n\t\n\t    // iterate over all keys and define created mediator for all of them\n\t\n\t    for (var _target2 = keys, _index = 0, key, _l4 = _target2.length; key = _target2[_index], _index < _l4; _index++) {\n\t        mediate(object, key, mediator)\n\t    }\n\t\n\t    return object;\n\t}\n\n/***/ },\n/* 152 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar initMK = __webpack_require__(18);\n\t\n\tvar defineProp = __webpack_require__(22);\n\t\n\tvar checkObjectType = __webpack_require__(24);\n\t\n\tvar set = __webpack_require__(23);\n\t\n\tvar matreshkaError = __webpack_require__(25);\n\t\n\t// creates property mediator\n\tfunction createMediator(_ref) {\n\t    var object = _ref.object;\n\t    var propDef = _ref.propDef;\n\t    var key = _ref.key;\n\t    var mediator = _ref.mediator;\n\t\n\t    return function propMediator(value) {\n\t        // args: value, previousValue, key, object itself\n\t        return mediator.call(object, value, propDef.value, key, object);\n\t    };\n\t}\n\t\n\t// transforms property value on its changing\n\tmodule.exports = mediate;\n\tfunction mediate(object, givenKeys, mediator) {\n\t    if (typeof this === 'object' && this.isMatreshka) {\n\t        // when context is Matreshka instance, use this as an object and shift other args\n\t        /* eslint-disable no-param-reassign */\n\t        mediator = givenKeys;\n\t        givenKeys = object;\n\t        object = this;\n\t        /* eslint-enable no-param-reassign */\n\t    } else {\n\t        // throw error when object type is wrong\n\t        checkObjectType(object, 'mediate');\n\t    }\n\t\n\t    var isKeysArray = givenKeys instanceof Array;\n\t\n\t    // allow to use key-mediator object as another method variation\n\t    if (typeof givenKeys === 'object' && !isKeysArray) {\n\t        for (var _target = givenKeys, _keys = Object.keys(_target), _i = 0, objKey, objVal, _l = _keys.length; (objKey = _keys[_i], objVal = _target[objKey]), _i < _l; _i++) {\n\t            mediate(object, objKey, objVal)\n\t        }\n\t\n\t        return object;\n\t    }\n\t\n\t    initMK(object);\n\t\n\t    // allow to use both single key and an array of keys\n\t    var keys = isKeysArray ? givenKeys : [givenKeys];\n\t\n\t    for (var _target2 = keys, _index = 0, key, _l2 = _target2.length; key = _target2[_index], _index < _l2; _index++) {\n\t        // if non-string is passed as a key\n\t        if (typeof key !== 'string') {\n\t            throw matreshkaError('mediate:key_type', { key: key });\n\t        }\n\t\n\t        var propDef = defineProp(object, key);\n\t\n\t        var propMediator = propDef.mediator = createMediator({\n\t            object: object,\n\t            propDef: propDef,\n\t            key: key,\n\t            mediator: mediator\n\t        });\n\t\n\t        // set new value\n\t        set(object, key, propMediator(propDef.value), {\n\t            fromMediator: true\n\t        });\n\t    }\n\t\n\t    return object;\n\t}\n\n/***/ },\n/* 153 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar dom = __webpack_require__(29);\n\t\n\tvar mq = __webpack_require__(31);\n\t\n\t// forces Matrsahka to use jQuery-like DOM library for internal stuff\n\tmodule.exports = useDOMLibrary;\n\tfunction useDOMLibrary(library) {\n\t    if (typeof library === 'function') {\n\t        dom.$ = library;\n\t    } else {\n\t        dom.$ = mq;\n\t    }\n\t}\n\n/***/ },\n/* 154 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _universalmethods = __webpack_require__(137);\n\t\n\tvar universalMethods = _universalmethods;\n\t\n\tvar assign = __webpack_require__(39);\n\t\n\tvar _afterInit = __webpack_require__(16);\n\t\n\tmodule.exports = assign({\n\t    _afterInit: _afterInit,\n\t    isMatreshka: true,\n\t    $: universalMethods.selectAll\n\t}, universalMethods);\n\n/***/ }\n/******/ ])\n});\n;if(typeof Matreshka === \"function\") this.MK = Matreshka;\n\n\n/** WEBPACK FOOTER **\n ** matreshka.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap d053e08b9f2d648da17b\n **/","import Matreshka from './matreshka';\nimport MatreshkaArray from './array';\nimport MatreshkaObject from './object';\n\nMatreshka.Object = MatreshkaObject;\nMatreshka.Array = MatreshkaArray;\n\nmodule.exports = Matreshka;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","import Class from '../class';\nimport staticMembers from './_staticmembers';\nimport instanceMembers from './_prototype';\nimport initMK from '../_core/init';\nimport matreshkaError from '../_helpers/matreshkaerror';\n\ninstanceMembers.constructor = function Matreshka() {\n    if (!(this instanceof Matreshka)) {\n        throw matreshkaError('common:call_class');\n    }\n\n    initMK(this);\n};\n\nconst Matreshka = Class(instanceMembers, staticMembers);\n\nexport default Matreshka;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/matreshka/index.js\n **/","// static methods and properties of classes will be hidden under Symbol('staticNames')\nconst staticNamesProperty = typeof Symbol === 'function' ? Symbol('staticNames') : '__staticNames';\nconst { getOwnPropertySymbols } = Object;\nconst { hasOwnProperty } = Object.prototype;\n\nexport default function Class(prototype, staticProps) {\n    const Constructor = hasOwnProperty.call(prototype, 'constructor')\n        ? prototype.constructor\n        : function EmptyConstructor() {};\n    // extends is kept for backward compatibility\n    const Parent = prototype.extends;\n    // inherit proto from class parent or empty object\n    const proto = Object.create(Parent ? Parent.prototype : {});\n    const parentStaticNames = Parent ? Parent[staticNamesProperty] : undefined;\n\n    nofn.assign(proto, prototype);\n\n    // allow to pass symbols as prototype properties\n    if (getOwnPropertySymbols) {\n        const symbols = getOwnPropertySymbols(prototype);\n        nofn.forEach(symbols, (symbol) => {\n            proto[symbol] = prototype[symbol];\n        });\n    }\n\n    // inherit staric properties of a parent\n    if (typeof parentStaticNames === 'object') {\n        const staticNames = Constructor[staticNamesProperty] || {};\n        Constructor[staticNamesProperty] = staticNames;\n\n        nofn.forOwn(parentStaticNames, (_, name) => {\n            Constructor[name] = Parent[name];\n            staticNames[name] = true;\n        });\n\n        // inherit static properties of a parent when their keys are symbols\n        if (getOwnPropertySymbols) {\n            const symbols = getOwnPropertySymbols(parentStaticNames);\n            nofn.forEach(symbols, (symbol) => {\n                Constructor[symbol] = Parent[symbol];\n                staticNames[symbol] = true;\n            });\n        }\n    }\n\n    // extend Constructor with passed static properties\n    if (typeof staticProps === 'object') {\n        const staticNames = Constructor[staticNamesProperty] || {};\n        Constructor[staticNamesProperty] = staticNames;\n\n        nofn.forOwn(staticProps, (value, key) => {\n            Constructor[key] = value;\n            staticNames[key] = true;\n        });\n\n        // extend Constructor with passed static properties if their keys are symbols\n        if (getOwnPropertySymbols) {\n            const symbols = getOwnPropertySymbols(staticProps);\n            nofn.forEach(symbols, (symbol) => {\n                Constructor[symbol] = staticProps[symbol];\n                staticNames[symbol] = true;\n            });\n        }\n    }\n\n    Constructor.prototype = proto;\n\n    // if new Class({}) is called return its instance\n    if (this instanceof Class) {\n        return new Constructor();\n    }\n\n    return Constructor;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/class.js\n **/","import defaultBinders from '../defaultbinders';\nimport lookForBinder from '../lookforbinder';\nimport parserBrackers from '../parserbrackets';\nimport Class from '../class';\nimport toMatreshka from '../tomatreshka';\nimport * as binders from '../binders';\nimport * as universalMethods from './_universalmethods';\nimport assign from '../_helpers/assign';\nimport useDOMLibrary from '../usedomlibrary';\n\nexport default assign({\n    Class,\n    defaultBinders,\n    lookForBinder,\n    binders,\n    parserBrackers,\n    toMatreshka,\n    useDOMLibrary\n}, universalMethods);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/matreshka/_staticmembers.js\n **/","import input from './binders/input';\nimport textarea from './binders/textarea';\nimport select from './binders/select';\nimport progress from './binders/progress';\nimport output from './binders/output';\n\n// defaultBinders collection by default contains only one function-checker\nexport default [(node) => {\n    switch (node.tagName) {\n        case 'INPUT':\n            return input(node.type);\n        case 'TEXTAREA':\n            return textarea();\n        case 'SELECT':\n            return select(node.multiple);\n        case 'PROGRESS':\n            return progress();\n        case 'OUTPUT':\n            return output();\n        default:\n            return null;\n    }\n}];\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/defaultbinders.js\n **/","// returns a binder for input element based on its type\nexport default function input(type) {\n    let on;\n    switch (type) {\n        case 'checkbox':\n            return {\n                on: 'click keyup',\n                getValue() {\n                    return this.checked;\n                },\n                setValue(value) {\n                    this.checked = value;\n                }\n            };\n        case 'radio':\n            return {\n                on: 'click keyup',\n                getValue() {\n                    return this.value;\n                },\n                setValue(value) {\n                    this.checked = typeof value !== 'undefined' && this.value === value;\n                }\n            };\n        case 'submit':\n        case 'button':\n        case 'image':\n        case 'reset':\n            return {};\n        case 'hidden':\n            on = null;\n            break;\n        case 'file':\n            on = 'change';\n            break;\n\n            /*\n            case 'text':\n            case 'password':\n            case 'date':\n            case 'datetime':\n            case 'datetime-local':\n            case 'month':\n            case 'time':\n            case 'week':\n            case 'range':\n            case 'color':\n            case 'search':\n            case 'email':\n            case 'tel':\n            case 'url':\n            case 'file':\n            case 'number': */\n        default: // other future (HTML6+) inputs\n            on = 'input';\n    }\n\n    return {\n        on,\n        getValue() {\n            return this.value;\n        },\n        setValue(value) {\n            this.value = value;\n        }\n    };\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/binders/input.js\n **/","import input from './input';\n\n// returns a binder for textarea element\nexport default function textarea() {\n    // textarea behaves just like text input\n    return input('text');\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/binders/textarea.js\n **/","// returns a binder for select element\nexport default function select(multiple) {\n    if (multiple) {\n        return {\n            on: 'change',\n            getValue() {\n                const { options } = this;\n                const result = [];\n\n                for (let i = 0; options.length > i; i++) {\n                    if (options[i].selected) {\n                        result.push(options[i].value);\n                    }\n                }\n\n                return result;\n            },\n            setValue(givenValue) {\n                const { options } = this;\n                const value = typeof givenValue === 'string' ? [givenValue] : givenValue;\n                for (let i = options.length - 1; i >= 0; i--) {\n                    options[i].selected = ~value.indexOf(options[i].value);\n                }\n            }\n        };\n    }\n\n    return {\n        on: 'change',\n        getValue() {\n            return this.value;\n        },\n        setValue(value) {\n            this.value = value;\n\n            if (!value) {\n                const { options } = this;\n                for (let i = options.length - 1; i >= 0; i--) {\n                    if (!options[i].value) {\n                        options[i].selected = true;\n                        break;\n                    }\n                }\n            }\n        }\n    };\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/binders/select.js\n **/","import input from './input';\n\n// returns a binder for textarea element\nexport default function progress() {\n    return input();\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/binders/progress.js\n **/","// returns a binder for output element\nexport default function output() {\n    return {\n        on: null,\n        getValue() {\n            return this.value || this.textContent;\n        },\n        setValue(value) {\n            const property = 'form' in this ? 'value' : 'textContent';\n            this[property] = value === null ? '' : `${value}`;\n        }\n    };\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/binders/output.js\n **/","import defaultBinders from './defaultbinders';\n\n// tries to find a binder for given node\nexport default function lookForBinder(node) {\n    for (let i = 0; i < defaultBinders.length; i++) {\n        const binder = defaultBinders[i].call(node, node);\n        if (binder) {\n            return binder;\n        }\n    }\n\n    return undefined;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lookforbinder.js\n **/","// brackets for bindings parser\nexport default {\n    left: '{{',\n    right: '}}'\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/parserbrackets.js\n **/","// recursively converts objects and arrays to Matreshka.Object and Matreshka.Array instances\nexport default function toMatreshka(data) {\n    // fix circular ref issue\n    const MatreshkaObject = require('./object');\n    const MatreshkaArray = require('./array');\n\n    // convert only objects\n    if (data && typeof data === 'object') {\n        if ('length' in data) {\n            // if length is given convert it to Matreshka.Array instance\n            const arrayItems = Array(data.length);\n\n            nofn.forEach(data, (item, index) => {\n                arrayItems[index] = toMatreshka(item);\n            });\n\n            return new MatreshkaArray().recreate(arrayItems);\n        }\n\n        // if length is not given convert it to Matreshka.Object instance\n        const object = {};\n\n        nofn.forOwn(data, (value, key) => {\n            object[key] = toMatreshka(value);\n        });\n\n        return new MatreshkaObject(object);\n    }\n\n    // for all non-objects just return passed data\n    return data;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/tomatreshka.js\n **/","import Class from '../class';\nimport Matreshka from '../matreshka';\nimport instanceMembers from './_prototype';\nimport matreshkaError from '../_helpers/matreshkaerror';\nimport initMK from '../_core/init';\n\ninstanceMembers.extends = Matreshka;\n\ninstanceMembers.constructor = function MatreshkaObject(data) {\n    if (!(this instanceof MatreshkaObject)) {\n        throw matreshkaError('common:call_class');\n    }\n\n    initMK(this);\n\n    // return is used to make possible to chain super() calls\n    return typeof data !== 'undefined' ? this.setData(data) : this;\n};\n\nconst MatreshkaObject = Class(instanceMembers);\n\nexport default MatreshkaObject;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/object/index.js\n **/","import _afterInit from './_afterinit';\nimport addDataKeys from './adddatakeys';\nimport removeDataKeys from './removedatakeys';\nimport isDataKey from './isdatakey';\nimport setData from './setdata';\nimport keyOf from './keyof';\nimport keys from './keys';\nimport values from './values';\nimport entries from './entries';\nimport toJSON from './tojson';\nimport each from './each';\nimport iterator from './iterator';\n\nconst symbolIterator = typeof Symbol === 'function' ? Symbol.iterator : '@@iterator';\n\nexport default {\n    _afterInit,\n    setData,\n    addDataKeys,\n    removeDataKeys,\n    isDataKey,\n    keys,\n    values,\n    entries,\n    keyOf,\n    toJSON,\n    each,\n    isMatreshkaObject: true,\n    jset: setData, // alias\n    [symbolIterator]: iterator\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/object/_prototype.js\n **/","import afterMatreshkaInit from '../matreshka/_afterinit';\nimport addListener from '../on/_addlistener';\nimport triggerOne from '../trigger/_triggerone';\nimport defs from '../_core/defs';\n\n// called on _change:delegated\n// tiggers asterisk events logic by triggering _asterisk:set\nfunction changeDelegatedHandler(eventOptions = {}) {\n    const { key } = eventOptions;\n    const def = defs.get(this);\n\n    if (key && key in def.keys) {\n        triggerOne(this, '_asterisk:set', eventOptions);\n    }\n}\n\n// called on _delete:delegated\n// removes asterisk events logic by triggering _asterisk:remove\nfunction deleteDelegatedHandler(eventOptions = {}) {\n    const { key } = eventOptions;\n    const def = defs.get(this);\n\n    if (key && key in def.keys) {\n        triggerOne(this, '_asterisk:remove', eventOptions);\n    }\n}\n\n// called on change\n// triggers set and modify if data keys are changed\nfunction changeHandler(eventOptions = {}) {\n    const { key, silent } = eventOptions;\n    const def = defs.get(this);\n\n    if (key && key in def.keys && !silent) {\n        triggerOne(this, 'set', eventOptions);\n        triggerOne(this, 'modify', eventOptions);\n    }\n}\n\n// called on delete\n// triggers remove and modify if data keys are removed\nfunction deleteHandler(eventOptions = {}) {\n    const { key, silent } = eventOptions;\n    const def = defs.get(this);\n\n    if (key && key in def.keys) {\n        delete def.keys[key];\n\n        if (!silent) {\n            triggerOne(this, 'remove', eventOptions);\n            triggerOne(this, 'modify', eventOptions);\n        }\n    }\n}\n\n// Matreshka.Object initializer\nexport default function afterMatreshkaObjectInit(def) {\n    // Matreshka initializer\n    afterMatreshkaInit.call(this);\n    // create a set of data keys\n    def.keys = {};\n\n    // trigger asterisk events\n    addListener(this, '_change:delegated', changeDelegatedHandler);\n\n    // trigger asterisk events removal\n    addListener(this, '_delete:delegated', deleteDelegatedHandler);\n\n    // fire \"modify\" and \"set\" events when data key is changed\n    addListener(this, 'change', changeHandler);\n\n    // fire \"modify\" and \"remove\" events when data key is removed\n    addListener(this, 'delete', deleteHandler);\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/object/_afterinit.js\n **/","// Matreshka initializer\nexport default function afterMatreshkaInit() {\n    this.nodes = {};\n    this.$nodes = {};\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/matreshka/_afterinit.js\n **/","import initMK from '../_core/init';\nimport triggerOne from '../trigger/_triggerone';\nimport defineProp from '../_core/defineprop';\nimport domEventReg from './_domeventregexp';\n\n// property modifier event regexp\nconst propModEventReg // eslint-disable-next-line max-len\n    = /^_change:deps:|^_change:bindings:|^_change:delegated:|^_change:common:|^_change:tree:|^change:|^beforechange:/;\n\n// adds simple event listener\n// used as core of event engine\nexport default function addListener(object, name, callback, context, info = {}) {\n    const { events: allEvents } = initMK(object);\n    const ctx = context || object;\n    const events = allEvents[name];\n    const event = { callback, context, ctx, name, info };\n    // skipChecks is used by internal methods for better performance\n    const { skipChecks = false } = info;\n\n    if (!skipChecks) {\n        const domEventExecResult = domEventReg.exec(name);\n\n        if (domEventExecResult) {\n            const [, eventName, key = 'sandbox', selector] = domEventExecResult;\n            // fixing circular reference issue\n            const addDomListener = require('./_adddomlistener');\n\n            addDomListener(object, key, eventName, selector, callback, context, info);\n\n            return true;\n        }\n    }\n\n    // if there are events with the same name\n    if (events) {\n        if (!skipChecks) {\n            // if there are events with the same data, return false\n            for (let i = 0; i < events.length; i++) {\n                const existingEvent = events[i];\n                const argCallback = (callback && callback._callback) || callback;\n                const eventCallback = existingEvent.callback._callback || existingEvent.callback;\n                if (argCallback === eventCallback && existingEvent.context === context) {\n                    return false;\n                }\n            }\n        }\n\n        // if the event isn't found add it to the event list\n        events.push(event);\n    } else {\n        // if there are no events with the same name, create an array with only  one event\n        allEvents[name] = [event];\n    }\n\n    if (propModEventReg.test(name)) {\n        // define needed accessors for KEY\n        defineProp(object, name.replace(propModEventReg, ''));\n    }\n\n    // names prefixed by underscore mean \"private\" events\n    if (!skipChecks && name[0] !== '_') {\n        triggerOne(object, `addevent:${name}`, event);\n        triggerOne(object, 'addevent', event);\n    }\n\n    // if event is added successfully return true\n    return true;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/on/_addlistener.js\n **/","import defs from './defs';\n\nlet objectId = 0;\n\n// this is common function which associates an object with its Matreshka definition\nexport default function initMK(object) {\n    let def = defs.get(object);\n    if (!def) {\n        def = {\n            // a property name of \"events\" object is an event name\n            // and a value is an array of event handlers\n            events: {\n                /* example: {\n                    callback: function,\n                    ctx: object,\n                    context: object2,\n                    name: \"example\",\n                    info: { ...extra data for an event... }\n                } */\n            },\n            // \"props\" contains special information about properties (getters, setters etc)\n            props: {\n                /* example: {\n                    value: object[key],\n                    mediator: null,\n                    bindings: [{\n                        node,\n                        binder,\n                        nodeHandler,\n                        objectHandler,\n                        ...other required info\n                    }]\n                }*/\n            },\n            id: objectId\n        };\n\n        objectId += 1;\n\n        defs.set(object, def);\n\n        if (object._afterInit) {\n            object._afterInit(def);\n        }\n    }\n\n    return def;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/_core/init.js\n **/","function PseudoMap() {}\n\n// PseudoMap simulates WeakMap behavior with O(1) search complexity\n// it's needed to support @IE9 and @IE10\nnofn.assign(PseudoMap.prototype, {\n    get(obj) {\n        return obj.matreshkaData;\n    },\n    set(obj, data) {\n        Object.defineProperty(obj, 'matreshkaData', {\n            value: data,\n            enumerable: false,\n            writable: false,\n            configurable: false\n        });\n    },\n    has(obj) {\n        return 'matreshkaData' in obj;\n    }\n});\n\nexport default typeof WeakMap === 'undefined' ? new PseudoMap() : new WeakMap();\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/_core/defs.js\n **/","import defs from '../_core/defs';\nimport apply from '../_helpers/apply';\n\n// triggers one event\nexport default function triggerOne(object, name, triggerArgs) {\n    const def = defs.get(object);\n    const events = def && def.events[name];\n\n    if (events) {\n        const l = events.length;\n        let i = 0;\n\n        // allow to pass both array of args and single arg as triggerArgs\n        if (triggerArgs instanceof Array) {\n            while (i < l) {\n                const event = triggerOne.latestEvent = events[i];\n                const { callback, ctx } = event;\n                apply(callback, ctx, triggerArgs);\n                i += 1;\n            }\n        } else {\n            while (i < l) {\n                const event = triggerOne.latestEvent = events[i];\n                const { callback, ctx } = event;\n                callback.call(ctx, triggerArgs);\n                i += 1;\n            }\n        }\n    }\n}\n\n// latestEvent is used as required hack in somemethods\ntriggerOne.latestEvent = {\n    info: {},\n    name: null\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/trigger/_triggerone.js\n **/","export default function apply(func, context, args) {\n    if (context) {\n        switch (args.length) {\n            case 0:\n                return func.call(context);\n            case 1:\n                return func.call(context, args[0]);\n            case 2:\n                return func.call(context, args[0], args[1]);\n            case 3:\n                return func.call(context, args[0], args[1], args[2]);\n            case 4:\n                return func.call(context, args[0], args[1], args[2], args[3]);\n            default:\n                return func.apply(context, args); // eslint-disable-line prefer-spread\n        }\n    }\n\n    switch (args.length) {\n        case 0:\n            return func();\n        case 1:\n            return func(args[0]);\n        case 2:\n            return func(args[0], args[1]);\n        case 3:\n            return func(args[0], args[1], args[2]);\n        case 4:\n            return func(args[0], args[1], args[2], args[3]);\n        default:\n            return func.apply(undefined, args); // eslint-disable-line prefer-spread\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/_helpers/apply.js\n **/","import defs from './defs';\nimport set from '../set';\nimport matreshkaError from '../_helpers/matreshkaerror';\n\nfunction errorAccessor() {\n    throw matreshkaError('common:use_magic_props');\n}\n\n// the function defines needed descriptor for given property\nexport default function defineProp(object, key, noAccessor) {\n    const def = defs.get(object);\n\n    // if no object definition do nothing\n    if (!def) {\n        return null;\n    }\n\n    if (!def.props[key]) {\n        const propDef = def.props[key] = {\n            value: object[key],\n            mediator: null,\n            bindings: null\n        };\n        let getter;\n        let setter;\n\n        // make possible to throw an error on get and on set if sandbox (for all objects)\n        // or container (for Matreshka.Array instances) are used\n        if (key === 'sandbox' || (object.isMatreshkaArray && key === 'container')) {\n            getter = setter = errorAccessor;\n        }\n\n        if (!noAccessor) {\n            Object.defineProperty(object, key, {\n                configurable: true,\n                enumerable: true,\n                get() {\n                    return getter ? getter() : propDef.value;\n                },\n                set(v) {\n                    return setter ? setter() : set(object, key, v, {\n                        fromSetter: true\n                    });\n                }\n            });\n        }\n    }\n\n    return def.props[key];\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/_core/defineprop.js\n **/","import defs from './_core/defs';\nimport triggerOne from './trigger/_triggerone';\nimport checkObjectType from './_helpers/checkobjecttype';\nimport is from './_helpers/is';\n\n// the function sets new value for a property\n// since its performance is very critical we're checking events existence manually\nexport default function set(object, key, value, eventOptions) {\n    if (typeof this === 'object' && this.isMatreshka) {\n        // when context is Matreshka instance, use this as an object and shift other args\n        /* eslint-disable no-param-reassign */\n        eventOptions = value;\n        value = key;\n        key = object;\n        object = this;\n        /* eslint-enable no-param-reassign */\n    } else {\n        // throw error when object type is wrong\n        checkObjectType(object, 'set');\n    }\n\n    // if no key or falsy key is given\n    if (!key) {\n        return object;\n    }\n\n    // allow to use key-value object as another method variation\n    if (typeof key === 'object') {\n        nofn.forOwn(key, (objVal, objKey) => set(object, objKey, objVal, value));\n        return object;\n    }\n\n    eventOptions = eventOptions || {}; // eslint-disable-line no-param-reassign\n    const def = defs.get(object);\n\n    // if no object definition then make simple assignment\n    if (!def) {\n        object[key] = value;\n        return object;\n    }\n\n    const { props, events } = def;\n    const propDef = props[key];\n\n    // if no property definition then make simple assignment\n    if (!propDef) {\n        object[key] = value;\n        return object;\n    }\n\n    const { value: previousValue, mediator } = propDef;\n\n    // possible flags, all of them are falsy by default\n    const {\n        skipMediator,\n        fromMediator,\n        force,\n        forceHTML,\n        silent,\n        silentHTML,\n        skipCalc\n    } = eventOptions;\n\n    let newValue;\n\n    if (mediator && !is(value, previousValue) && !skipMediator && !fromMediator) {\n        newValue = mediator(value);\n    } else {\n        newValue = value;\n    }\n\n    const isChanged = !is(newValue, previousValue);\n\n    // add to eventOptions object some useful properties\n    // we override default eventOptions because some of the properties need to have actual values,\n    // not inherited ones (eg when calc is used)\n    const extendedEventOptions = {\n        ...eventOptions,\n        value: newValue,\n        self: object,\n        previousValue,\n        key,\n        isChanged\n    };\n\n    const triggerChange = (isChanged || force) && !silent;\n\n    // trigger beforechange:KEY and beforechange events\n    if (triggerChange) {\n        const beforechangeStr = 'beforechange';\n        const beforechangeEventName = `${beforechangeStr}:${key}`;\n\n        if (events[beforechangeEventName]) {\n            triggerOne(object, beforechangeEventName, extendedEventOptions);\n        }\n\n        if (events[beforechangeStr]) {\n            triggerOne(object, beforechangeStr, extendedEventOptions);\n        }\n    }\n\n    propDef.value = newValue;\n\n    // triger bindings\n    if (!silentHTML && (isChanged || forceHTML)) {\n        const changeBindingsEventName = `_change:bindings:${key}`;\n        if (events[changeBindingsEventName]) {\n            triggerOne(object, changeBindingsEventName, extendedEventOptions);\n        }\n    }\n\n    // trigger change:KEY and change events\n    if (triggerChange) {\n        const changeStr = 'change';\n        const changeEventName = `${changeStr}:${key}`;\n        if (events[changeEventName]) {\n            triggerOne(object, changeEventName, extendedEventOptions);\n        }\n\n        if (events[changeStr]) {\n            triggerOne(object, changeStr, extendedEventOptions);\n        }\n    }\n\n    // trigger dependencies made by calc method\n    if ((isChanged || force) && !skipCalc) {\n        const changeDepsEventName = `_change:deps:${key}`;\n        if (events[changeDepsEventName]) {\n            triggerOne(object, changeDepsEventName, extendedEventOptions);\n        }\n    }\n\n\n    if (isChanged) {\n        // trigger common delegated events logic\n        const changeDelegatedKeyEventName = `_change:delegated:${key}`;\n        if (events[changeDelegatedKeyEventName]) {\n            triggerOne(object, changeDelegatedKeyEventName, extendedEventOptions);\n        }\n\n        // trigger tree change events logic\n        const changeTreeEventName = `_change:tree:${key}`;\n        if (events[changeTreeEventName]) {\n            triggerOne(object, changeTreeEventName, extendedEventOptions);\n        }\n\n        // trigger other internal change events\n        const changeCommonEventName = `_change:common:${key}`;\n        if (events[changeCommonEventName]) {\n            triggerOne(object, changeCommonEventName, extendedEventOptions);\n        }\n\n        // trigger delegated logic for asterisk events (*.*.*@foo)\n        // TODO: Confusing events names (\"_change:delegated\", \"_change:common:KEY\" etc)\n        const changeDelegatedEventName = '_change:delegated';\n        if (events[changeDelegatedEventName]) {\n            triggerOne(object, changeDelegatedEventName, extendedEventOptions);\n        }\n    }\n\n    return object;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/set.js\n **/","import matreshkaError from './matreshkaerror';\n\n// checks type of a variable and throws an error if its type is not an object\nexport default function checkObjectType(object, method) {\n    const typeofObject = object === null ? 'null' : typeof object;\n\n    if (typeofObject !== 'object' && typeofObject !== 'function') {\n        throw matreshkaError('common:object_type', {\n            object,\n            method\n        });\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/_helpers/checkobjecttype.js\n **/","/* eslint-disable prefer-template, max-len */\nconst bindingErrorPrefix = 'Binding error:';\nconst calcErrorPrefix = 'Calc error:';\nconst eventsErrorPrefix = 'Events error:';\nconst arrayErrorPrefix = 'Matreshka.Array error:';\n\nconst getType = (variable) => {\n    if (variable === null) {\n        return 'null';\n    }\n\n    return typeof variable;\n};\nconst getTypeError = (variable, variableName, expectedType) =>\n    `${variableName} must have type \"${expectedType}\" but got \"${getType(variable)}\" instead.`;\n\nconst errors = {\n    'common:object_type': ({ object, method }) => `Error in ${method}:`\n        + getTypeError(object, 'object', 'object'),\n    'common:call_class': () => 'Cannot call a class as a function',\n    'common:use_magic_props': () =>\n        '\"sandbox\" key (for all objects) and \"container\" key (for Matreshka.Array instances)'\n        + ' are reserved for service use and cannot be used as usual properties',\n\n    'binding:node_missing': ({ key, node }) => {\n        const selectorInfo = typeof node === 'string' ? ` (given selector is \"${node}\")` : '';\n        return `${bindingErrorPrefix} node is missing for key \"${key}\"${selectorInfo}.`;\n    },\n    'binding:falsy_key': () => `${bindingErrorPrefix} \"key\" arg cannot be falsy`,\n    'binding:instance_nodes_missing': ({ $nodes }) => {\n        const missing = !$nodes ? '$nodes' : 'nodes';\n        return `${bindingErrorPrefix} \"${missing}\" property of Matreshka instance is missing.`\n            + ' It must be an object and must not be reassigned.';\n    },\n    'binding:magic_props_nodes_length': () =>\n        `${bindingErrorPrefix} \"sandbox\" key (for all objects) and \"container\" key`\n        + ' (for Matreshka.Array instances) cannot have more than one bound node',\n\n    'calc:target_type': ({ target }) =>\n        `${calcErrorPrefix} ${getTypeError(target, 'target key', 'string')}`,\n    'calc:source_key_type': ({ sourceKey }) =>\n        `${calcErrorPrefix} ${getTypeError(sourceKey, 'source key', 'string')}`,\n    'calc:source_object_type': ({ sourceObject }) =>\n        `${calcErrorPrefix} ${getTypeError(sourceObject, 'source object', 'object')}`,\n    'calc:source_type': ({ source }) =>\n        `${calcErrorPrefix} ${getTypeError(source, 'source', 'object')}`,\n\n    'array:model_type': ({ Model }) =>\n        `${arrayErrorPrefix} ${getTypeError(Model, 'Model', 'function')}`,\n    'array:add_render_twice': () =>\n        `${arrayErrorPrefix} one rendered object was inserted twice.`,\n    'array:rendered_number_nodes': ({ length }) =>\n        `${arrayErrorPrefix} renderer returned ${length} nodes instead of one.`\n        + ` ${length > 0 ? 'To fix this wrap these nodes by single node.' : ''}`,\n    'array:renderer_node_missing': ({ selector }) =>\n        `${arrayErrorPrefix} renderer node is missing (given selector is \"${selector}\")`,\n    'array:nonexistent_method': ({ method }) =>\n            `${arrayErrorPrefix} Array.prototype.${method} doesn't exist.`\n            + ' You need to include a polyfill for it (e. g. babel-node)',\n    'array:method_compat_renderer': ({ method }) =>\n            `${arrayErrorPrefix} Not possible to render when ${method} method is called`,\n\n    'pull:to_remove_type': ({ toRemove }) =>\n        `Error in pull: ${getTypeError(toRemove, 'toRemove', 'number')}`,\n\n    'restore:no_nodes': () =>\n        `${arrayErrorPrefix} cannot find any container to restore an instance using \"restore\" method`,\n\n    'trigger:names_type': ({ names }) =>\n        `${eventsErrorPrefix} ${getTypeError(names, 'event name', 'string')}`,\n\n    'on:names_type': ({ names }) => errors['trigger:names_type']({ names }),\n\n    'removedatakeys:key_type': ({ key }) =>\n        `Error in removeDataKeys: ${getTypeError(key, 'key', 'string')}`,\n\n    'adddatakeys:key_type': ({ key }) =>\n        `Error in addDataKeys: ${getTypeError(key, 'key', 'string')}`,\n\n    'remove:key_type': ({ key }) =>\n        `Error in remove: ${getTypeError(key, 'key', 'string')}`,\n\n    'mediate:key_type': ({ key }) =>\n        `Error in mediate: ${getTypeError(key, 'key', 'string')}`\n};\n\nexport default function matreshkaError(key, data) {\n    const getError = errors[key];\n    if (!getError) {\n        throw Error(`Unknown error \"${key}\". Please report about this on Github.`);\n    }\n\n    return new Error(getError(data));\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/_helpers/matreshkaerror.js\n **/","// determines whether two values are the same value\n/* istanbul ignore next */\n// eslint-disable-next-line\nconst isPolyfill = (v1, v2) => v1 === 0 && v2 === 0 ? 1 / v1 === 1 / v2 : v1 !== v1 && v2 !== v2 || v1 === v2;\n\nexport default Object.is || isPolyfill;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/_helpers/is.js\n **/","// the regexp allows to parse things like \"click::x(.y)\"\n// it's shared between few modules\nexport default /([^::]+)::([^\\(\\)]+)?(?:\\((.*)\\))?/;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/on/_domeventregexp.js\n **/","import initMK from '../_core/init';\nimport defineProp from '../_core/defineprop';\nimport addListener from './_addlistener';\nimport dom from '../_dom';\nimport createDomEventHandler from './_createdomeventhandler';\n\n// returns an object with event handlers used at addDomListener\nfunction createBindingHandlers({\n    fullEventName,\n    domEventHandler,\n    selector\n}) {\n    return {\n        bindHandler(evt = {}) {\n            const { node } = evt;\n            if (node) {\n                dom.$(node).on(fullEventName, selector, domEventHandler);\n            }\n        },\n        unbindHandler(evt = {}) {\n            const { node } = evt;\n            if (node) {\n                dom.$(node).off(fullEventName, selector, domEventHandler);\n            }\n        }\n    };\n}\n\n// adds DOM event listener for nodes bound to given property\nexport default function addDomListener(object, key, eventName, selector, callback, context, info) {\n    const def = initMK(object);\n    const propDef = defineProp(object, key);\n\n    const domEventHandler = createDomEventHandler({\n        key,\n        object,\n        callback,\n        context: context || object\n    });\n\n    // making possible to remove this event listener\n    domEventHandler._callback = callback;\n\n    const eventNamespace = def.id + key;\n    const fullEventName = `${eventName}.${eventNamespace}`;\n    const { bindHandler, unbindHandler } = createBindingHandlers({\n        fullEventName,\n        domEventHandler,\n        selector\n    });\n    const addBindListenerResult\n        = addListener(object, `bind:${key}`, bindHandler, context, info);\n    const addUnbindListenerResult\n        = addListener(object, `unbind:${key}`, unbindHandler, context, info);\n\n    // if events are added successfully then run bindHandler for every node immediately\n    // TODO: Describe why do we need addBindListenerResult and addUnbindListenerResult\n    if (addBindListenerResult && addUnbindListenerResult) {\n        const { bindings } = propDef;\n        if (bindings) {\n            nofn.forEach(bindings, ({ node }) => bindHandler({ node }));\n        }\n    }\n\n    return object;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/on/_adddomlistener.js\n **/","import $ from './default-dollar';\n\nexport default { $ };\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/_dom/index.js\n **/","/* global $ */\nimport mq from './mq';\n\n// check existence of needed methods in $ global variable\n// to use it for internal needs\n\nconst neededMethods = ['on', 'off', 'add'];\n\nconst globalDollar = typeof $ === 'function' ? $ : null;\nlet useGlobalDollar = true;\n\n/* istanbul ignore if */\nif (globalDollar) {\n    const fn = globalDollar.fn || globalDollar.prototype;\n    for (let i = 0; i < neededMethods.length; i++) {\n        if (!fn[neededMethods[i]]) {\n            useGlobalDollar = false;\n            break;\n        }\n    }\n\n    if (!globalDollar.parseHTML) {\n        // Zepto doesn't include its own parseHTML\n        // TODO: Assignment of parseHTML is side effect\n        globalDollar.parseHTML = mq.parseHTML;\n    }\n} else {\n    useGlobalDollar = false;\n}\n\nexport default useGlobalDollar ? globalDollar : mq;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/_dom/default-dollar.js\n **/","import Init from './_init';\nimport parseHTML from './parsehtml';\nimport on from './on';\nimport off from './off';\nimport add from './add';\nimport assign from '../../_helpers/assign';\n\n// tiny jQuery replacement for Matreshka\n// mq previously called balalaika.js\nexport default function mq(selector, context) {\n    return new Init(selector, context);\n}\n\nmq.parseHTML = parseHTML;\n\nassign(Init.prototype, {\n    on,\n    off,\n    add\n});\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/_dom/mq/index.js\n **/","import html2nodeList from './_html2nodelist';\n\nconst win = window;\n\n// function-constructor of mq library\n// accepts many kinds of arguments (selector, html, function)\nfunction MQInit(selector, context) {\n    let result;\n\n    if (selector) {\n        if (selector.nodeType || (typeof win === 'object' && selector === win)) {\n            result = [selector];\n        } else if (typeof selector === 'string') {\n            if (/</.test(selector)) {\n                result = html2nodeList(selector);\n            } else if (context) {\n                const newContext = (new MQInit(context))[0];\n\n                if (newContext) {\n                    result = newContext.querySelectorAll(selector);\n                }\n            } else {\n                result = win.document.querySelectorAll(selector);\n            }\n        } else if ('length' in selector) {\n            // if it's something array-like (eg NodeList)\n            result = selector;\n        } else {\n            // this is somethong another (eg Attr)\n            result = [selector];\n        }\n    }\n\n    const length = result && result.length;\n\n    if (length) {\n        for (let i = 0; i < length; i++) {\n            this.push(result[i]);\n        }\n    }\n}\n\nMQInit.prototype = [];\n\nexport default MQInit;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/_dom/mq/_init.js\n **/","// converts HTML string to NodeList instance\nexport default function html2nodeList(givenHTML) {\n    // wrapMap is taken from jQuery\n    const wrapMap = {\n        option: [1, '<select multiple=\"multiple\">', '</select>'],\n        legend: [1, '<fieldset>', '</fieldset>'],\n        thead: [1, '<table>', '</table>'],\n        tr: [2, '<table><tbody>', '</tbody></table>'],\n        td: [3, '<table><tbody><tr>', '</tr></tbody></table>'],\n        col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],\n        area: [1, '<map>', '</map>'],\n        _: [0, '', '']\n    };\n\n    const html = givenHTML.replace(/^\\s+|\\s+$/g, '');\n    let node = window.document.createElement('div');\n    let i;\n\n    wrapMap.optgroup = wrapMap.option;\n    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\n    wrapMap.th = wrapMap.td;\n\n    const ex = /<([\\w:]+)/.exec(html);\n    const wrapper = (ex && wrapMap[ex[1]]) || wrapMap._;\n\n    node.innerHTML = wrapper[1] + html + wrapper[2];\n\n    i = wrapper[0];\n\n    while (i) {\n        i -= 1;\n        node = node.children[0];\n    }\n\n    return node.childNodes;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/_dom/mq/_html2nodelist.js\n **/","import html2nodeList from './_html2nodelist';\nimport Init from './_init';\n\n// parses given HTML and returns mq instance\nexport default function parseHTML(html) {\n    return new Init(html2nodeList(html));\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/_dom/mq/parsehtml.js\n **/","import data from './_data';\n\nconst splitBySpaceReg = /\\s+/;\nconst splitByDotReg = /\\.(.+)/;\n\n// checks an element against a selector\nfunction is(node, selector) {\n    return (node.matches\n            || node.webkitMatchesSelector\n            || node.mozMatchesSelector\n            || node.msMatchesSelector\n            || node.oMatchesSelector).call(node, selector);\n}\n\n// the function is used when a selector is given\nfunction delegateHandler(evt, selector, handler) {\n    const randomID = Math.random().toString().replace('0.', 'x');\n    const scopeSelector = `[${randomID}=\"${randomID}\"] `;\n    const splittedSelector = selector.split(',');\n\n    let matching = '';\n\n    for (let i = 0; i < splittedSelector.length; i++) {\n        const sel = splittedSelector[i];\n        matching += `${i === 0 ? '' : ','}${scopeSelector}${sel},${scopeSelector}${sel} *`;\n    }\n\n\n    this.setAttribute(randomID, randomID);\n\n    if (is(evt.target, matching)) {\n        handler.call(this, evt);\n    }\n\n    this.removeAttribute(randomID);\n}\n\n// adds event listener to a set of elemnts\nexport default function on(namesStr, selector, handler) {\n    const names = namesStr.split(splitBySpaceReg);\n    let delegate;\n\n    if (typeof selector === 'function') {\n        handler = selector; // eslint-disable-line no-param-reassign\n        selector = null; // eslint-disable-line no-param-reassign\n    }\n\n    if (selector) {\n        delegate = function uniqueDelegateHandler(evt) {\n            delegateHandler.call(this, evt, selector, handler);\n        };\n    }\n\n    for (let i = 0; i < names.length; i++) {\n        const [name, namespace] = names[i].split(splitByDotReg);\n\n        for (let j = 0; j < this.length; j++) {\n            const node = this[j];\n            const nodeID = node.b$ = node.b$ || ++data.nodeIndex; // eslint-disable-line no-plusplus\n            const events = data.allEvents[name + nodeID] = data.allEvents[name + nodeID] || [];\n\n            let exist = false;\n\n            for (let k = 0; k < events.length; k++) {\n                const event = events[k];\n\n                if (handler === event.handler && (!selector || selector === event.selector)) {\n                    exist = true;\n                    break;\n                }\n            }\n\n            if (!exist) {\n                events.push({\n                    delegate,\n                    handler,\n                    namespace,\n                    selector\n                });\n\n                node.addEventListener(name, delegate || handler, false);\n            }\n        }\n    }\n\n    return this;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/_dom/mq/on.js\n **/","// an object allows to share data between modules; it's needed because we use\n// simplified ES modules there and cannot import and share a number\nexport default {\n    nodeIndex: 0,\n    allEvents: {}\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/_dom/mq/_data.js\n **/","import data from './_data';\n\nconst splitBySpaceReg = /\\s+/;\nconst splitByDotReg = /\\.(.+)/;\n\n// removes event handler from a set of elements\nexport default function off(namesStr, selector, handler) {\n    if (typeof selector === 'function') {\n        handler = selector; // eslint-disable-line no-param-reassign\n        selector = null;  // eslint-disable-line no-param-reassign\n    }\n\n    const names = namesStr.split(splitBySpaceReg);\n\n    for (let i = 0; i < names.length; i++) {\n        const [name, namespace] = names[i].split(splitByDotReg);\n\n        for (let j = 0; j < this.length; j++) {\n            const node = this[j];\n            const events = data.allEvents[name + node.b$];\n\n            if (events) {\n                for (let k = 0; k < events.length; k++) {\n                    const event = events[k];\n                    if (\n                        (!handler || handler === event.handler || handler === event.delegate)\n                        && (!namespace || namespace === event.namespace)\n                        && (!selector || selector === event.selector)\n                    ) {\n                        node.removeEventListener(name, event.delegate || event.handler);\n                        events.splice(k, 1);\n                        k -= 1;\n                    }\n                }\n            } else if (!namespace && !selector) {\n                node.removeEventListener(name, handler);\n            }\n        }\n    }\n\n    return this;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/_dom/mq/off.js\n **/","import Init from './_init';\nimport data from './_data';\n\n// adds unique nodes to mq collection\nexport default function add(selector) {\n    const idMap = {};\n\n    let result;\n\n    const nodes = new Init(selector);\n\n    if (this.length) {\n        result = new Init();\n        for (let i = 0; i < this.length; i++) {\n            const node = this[i];\n            const nodeID = node.b$ = node.b$ || ++data.nodeIndex; // eslint-disable-line no-plusplus\n            idMap[nodeID] = 1;\n            result.push(node);\n        }\n\n        for (let i = 0; i < nodes.length; i++) {\n            const node = nodes[i];\n            const nodeID = node.b$ = node.b$ || ++data.nodeIndex; // eslint-disable-line no-plusplus\n            if (!idMap[nodeID]) {\n                idMap[nodeID] = 1;\n                result.push(node);\n            }\n        }\n    } else {\n        result = nodes;\n    }\n\n    return result;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/_dom/mq/add.js\n **/","// Object.assign polyfyll\n/* istanbul ignore next */\nconst assign = Object.assign || function assign(target) {\n    /* istanbul ignore next */\n    if (target === undefined || target === null) {\n        throw new TypeError('Cannot convert undefined or null to object');\n    }\n\n    const output = Object(target);\n\n    for (let index = 1; index < arguments.length; index++) {\n        const source = arguments[index];\n        if (source !== undefined && source !== null) {\n            nofn.forOwn(source, (nextValue, nextKey) => {\n                output[nextKey] = nextValue;\n            });\n        }\n    }\n\n    return output;\n};\n\nexport default assign;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/_helpers/assign.js\n **/","import apply from '../_helpers/apply';\n// returns DOM event handler\nexport default function createDomEventHandler({\n    key,\n    object,\n    callback,\n    context\n}) {\n    return function domEventHandler(domEvent) {\n        const originalEvent = domEvent.originalEvent || domEvent;\n        // matreshkaTriggerArgs are created when DOM event is triggered by trigger method\n        const triggerArgs = originalEvent.matreshkaTriggerArgs;\n        const { which, target, ctrlKey, altKey } = domEvent;\n\n        if (triggerArgs) {\n            // if args are passed to trigger method then pass them to an event handler\n            apply(callback, context, triggerArgs);\n        } else {\n            // use the following object as an arg for event handler\n            callback.call(context, {\n                self: object,\n                node: this,\n                preventDefault: () => domEvent.preventDefault(),\n                stopPropagation: () => domEvent.stopPropagation(),\n                key,\n                domEvent,\n                originalEvent,\n                which,\n                target,\n                ctrlKey,\n                altKey\n            });\n        }\n    };\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/on/_createdomeventhandler.js\n **/","import initMK from '../_core/init';\nimport defineProp from '../_core/defineprop';\nimport matreshkaError from '../_helpers/matreshkaerror';\nimport triggerOne from '../trigger/_triggerone';\n\n// adds keys to a list of data keys\nexport default function addDataKeys(givenKeys) {\n    const { keys } = initMK(this);\n\n    let newKeys;\n\n    // accept an array keys or a list of args\n    if (givenKeys instanceof Array) {\n        newKeys = givenKeys;\n    } else {\n        newKeys = arguments;\n    }\n\n    nofn.forEach(newKeys, (key) => {\n        if (typeof key !== 'string') {\n            throw matreshkaError('adddatakeys:key_type', { key });\n        }\n\n        // if key is not in a list of keys\n        if (!(key in keys)) {\n            // define descriptors for this property\n            const { value } = defineProp(this, key);\n            const eventOptions = { key, value };\n\n            // add a key to the list of keys\n            keys[key] = true;\n\n            // trigger events which say that data is changed\n            triggerOne(this, 'set', eventOptions);\n            triggerOne(this, 'modify', eventOptions);\n        }\n    });\n\n    return this;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/object/adddatakeys.js\n **/","import defs from '../_core/defs';\nimport triggerOne from '../trigger/_triggerone';\nimport matreshkaError from '../_helpers/matreshkaerror';\n\n// removes given keys from a list of data keys\nexport default function removeDataKeys(givenKeys) {\n    const def = defs.get(this);\n\n    /* istanbul ignore if */\n    if (!def) {\n        return this;\n    }\n\n    const { keys } = def;\n    let removedKeys;\n\n    // accept an array keys or a list of args\n    if (givenKeys instanceof Array) {\n        removedKeys = givenKeys;\n    } else {\n        removedKeys = arguments;\n    }\n\n    nofn.forEach(removedKeys, (key) => {\n        if (typeof key !== 'string') {\n            throw matreshkaError('removedatakeys:key_type', { key });\n        }\n\n        if (key in keys) {\n            const eventOptions = {\n                key,\n                value: this[key]\n            };\n\n            delete keys[key];\n\n            // fire \"modify\" and \"remove\" events\n            triggerOne(this, 'modify', eventOptions);\n            triggerOne(this, 'remove', eventOptions);\n        }\n    });\n\n    return this;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/object/removedatakeys.js\n **/","import defs from '../_core/defs';\n\n// checks is a key present in data keys list\nexport default function isDataKey(key) {\n    const def = defs.get(this);\n\n    /* istanbul ignore if */\n    if (!def) {\n        return false;\n    }\n\n    return key in def.keys;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/object/isdatakey.js\n **/","import initMK from '../_core/init';\nimport defineProp from '../_core/defineprop';\nimport set from '../set';\n\n// returns an array of keys listed at inObject but not listed at fromObject\nfunction getNotListedKeys(inObject, fromObject) {\n    const result = [];\n    nofn.forOwn(inObject, (_, key) => {\n        if (!(key in fromObject)) {\n            result.push(key);\n        }\n    });\n\n    return result;\n}\n\n// changes property value and adds given key to a list of data keys\nexport default function setData(key, value, eventOptions) {\n    // if no key or falsy key is given\n    if (!key) {\n        return this;\n    }\n\n    const { keys } = initMK(this);\n\n    // allow to pass key-value object\n    if (typeof key === 'object') {\n        eventOptions = value || {}; // eslint-disable-line no-param-reassign\n\n        const { replaceData } = eventOptions;\n\n        // do not call setData recursivally for better performance\n        nofn.forOwn(key, (objVal, objKey) => {\n            // remove data keys not listed at key-value object\n            if (replaceData) {\n                const notListedKeys = getNotListedKeys(keys, key);\n\n                if (notListedKeys.length) {\n                    this.removeDataKeys(notListedKeys);\n                }\n            }\n\n            // define descriptors for given property\n            defineProp(this, objKey);\n\n            // add a key to a list of keys\n            keys[objKey] = 1;\n\n            // do other things with set method\n            set(this, objKey, objVal, eventOptions);\n        });\n\n        return this;\n    }\n\n    eventOptions = eventOptions || {}; // eslint-disable-line no-param-reassign\n\n    const { replaceData } = eventOptions;\n\n    // remove all data keys except given key\n    if (replaceData) {\n        const notListedKeys = getNotListedKeys(keys, { [key]: true });\n\n        if (notListedKeys.length) {\n            this.removeDataKeys(notListedKeys);\n        }\n    }\n\n    // define descriptors for given property\n    defineProp(this, key);\n\n    // add a key to a list of keys\n    keys[key] = 1;\n\n    // do other things with set method\n    return set(this, key, value, eventOptions);\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/object/setdata.js\n **/","import defs from '../_core/defs';\n\n// iterates over data keys looking for a property with given value\n// and returns a key of found property\nexport default function keyOf(value) {\n    const def = defs.get(this);\n\n    /* istanbul ignore if */\n    if (!def) {\n        return null;\n    }\n\n    const keysArray = Object.keys(def.keys);\n\n    for (let i = 0; i < keysArray.length; i++) {\n        const key = keysArray[i];\n        if (this[key] === value) {\n            return key;\n        }\n    }\n\n    return null;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/object/keyof.js\n **/","import defs from '../_core/defs';\n\n// returns an array which contains all data keys\nexport default function keys() {\n    const def = defs.get(this);\n\n    /* istanbul ignore if */\n    if (!def) {\n        return [];\n    }\n\n    return Object.keys(def.keys);\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/object/keys.js\n **/","import defs from '../_core/defs';\n\n// returns an array which contains all data values\nexport default function keys() {\n    const def = defs.get(this);\n\n    /* istanbul ignore if */\n    if (!def) {\n        return [];\n    }\n\n    const keysArr = Object.keys(def.keys);\n    const { length } = keysArr;\n    const result = new Array(length);\n\n    for (let i = 0; i < keysArr.length; i++) {\n        result[i] = this[keysArr[i]];\n    }\n\n    return result;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/object/values.js\n **/","import defs from '../_core/defs';\n\n// returns an array which contains things like [key, value]\nexport default function keys() {\n    const def = defs.get(this);\n\n    /* istanbul ignore if */\n    if (!def) {\n        return [];\n    }\n\n    const keysArr = Object.keys(def.keys);\n    const { length } = keysArr;\n    const result = new Array(length);\n\n    for (let i = 0; i < keysArr.length; i++) {\n        const key = keysArr[i];\n        result[i] = [key, this[key]];\n    }\n\n    return result;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/object/entries.js\n **/","import initMK from '../_core/init';\n\n// converts Matreshka.Object instance to ordinary object\nexport default function toJSON(recursive = true) {\n    const { keys } = initMK(this);\n    const result = {};\n\n    nofn.forOwn(keys, (_, key) => {\n        const value = this[key];\n        // when recursive is true and when value has toJSON method then call it recusively\n        if (recursive && value && typeof value.toJSON === 'function') {\n            result[key] = value.toJSON(true);\n        } else {\n            result[key] = value;\n        }\n    });\n\n    return result;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/object/tojson.js\n **/","import defs from '../_core/defs';\n\n// iterates over data keys and calls callback on every iteration\n// @IE for..of is preferable and the method will be removed in one of major versions\nexport default function each(callback, thisArg) {\n    const def = defs.get(this);\n    const ctx = typeof thisArg !== 'undefined' ? thisArg : this;\n\n    /* istanbul ignore if */\n    if (!def) {\n        return this;\n    }\n\n    nofn.forOwn(def.keys, (_, key) => {\n        callback.call(ctx, this[key], key, this);\n    });\n\n    return this;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/object/each.js\n **/","// Symbol.iterator of Matreshka.Object instances\nexport default function matreshkaObjectIterator() {\n    const keys = this.keys();\n    let i = 0;\n\n    return {\n        next: () => {\n            if (i > keys.length - 1) {\n                return { done: true };\n            }\n\n            return {\n                done: false,\n                value: this[keys[i++]] // eslint-disable-line no-plusplus\n            };\n        }\n    };\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/object/iterator.js\n **/","import Class from '../class';\nimport Matreshka from '../matreshka';\nimport instanceMembers from './_prototype';\nimport matreshkaError from '../_helpers/matreshkaerror';\nimport initMK from '../_core/init';\nimport staticMembers from './_staticmembers';\n\ninstanceMembers.extends = Matreshka;\n\ninstanceMembers.constructor = function MatreshkaArray(length) {\n    if (!(this instanceof MatreshkaArray)) {\n        throw matreshkaError('common:call_class');\n    }\n\n    initMK(this);\n\n    // repeat the same logic as for native Array\n    if (arguments.length === 1 && typeof length === 'number') {\n        this.length = length;\n    } else if (arguments.length) {\n        this.recreate(arguments, {\n            silent: true,\n            dontRender: true\n        });\n    }\n\n    // return is used to make possible to chain super() calls\n    return this;\n};\n\nconst MatreshkaArray = Class(instanceMembers, staticMembers);\n\nexport default MatreshkaArray;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/array/index.js\n **/","import assign from '../_helpers/assign';\nimport _afterInit from './_afterinit';\nimport mediateItem from './mediateitem';\nimport orderBy from './orderby';\nimport pull from './pull';\nimport recreate from './recreate';\nimport rerender from './rerender';\nimport restore from './restore';\nimport toJSON from './tojson';\nimport pseudoNativeMethods from './_pseudonativemethods';\nimport iterator from './iterator';\n\nconst symbolIterator = typeof Symbol === 'function' ? Symbol.iterator : '@@iterator';\n\nexport default assign({\n    _afterInit,\n    mediateItem,\n    orderBy,\n    pull,\n    recreate,\n    rerender,\n    restore,\n    toJSON,\n    length: 0,\n    isMatreshkaArray: true,\n    [symbolIterator]: iterator\n}, pseudoNativeMethods);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/array/_prototype.js\n **/","import afterMatreshkaInit from '../matreshka/_afterinit';\nimport addListener from '../on/_addlistener';\nimport matreshkaError from '../_helpers/matreshkaerror';\n\n// the function returns array item converted to Model instance\nfunction modelItemMediator(item, index) {\n    const { Model } = this;\n\n    // if an item is already instance of Model\n    if (item instanceof Model) {\n        return item;\n    }\n\n    let itemData;\n\n    if (item && typeof item.toJSON === 'function') {\n        // if item is not falsy and if it has toJSON method\n        // then retrieve instance data by this method\n        itemData = item.toJSON(false);\n    } else {\n        // if not then use an item as its data\n        itemData = item;\n    }\n\n    return new Model(itemData, this, index);\n}\n\n// event handler to listen changes of Model property\nfunction changeModel() {\n    const { Model } = this;\n\n    // if model has wrong type then throw an error\n    if (typeof Model !== 'function') {\n        throw matreshkaError('array:model_type', { Model });\n    }\n\n    // attatch item mediator\n    this.mediateItem(modelItemMediator);\n}\n\n// event handler to listen changes of itemRenderer property\nfunction changeItemRendererHandler(eventOptions = {}) {\n    const { forceRerender = true } = eventOptions;\n    this.rerender({ forceRerender });\n}\n\n// Matreshka.Array initializer\nexport default function afterMatreshkaArrayInit() {\n    // we need to calculate hasModel before change:Model is added\n    const hasModel = 'Model' in this;\n\n    // call Matreshka initializer\n    afterMatreshkaInit.call(this);\n\n    addListener(this, '_change:common:Model', changeModel, this, {\n        skipChecks: true\n    });\n\n    addListener(this, '_change:common:itemRenderer', changeItemRendererHandler, this, {\n        skipChecks: true\n    });\n\n    // call changeModel handler immediately if model is present\n    // it will throw an error if Model is not a function\n    if (hasModel) {\n        changeModel.call(this);\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/array/_afterinit.js\n **/","import initMK from '../_core/init';\n\n// creates item mediator\nfunction createItemMediator({\n    arr,\n    mediator\n}) {\n    return function itemMediator(value, index) {\n        // args: value, old value, index, array itself\n        return mediator.call(arr, value, index, arr);\n    };\n}\n\n// defines a \"type\" of every array item\nexport default function mediateItem(mediator) {\n    const def = initMK(this);\n    const { length } = this;\n\n    // store itemMediator in object definition\n    const itemMediator = def.itemMediator = createItemMediator({\n        arr: this,\n        mediator\n    });\n\n    // convert existing items\n    for (let i = 0; i < length; i++) {\n        this[i] = itemMediator(this[i], i);\n    }\n\n    return this;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/array/mediateitem.js\n **/","import cheapRecreate from '../_cheaprecreate';\nimport pureOrderBy from './_pureorderby';\nimport reportModified from '../_reportmodified';\n\n// sorts by properties of items\nexport default function orderBy(keys, orders, eventOptions = {}) {\n    if (this.length > 1) {\n        cheapRecreate(this, pureOrderBy(this, keys, orders));\n\n        reportModified(this, {\n            method: 'sort', // makes possible to listen \"sort\" event\n            self: this,\n            added: [],\n            removed: [],\n            ...eventOptions\n        });\n    }\n\n    return this;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/array/orderby/index.js\n **/","// makes cheap array recreation (with no trackBy, with no events, with no item mediator etc)\nexport default function cheapRecreate(self, newItems = []) {\n    const newLength = newItems.length;\n    const oldLength = self.length;\n    const lengthDiff = newLength - oldLength;\n\n    for (let i = 0; i < newLength; i++) {\n        self[i] = newItems[i];\n    }\n\n    for (let i = 0; i < lengthDiff; i++) {\n        delete self[i + newLength];\n    }\n\n    self.length = newLength;\n\n    return self;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/array/_cheaprecreate.js\n **/","// the function orders by given order data any array-like object\nexport default function pureOrderBy(arr, givenKeys, orders) {\n    if ('length' in arr && typeof arr === 'object') {\n        const defaultOrder = 'asc';\n        let commonOrder;\n\n        if (!(orders instanceof Array)) {\n            commonOrder = orders || defaultOrder;\n        }\n\n        const { length } = arr;\n        const result = Array(length);\n\n        for (let i = 0; i < length; i++) {\n            result[i] = arr[i];\n        }\n\n        if (!givenKeys) {\n            return result;\n        }\n\n        const keys = givenKeys instanceof Array ? givenKeys : [givenKeys];\n\n        return result.sort((a, b) => {\n            if (a && b) {\n                for (let i = 0; i < keys.length; i++) {\n                    const key = keys[i];\n                    const order = (commonOrder || orders[i]) !== 'desc' ? -1 : 1;\n\n                    if (a[key] > b[key]) {\n                        return -order;\n                    } else if (a[key] < b[key]) {\n                        return order;\n                    }\n                }\n            }\n\n            return 0;\n        });\n    }\n\n    return [];\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/array/orderby/_pureorderby.js\n **/","import defs from '../_core/defs';\nimport triggerOne from '../trigger/_triggerone';\nimport processRendering from './_processrendering';\n\n// fires events and triggers rendering logic\nexport default function reportModified(self, eventOptions) {\n    const {\n        added,\n        removed,\n        silent,\n        method,\n        dontRender\n    } = eventOptions;\n    const addedLength = added.length;\n    const removedLength = removed.length;\n    const modified = addedLength || removedLength || method === 'sort' || method === 'reverse';\n    const { events } = defs.get(self);\n    const { renderIfPossible = true } = self;\n    const asteriskAddEvtName = '_asterisk:add';\n    const asteriskRemoveEvtName = '_asterisk:remove';\n\n    // if something is added and an array has delegated \"asterisk\" events\n    // then attatch delegated event handlers to newly added items\n    if (addedLength && events[asteriskAddEvtName]) {\n        triggerOne(self, asteriskAddEvtName, eventOptions);\n    }\n\n    // if something is removed and an array has delegated \"asterisk\" events\n    // then remove delegated event handlers from removed items\n    if (removedLength && events[asteriskRemoveEvtName]) {\n        triggerOne(self, asteriskRemoveEvtName, eventOptions);\n    }\n\n    if (!silent) {\n        // fire additional event name (like \"push\")\n        if (events[method]) {\n            triggerOne(self, method, eventOptions);\n        }\n\n        // if something is added then fire add and addone events\n        if (addedLength) {\n            if (events.add) {\n                triggerOne(self, 'add', eventOptions);\n            }\n\n            if (events.addone) {\n                for (let i = 0; i < addedLength; i++) {\n                    triggerOne(self, 'addone', {\n                        self,\n                        addedItem: added[i]\n                    });\n                }\n            }\n        }\n\n        // if something is removed then fire add and addone events\n        if (removedLength) {\n            if (events.remove) {\n                triggerOne(self, 'remove', eventOptions);\n            }\n\n            if (events.removeone) {\n                for (let i = 0; i < removedLength; i++) {\n                    triggerOne(self, 'removeone', {\n                        self,\n                        removedItem: removed[i]\n                    });\n                }\n            }\n        }\n\n        // modify event says that something is added or removed\n        if (events.modify) {\n            triggerOne(self, 'modify', eventOptions);\n        }\n    }\n\n    // trigger rendering logic if possible\n    if (modified && !dontRender && renderIfPossible) {\n        processRendering({\n            self,\n            eventOptions\n        });\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/array/_reportmodified.js\n **/","import defs from '../../_core/defs';\nimport matreshkaError from '../../_helpers/matreshkaerror';\nimport processPush from './processpush';\nimport processUnshift from './processunshift';\nimport processRecreate from './processrecreate';\nimport processSort from './processsort';\nimport processRemove from './processremove';\nimport processRerender from './processrerender';\nimport processSpliceAdd from './processspliceadd';\n\n// makes possible to render array items based on a name of called method\nexport default function processRendering({\n    self,\n    eventOptions\n}) {\n    const { method, added, removed } = eventOptions;\n    // nodes object always exist at Matreshka instances\n    const container = self.nodes.container || self.nodes.sandbox;\n    const selfDef = defs.get(self);\n\n    if (!container) {\n        return;\n    }\n\n    switch (method) {\n        case 'fill':\n        case 'copyWithin':\n            throw matreshkaError('array:method_compat_renderer', { method });\n        case 'push':\n            processPush({\n                self,\n                selfDef,\n                eventOptions,\n                container\n            });\n            break;\n        case 'unshift':\n            processUnshift({\n                self,\n                selfDef,\n                eventOptions,\n                container\n            });\n            break;\n        case 'pull':\n        case 'pop':\n        case 'shift':\n            processRemove({\n                self,\n                selfDef,\n                eventOptions,\n                container\n            });\n            break;\n        case 'sort':\n        case 'reverse':\n            processSort({\n                self,\n                selfDef,\n                eventOptions,\n                container\n            });\n            break;\n        case 'rerender':\n            processRerender({\n                self,\n                selfDef,\n                eventOptions,\n                container\n            });\n            break;\n        case 'recreate':\n            processRecreate({\n                self,\n                selfDef,\n                eventOptions,\n                container\n            });\n            break;\n        case 'splice':\n            if (added.length) {\n                processSpliceAdd({\n                    self,\n                    selfDef,\n                    eventOptions,\n                    container\n                });\n            }\n\n            if (removed.length) {\n                processRemove({\n                    self,\n                    selfDef,\n                    eventOptions,\n                    container\n                });\n            }\n\n            break;\n        default:\n            return;\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/array/_processrendering/index.js\n **/","import renderItemNode from './renderitemnode';\nimport triggerOne from '../../trigger/_triggerone';\nimport checkAlreadyRendered from './checkalreadyrendered';\n\n// this function renders inserted items if possible when push method is called\nexport default function processPush({\n    self,\n    selfDef,\n    eventOptions,\n    container\n}) {\n    const { added, silent } = eventOptions;\n\n    nofn.forEach(added, (item) => {\n        if (item && typeof item === 'object') {\n            // if a node of an item is already rendered then throw an error\n            checkAlreadyRendered({\n                item,\n                selfDef\n            });\n\n            // render\n            const { node, itemEventOptions } = renderItemNode({\n                selfDef,\n                self,\n                item,\n                eventOptions\n            });\n\n            if (node) {\n                container.appendChild(node);\n                if (!silent) {\n                    triggerOne(item, 'afterrender', itemEventOptions);\n                }\n            }\n        }\n    });\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/array/_processrendering/processpush.js\n **/","import parseBindings from '../../parsebindings';\nimport bindNode from '../../bindnode';\nimport unbindNode from '../../unbindnode';\nimport triggerOne from '../../trigger/_triggerone';\nimport initMK from '../../_core/init';\nimport matreshkaError from '../../_helpers/matreshkaerror';\nimport getNodes from '../../bindnode/_getnodes';\n\nconst htmlTestReg = /</;\n\n// the function makes the main rendering job\n// it renders given array item\nexport default function renderItemNode({\n    selfDef, // selfDef is passed as little optimization\n    self,\n    item,\n    eventOptions\n}) {\n    const { renderer, bindRenderedAsSandbox = true } = item;\n    const { itemRenderer } = self;\n    let usedRenderer = renderer || itemRenderer;\n    const rendererContext = usedRenderer === renderer ? item : self;\n    const { id: selfId } = selfDef;\n    const {\n        moveSandbox,\n        forceRerender,\n        silent\n    } = eventOptions;\n\n    // if renderer is not found return null as a node\n    if (!usedRenderer) {\n        return { node: null };\n    }\n\n    const itemDef = initMK(item);\n    const { renderedInArrays = {} } = itemDef;\n\n    // if moveSandbox option is truthy then return a sandbox of an item\n    if (moveSandbox) {\n        const sandboxPropDef = itemDef.props.sandbox;\n        if (sandboxPropDef) {\n            const { bindings } = sandboxPropDef;\n            const node = bindings ? bindings[0].node : null;\n\n            if (node) {\n                for (let i = 0, keys = Object.keys(renderedInArrays); i < keys.length; i++) {\n                    const key = keys[i];\n\n                    if (node === renderedInArrays[key]) {\n                        // delete an information about previous array\n                        delete renderedInArrays[key];\n                        break;\n                    }\n                }\n\n                renderedInArrays[selfId] = node;\n\n                // moving sandbox does not fire \"render\" event but it fire \"afterrender\"\n                // since \"afterrender\" means \"node is inserted to DOM\"\n                return {\n                    node,\n                    itemEventOptions: {\n                        node,\n                        self: item,\n                        parentArray: self\n                    }\n                };\n            }\n        }\n    }\n\n    itemDef.renderedInArrays = renderedInArrays;\n\n    // if usedRenderer is function then call it\n    if (typeof usedRenderer === 'function') {\n        usedRenderer = usedRenderer.call(rendererContext, item);\n    }\n\n\n    // if usedRenderer is string\n    if (typeof usedRenderer === 'string') {\n        if (!htmlTestReg.test(usedRenderer)) {\n            // if usedRenderer is a selector\n            const selector = usedRenderer;\n\n            usedRenderer = getNodes(self, selector);\n\n            if (usedRenderer.length) {\n                // if a node is found by given selector then use its HTML\n                usedRenderer = usedRenderer[0].innerHTML.trim();\n            } else {\n                // if not throw an error\n                throw matreshkaError('array:renderer_node_missing', { selector });\n            }\n        } else {\n            // if usedRenderer is HTML string\n            usedRenderer = usedRenderer.trim();\n        }\n    }\n\n    // pass a node or HTML\n    const parsed = parseBindings(item, usedRenderer, eventOptions);\n\n    // if parseBindings returned more/less than one node then throw an error\n    if (parsed.length !== 1) {\n        throw matreshkaError('array:rendered_number_nodes', { length: parsed.length });\n    }\n\n    const node = renderedInArrays[selfId] = parsed[0];\n\n    if (bindRenderedAsSandbox) {\n        if (forceRerender) {\n            unbindNode(item, 'sandbox', null, null, eventOptions);\n        }\n\n        bindNode(item, 'sandbox', node, null, eventOptions);\n    }\n\n    // if silent is not truthy then fire 'render' event and virtual methods\n    if (!silent) {\n        const itemEventOptions = {\n            node,\n            self: item,\n            parentArray: self\n        };\n        const { onRender } = item;\n        const { onItemRender } = self;\n\n        if (onRender) {\n            onRender.call(item, itemEventOptions);\n        }\n\n        if (onItemRender) {\n            onItemRender.call(self, item, itemEventOptions);\n        }\n\n        triggerOne(item, 'render', itemEventOptions);\n\n        return { node, itemEventOptions };\n    }\n\n    return { node };\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/array/_processrendering/renderitemnode.js\n **/","import checkObjectType from '../_helpers/checkobjecttype';\nimport dom from '../_dom';\nimport parserData from './_parserdata';\nimport processTextNode from './_processtextnode';\nimport processAttribute from './_processattribute';\nimport getNodes from '../bindnode/_getnodes';\n\n// makes parsing of given node (node, $(nodes), selector, HTML)\n// and initializes bindings for attributes and text nodes which contain things like {{foo}}\nexport default function parseBindings(object, givenNodes, eventOptions) {\n    if (typeof this === 'object' && this.isMatreshka) {\n        // when context is Matreshka instance, use this as an object and shift other args\n        /* eslint-disable no-param-reassign */\n        eventOptions = givenNodes;\n        givenNodes = object;\n        object = this;\n        /* eslint-enable no-param-reassign */\n    } else {\n        // throw error when object type is wrong\n        checkObjectType(object, 'parseBindings');\n    }\n\n    const extendedEventOptions = {\n        // useExactBinder is little optimization\n        // without this option used binder is extended by default binder\n        useExactBinder: true,\n        fromParser: true,\n        setValueOnBind: true\n    };\n\n    if (typeof eventOptions === 'object') {\n        nofn.assign(extendedEventOptions, eventOptions);\n    }\n\n    let nodes;\n    const allNodes = [];\n    // extract all needed data from parserData\n    // check out what is parserData in its module\n    const {\n        leftBracket,\n        bindingReg\n    } = parserData;\n\n    if (typeof givenNodes === 'string') {\n        if (~givenNodes.indexOf('<')) {\n            // this is HTML\n            nodes = dom.$.parseHTML(givenNodes);\n            if (!~givenNodes.indexOf(leftBracket)) {\n                // if it doesn't include parser bracket then we don't need to check\n                // their existence for all included nodes in cycle below\n                return nodes;\n            }\n        } else {\n            // this is a selector\n            nodes = getNodes(object, givenNodes);\n        }\n    } else if (typeof givenNodes === 'object') {\n        // this is a node, nodeList or something else (eg array, jQuery instance etc)\n        nodes = dom.$(givenNodes);\n    }\n\n    // to make possible to not use recursion we're collecting all nodes to allNodes array\n    nofn.forEach(nodes, node => allNodes.push(node));\n\n    // on every cycle of array we're adding new descendants to allNodes\n    // increasing # of needed iterations\n    for (let i = 0; i < allNodes.length; i++) {\n        const node = allNodes[i];\n        const ELEMENT_NODE = 1;\n        const TEXT_NODE = 3;\n\n        // allow to parse elements only\n        if (node.nodeType !== ELEMENT_NODE) {\n            continue;\n        }\n\n        const { outerHTML, innerHTML, childNodes, attributes } = node;\n\n        // if outerHTML does't contain left bracket, then this node doesn't need to be parsed\n        // we may need to check outerHTML existence for older browsers\n        // we may need to add !~outerHTML.indexOf(encodeURI(leftBracket) to support old FF\n        if (!~outerHTML.indexOf(leftBracket)) {\n            continue;\n        }\n\n        // initialize bindings for attributes if they appear\n        if (attributes.length) {\n            nofn.forEach(attributes, (attribute) => {\n                if (bindingReg.test(attribute.value)) {\n                    processAttribute({\n                        node,\n                        attribute,\n                        object,\n                        eventOptions: extendedEventOptions\n                    });\n                }\n            });\n        }\n\n        // if innerHTML does't contain left bracket,\n        // then children of this node don't need to be parsed\n        // we may need to add !~innerHTML.indexOf(encodeURI(leftBracket) to support old FF\n        if (!~innerHTML.indexOf(leftBracket)) {\n            continue;\n        }\n\n        for (let j = 0; j < childNodes.length; j++) {\n            const childNode = childNodes[j];\n            const { nodeType, textContent } = childNode;\n\n            if (nodeType === ELEMENT_NODE) {\n                // if childNode is HTML element then add it to the end of allNodes array\n                // to check everything on next outer cycle iterations\n                allNodes.push(childNode);\n            } else if (nodeType === TEXT_NODE) {\n                // if childNode is text node which contains things like {{x}}\n                // then initialize bindings for this node\n                if (bindingReg.test(textContent)) {\n                    processTextNode({\n                        object,\n                        node,\n                        textNode: childNode,\n                        eventOptions: extendedEventOptions\n                    });\n                }\n            }\n        }\n    }\n\n    return nodes;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/parsebindings/index.js\n **/","import calc from '../calc';\nimport parserBrackets from '../parserbrackets';\n\nconst parserData = {};\n\n// since Matreshka allows to change parser brackets via parserBrackets objects\n// the parser needs to generate required regular expressions and escaped brackets every time\n// when parseBindings is called\n// to optimize this behavior parserData object is created\n// it calculates needed data every time when parserBrackets are changed\n// and when parseBindings function is called it uses previously generated regeps\n// from parserData object\ncalc(parserData, {\n    leftBracket: {\n        source: {\n            object: parserBrackets,\n            key: 'left'\n        }\n    },\n    rightBracket: {\n        source: {\n            object: parserBrackets,\n            key: 'right'\n        }\n    },\n    escLeftBracket: {\n        source: 'leftBracket',\n        handler: left => left.replace(/(\\[|\\(|\\?)/g, '\\\\$1')\n    },\n    escRightBracket: {\n        source: 'rightBracket',\n        handler: right => right.replace(/(\\]|\\)|\\?)/g, '\\\\$1')\n    },\n    bindingReg: {\n        source: ['escLeftBracket', 'escRightBracket'],\n        handler: (left, right) => new RegExp(`${left}\\\\s*(.+?)\\\\s*${right}`, 'g')\n    },\n    strictBindingReg: {\n        source: ['escLeftBracket', 'escRightBracket'],\n        handler: (left, right) => new RegExp(`^${left}\\\\s*(.+?)\\\\s*${right}$`, 'g')\n    }\n}, {\n    debounceCalc: false // we need to get new regexps immediately when brackets are changed\n});\n\nexport default parserData;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/parsebindings/_parserdata.js\n **/","import initMK from '../_core/init';\nimport checkObjectType from '../_helpers/checkobjecttype';\nimport matreshkaError from '../_helpers/matreshkaerror';\nimport debounce from '../_helpers/debounce';\nimport addSource from './_addsource';\nimport createCalcHandler from './_createcalchandler';\nimport defineProp from '../_core/defineprop';\n\n// defines a property which is dependend on other properties\nexport default function calc(object, target, sources, givenHandler, eventOptions) {\n    if (typeof this === 'object' && this.isMatreshka) {\n        // when context is Matreshka instance, use this as an object and shift other args\n        /* eslint-disable no-param-reassign */\n        eventOptions = givenHandler;\n        givenHandler = sources;\n        sources = target;\n        target = object;\n        object = this;\n        /* eslint-enable no-param-reassign */\n    } else {\n        // throw error when object type is wrong\n        checkObjectType(object, 'calc');\n    }\n\n    if (target instanceof Object) {\n        /*\n         * accept an object\n         * this.calc({target: { source, handler, event } }, commonEventOptions);\n         */\n        nofn.forOwn(target, ({\n            source: itemSource,\n            handler: itemHandler,\n            event: itemEventOptions\n        }, itemTarget) => {\n            const commonEventOptions = sources;\n            const mergedEventOptions = {};\n\n            if (commonEventOptions) {\n                // extend event object by \"global\" event\n                nofn.assign(mergedEventOptions, commonEventOptions);\n            }\n\n            if (itemEventOptions) {\n                // extend event object by \"local\" event (\"event\" key of an object)\n                nofn.assign(mergedEventOptions, itemEventOptions);\n            }\n\n            calc(object, itemTarget, itemSource, itemHandler, mergedEventOptions);\n        });\n\n        return object;\n    }\n\n    if (typeof target !== 'string') {\n        throw matreshkaError('calc:target_type', { target });\n    }\n\n    eventOptions = eventOptions || {}; // eslint-disable-line no-param-reassign\n    const def = initMK(object);\n    const {\n        setOnInit = true,\n        debounceCalcOnInit = false,\n        debounceCalc = true,\n        debounceCalcDelay = 0,\n        // the next option is used to hide a property for internal use (eg in bindings parser)\n        // hidden property means no accessors\n        isTargetPropertyHidden = false\n    } = eventOptions;\n    const defaultHandler = value => value;\n    const handler = givenHandler || defaultHandler;\n    const allSources = [];\n    const syncCalcHandler = createCalcHandler({\n        object,\n        eventOptions,\n        allSources,\n        target,\n        def,\n        handler\n    });\n\n    let debouncedCalcHandler;\n    let calcHandler;\n\n    if (debounceCalcOnInit || debounceCalc) {\n        debouncedCalcHandler = debounce(syncCalcHandler, debounceCalcDelay);\n    }\n\n    defineProp(object, target, isTargetPropertyHidden);\n\n    if (!(sources instanceof Array)) {\n        sources = [sources]; // eslint-disable-line no-param-reassign\n    }\n\n    if (debounceCalc) {\n        calcHandler = debouncedCalcHandler;\n    } else {\n        calcHandler = syncCalcHandler;\n    }\n\n    nofn.forEach(sources, (source) => {\n        if (typeof source === 'string') {\n            // source object is current object\n            addSource({\n                calcHandler,\n                allSources,\n                sourceKey: source,\n                sourceObject: object,\n                eventOptions\n            });\n        } else {\n            // source object is external object\n            if (!source || typeof source !== 'object') {\n                throw matreshkaError('calc:source_type', { source });\n            }\n\n            const sourceKey = source.key;\n            const sourceObject = source.object;\n            if (sourceKey instanceof Array) {\n                // many keys are passed\n                nofn.forEach(sourceKey, (sourceKeyItem) => {\n                    addSource({\n                        calcHandler,\n                        allSources,\n                        sourceKey: sourceKeyItem,\n                        sourceObject,\n                        eventOptions\n                    });\n                });\n            } else {\n                // one key is passed\n                addSource({\n                    calcHandler,\n                    allSources,\n                    sourceKey,\n                    sourceObject,\n                    eventOptions\n                });\n            }\n        }\n    });\n\n    if (setOnInit) {\n        if (debounceCalcOnInit) {\n            debouncedCalcHandler();\n        } else {\n            syncCalcHandler();\n        }\n    }\n\n    return object;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/calc/index.js\n **/","import apply from './apply';\n\n// Returns a function, that, as long as it continues to be invoked, will not\n// be triggered. The function will be called after it stops being called for\n// N milliseconds.\n// (c) https://davidwalsh.name/javascript-debounce-function\n\nexport default function debounce(func, givenDelay, thisArg) {\n    let timeout;\n    let delay;\n    if (typeof givenDelay !== 'number') {\n        thisArg = givenDelay; // eslint-disable-line no-param-reassign\n        delay = 0;\n    } else {\n        delay = givenDelay || 0;\n    }\n\n    return function debounced() {\n        const args = arguments;\n        const callContext = thisArg || this;\n\n        clearTimeout(timeout);\n\n        timeout = setTimeout(() => apply(func, callContext, args), delay);\n    };\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/_helpers/debounce.js\n **/","import addListener from '../on/_addlistener';\nimport addTreeListener from '../on/_addtreelistener';\nimport matreshkaError from '../_helpers/matreshkaerror';\n\n// adds a source to a source list and adds needed event listener to a it\nexport default function addSource({\n    calcHandler,\n    allSources,\n    sourceKey,\n    sourceObject,\n    eventOptions\n}) {\n    let { exactKey = false } = eventOptions;\n    let isDelegated = false;\n\n    // source key must be a string\n    if (typeof sourceKey !== 'string') {\n        throw matreshkaError('calc:source_key_type', { sourceKey });\n    }\n\n    // source object must be an object\n    if (!sourceObject || typeof sourceObject !== 'object') {\n        throw matreshkaError('calc:source_object_type', { sourceObject });\n    }\n\n    if (!exactKey) {\n        const deepPath = sourceKey.split('.');\n\n        // if something like a.b.c is used as a key\n        if (deepPath.length > 1) {\n            isDelegated = true;\n            // TODO: Avoid collisions with bindings by using another event name\n            // ... instead of _change:tree:xxx\n            addTreeListener(sourceObject, deepPath, calcHandler);\n        } else {\n            exactKey = true;\n        }\n    }\n\n\n    if (exactKey) {\n        // normal handler\n        addListener(sourceObject, `_change:deps:${sourceKey}`, calcHandler);\n    }\n\n    allSources.push({\n        sourceKey,\n        sourceObject,\n        isDelegated\n    });\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/calc/_addsource.js\n **/","import delegateListener from './_delegatelistener';\nimport removeTreeListener from '../off/_removetreelistener';\n\n// creates tree listener\nfunction createTreeListener({ handler, restPath }) {\n    const newHandler = function treeListener(changeEvent) {\n        const extendedChangeEvent = {\n            restPath,\n            ...changeEvent\n        };\n        const { previousValue, value } = changeEvent;\n\n        // removes listener for all branches of the path on old object\n        if (previousValue && typeof previousValue === 'object') {\n            removeTreeListener(previousValue, restPath, handler);\n        }\n\n        // adds listener for all branches of \"restPath\" path on newly assigned object\n        if (value && typeof value === 'object') {\n            addTreeListener(value, restPath, handler);\n        }\n\n        // call original handler\n        handler.call(this, extendedChangeEvent);\n    };\n\n    newHandler._callback = handler;\n\n    return newHandler;\n}\n\n// listens changes for all branches of given path\n// TODO: Pass context to addTreeListener\n// one of the most hard functions to understand\nexport default function addTreeListener(object, deepPath, handler) {\n    if (typeof deepPath === 'string') {\n        deepPath = deepPath.split('.'); // eslint-disable-line no-param-reassign\n    }\n\n    // iterate over all keys and delegate listener for all objects of given branch\n    for (let i = 0; i < deepPath.length; i++) {\n        // TODO: Array.prototype.slice method is slow\n        const listenPath = deepPath.slice(0, i);\n        const restPath = deepPath.slice(i + 1);\n\n        delegateListener(\n            object,\n            listenPath,\n            `_change:tree:${deepPath[i]}`,\n            createTreeListener({\n                handler,\n                restPath\n            })\n        );\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/on/_addtreelistener.js\n **/","import addListener from '../_addlistener';\nimport defs from '../../_core/defs';\nimport arrayAddHandler from './arrayaddhandler';\nimport objectSetHandler from './objectsethandler';\nimport arrayRemoveHandler from './arrayremovehandler';\nimport objectRemoveHandler from './objectremovehandler';\nimport changeHandler from './changehandler';\n\n// adds delegated event listener to an object by given path\nexport default function delegateListener(object, givenPath, name, callback, context, info = {}) {\n    // if typeof path is string and path is not empty string then split it\n    let path = typeof givenPath === 'string' && givenPath !== '' ? givenPath.split('.') : givenPath;\n\n    if (!path || !path.length) {\n        // if no path then add simple listener\n        addListener(object, name, callback, context, info);\n    } else {\n        // else do all magic\n        const key = path[0];\n        let pathStr; // needed for undelegation\n\n        if (path.length > 1) {\n            path = nofn.slice(path, 1);\n            pathStr = path.join('.');\n        } else {\n            path = [];\n            pathStr = path[0] || '';\n        }\n\n        const delegatedData = {\n            path,\n            name,\n            callback,\n            context,\n            info,\n            object\n        };\n\n        if (key === '*') {\n            // handling asterisk events\n            // { skipChecks: true } allows to use same event name and event handler few times\n            if (object.isMatreshkaArray) {\n                // the event is triggered when something is added to an array\n                addListener(object, '_asterisk:add', arrayAddHandler, null, {\n                    delegatedData,\n                    pathStr,\n                    skipChecks: true\n                });\n\n                // the event is triggered when something is removed from an array\n                addListener(object, '_asterisk:remove', arrayRemoveHandler, null, {\n                    delegatedData,\n                    pathStr,\n                    skipChecks: true\n                });\n\n                // call handler manually to delegate listener for currently existing data props\n                arrayAddHandler({\n                    added: object\n                }, delegatedData);\n            } else if (object.isMatreshkaObject) {\n                const def = defs.get(object);\n\n                // the event is triggered when data prop is changed\n                addListener(object, '_asterisk:set', objectSetHandler, null, {\n                    delegatedData,\n                    pathStr,\n                    skipChecks: true\n                });\n\n                // the event is triggered when data prop is removed\n                addListener(object, '_asterisk:remove', objectRemoveHandler, null, {\n                    delegatedData,\n                    pathStr,\n                    skipChecks: true\n                });\n\n                // delegate listener for currently existing data props\n                nofn.forOwn(def.keys, (_, defKey) => {\n                    const item = object[defKey];\n                    if (item && typeof item === 'object') {\n                        delegateListener(item, path, name, callback, context, info);\n                    }\n                });\n            }\n        } else {\n            // handling non-asterisk delegated event\n\n            // the event is triggered by \"set\"\n            addListener(object, `_change:delegated:${key}`, changeHandler, null, {\n                delegatedData,\n                pathStr\n            });\n\n            // call handler manually\n            changeHandler({\n                value: object[key]\n            }, delegatedData);\n        }\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/on/_delegatelistener/index.js\n **/","import triggerOne from '../../trigger/_triggerone';\n\n// the function is called when something is added to an array\n// it delegates asterisk listener for newly added items\nexport default function arrayAddHandler({ added }, {\n    path,\n    name,\n    callback,\n    context,\n    info\n} = triggerOne.latestEvent.info.delegatedData) {\n    nofn.forEach(added, (item) => {\n        if (item && typeof item === 'object') {\n            const delegateListener = require('./'); // fixing circular ref\n\n            delegateListener(item, path, name, callback, context, info);\n        }\n    });\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/on/_delegatelistener/arrayaddhandler.js\n **/","import triggerOne from '../../trigger/_triggerone';\nimport defs from '../../_core/defs';\n\n// the function is called when data property is changed in Matreshka.Object\n// it delegates asterisk listener for new value\nexport default function objectSetHandler({ key }, {\n    path,\n    name,\n    callback,\n    context,\n    info,\n    object\n} = triggerOne.latestEvent.info.delegatedData) {\n    if (key) {\n        const item = object[key];\n\n        if (item && typeof item === 'object') {\n            const def = defs.get(object);\n            if (key in def.keys) {\n                const delegateListener = require('./'); // fixing circular ref\n\n                delegateListener(item, path, name, callback, context, info);\n            }\n        }\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/on/_delegatelistener/objectsethandler.js\n **/","import undelegateListener from '../../off/_undelegatelistener';\nimport triggerOne from '../../trigger/_triggerone';\n\n// the function is called when something is removed from an array\n// it undelegates asterisk listener from removed items\nexport default function arrayRemoveHandler({ removed }, {\n    path,\n    name,\n    callback,\n    context,\n    info\n} = triggerOne.latestEvent.info.delegatedData) {\n    if (removed && removed.length) {\n        nofn.forEach(removed, (item) => {\n            if (item && typeof item === 'object') {\n                undelegateListener(item, path, name, callback, context, info);\n            }\n        });\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/on/_delegatelistener/arrayremovehandler.js\n **/","import defs from '../_core/defs';\nimport removeListener from './_removelistener';\n\n// the function removes internally used events such as _asterisk:add\nfunction detatchDelegatedLogic({\n    delegatedEventName,\n    pathStr,\n    allEvents\n}) {\n    const retain = [];\n    const events = allEvents[delegatedEventName];\n\n    nofn.forEach(events, (event) => {\n        // pathStr is assigned to info in delegateListener\n        if (event.info.pathStr !== pathStr) {\n            retain.push(event);\n        }\n    });\n\n    if (retain.length) {\n        allEvents[delegatedEventName] = retain;\n    } else {\n        delete allEvents[delegatedEventName];\n    }\n}\n\n// removes delegated event listener from an object by given path\nexport default function undelegateListener(object, givenPath, name, callback, context, info = {}) {\n    const def = defs.get(object);\n\n    // if no definition do nothing\n    if (!def) {\n        return;\n    }\n\n    const { events: allEvents } = def;\n\n    let path = typeof givenPath === 'string' && givenPath !== '' ? givenPath.split('.') : givenPath;\n\n    if (!path || !path.length) {\n        // if no path then remove listener\n        removeListener(object, name, callback, context, info);\n    } else {\n        // else do all magic\n        const key = path[0];\n        let pathStr;\n\n        if (path.length > 1) {\n            path = nofn.slice(path, 1);\n            pathStr = path.join('.');\n        } else {\n            path = [];\n            pathStr = path[0] || '';\n        }\n\n        if (key === '*') {\n            // remove asterisk events\n            if (object.isMatreshkaArray) {\n                const delegatedAddEvtName = '_asterisk:add';\n                if (allEvents[delegatedAddEvtName]) {\n                    detatchDelegatedLogic({\n                        delegatedEventName: delegatedAddEvtName,\n                        pathStr,\n                        allEvents\n                    });\n                }\n\n                const delegatedRemoveEvtName = '_asterisk:remove';\n                if (allEvents[delegatedRemoveEvtName]) {\n                    detatchDelegatedLogic({\n                        delegatedEventName: delegatedRemoveEvtName,\n                        pathStr,\n                        allEvents\n                    });\n                }\n\n                // undelegate asterisk events for existing items\n                if (object.length) {\n                    nofn.forEach(object, (item) => {\n                        if (item && typeof item === 'object') {\n                            undelegateListener(item, path, name, callback, context, info);\n                        }\n                    });\n                }\n            } else if (object.isMatreshkaObject) {\n                const delegatedSetEvtName = '_asterisk:set';\n                if (allEvents[delegatedSetEvtName]) {\n                    detatchDelegatedLogic({\n                        delegatedEventName: delegatedSetEvtName,\n                        pathStr,\n                        allEvents\n                    });\n                }\n\n                const delegatedRemoveEvtName = '_asterisk:remove';\n                if (allEvents[delegatedRemoveEvtName]) {\n                    detatchDelegatedLogic({\n                        delegatedEventName: delegatedRemoveEvtName,\n                        pathStr,\n                        allEvents\n                    });\n                }\n\n                object.each((item) => {\n                    if (item && typeof item === 'object') {\n                        undelegateListener(item, path, name, callback, context, info);\n                    }\n                });\n            }\n        } else {\n            // remove non-asterisk delegated events\n\n            const delegatedChangeEvtName = `_change:delegated:${key}`;\n            if (allEvents[delegatedChangeEvtName]) {\n                detatchDelegatedLogic({\n                    delegatedEventName: delegatedChangeEvtName,\n                    pathStr,\n                    allEvents\n                });\n            }\n\n            if (typeof object[key] === 'object') {\n                undelegateListener(object[key], path, name, callback, context, info);\n            }\n        }\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/off/_undelegatelistener.js\n **/","import defs from '../_core/defs';\nimport triggerOne from '../trigger/_triggerone';\nimport domEventReg from '../on/_domeventregexp';\n\n// removes simple event listener from an object\nexport default function removeListener(object, name, callback, context, info) {\n    const def = defs.get(object);\n\n    // if no definition do nothing\n    if (!def) {\n        return false;\n    }\n\n    const { events: allEvents } = def;\n    const events = allEvents[name];\n    const retain = [];\n    const noTrigger = name ? name[0] === '_' : false;\n    const domEventExecResult = domEventReg.exec(name);\n\n    if (domEventExecResult) {\n        const [, eventName, key = 'sandbox', selector] = domEventExecResult;\n        // fixing circular reference issue\n        const removeDomListener = require('./_removedomlistener');\n\n        removeDomListener(object, key, eventName, selector, callback, context, info);\n\n        return true;\n    }\n\n    // if all events need to be removed\n    if (typeof name === 'undefined') {\n        if (!noTrigger) {\n            nofn.forOwn(allEvents, (allEventsItem, allEventsName) => {\n                nofn.forEach(allEventsItem, (event) => {\n                    const removeEventData = {\n                        allEventsName,\n                        callback: event.callback,\n                        context: event.context\n                    };\n\n                    triggerOne(object, `removeevent:${name}`, removeEventData);\n                    triggerOne(object, 'removeevent', removeEventData);\n                });\n            });\n        }\n\n        // restore default value of \"events\"\n        def.events = {};\n    } else if (events) {\n        // if events with given name are found\n        nofn.forEach(events, (event) => {\n            const argCallback = (callback && callback._callback) || callback;\n            const eventCallback = event.callback._callback || event.callback;\n\n            if ((argCallback && argCallback !== eventCallback)\n                || (context && context !== event.context)) {\n                // keep event\n                retain.push(event);\n            } else {\n                const removeEventData = {\n                    name,\n                    callback: event.callback,\n                    context: event.context\n                };\n\n                if (!noTrigger) {\n                    triggerOne(object, `removeevent:${name}`, removeEventData);\n                    triggerOne(object, 'removeevent', removeEventData);\n                }\n            }\n        });\n\n        if (retain.length) {\n            allEvents[name] = retain;\n        } else {\n            delete def.events[name];\n        }\n    }\n\n    return false;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/off/_removelistener.js\n **/","import defs from '../_core/defs';\nimport removeListener from './_removelistener';\nimport dom from '../_dom';\n\n// removes dom listener from nodes bound to given key\nexport default function removeDomListener(\n    object,\n    key,\n    eventName,\n    selector,\n    callback,\n    context,\n    info\n) {\n    const def = defs.get(object);\n\n    if (!def) {\n        return object;\n    }\n\n    const { props } = def;\n    const propDef = props[key];\n\n    if (!propDef) {\n        return object;\n    }\n\n    const { bindings } = propDef;\n\n    if (bindings) {\n        // collect bound nodes and remove DOM event listener\n        const nodes = Array(bindings.length);\n        const eventNamespace = def.id + key;\n\n        nofn.forEach(bindings, (binding, index) => {\n            nodes[index] = binding.node;\n        });\n\n        dom.$(nodes).off(`${eventName}.${eventNamespace}`, selector, callback);\n    }\n\n    // remove bind and unbind listeners from given key\n    removeListener(object, `bind:${key}`, callback, context, info);\n    removeListener(object, `unbind:${key}`, callback, context, info);\n\n    return object;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/off/_removedomlistener.js\n **/","import undelegateListener from '../../off/_undelegatelistener';\nimport triggerOne from '../../trigger/_triggerone';\n\n// the function is called when data property is removed from Matreshka.Object\n// it undelegates asterisk listener from removed object\nexport default function objectRemoveHandler({ value: item }, {\n    path,\n    name,\n    callback,\n    context,\n    info\n    // , object\n} = triggerOne.latestEvent.info.delegatedData) {\n    if (item && typeof item === 'object') {\n        undelegateListener(item, path, name, callback, context, info);\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/on/_delegatelistener/objectremovehandler.js\n **/","import undelegateListener from '../../off/_undelegatelistener';\nimport triggerOne from '../../trigger/_triggerone';\n\n// the function is called when some part of a path is changed\n// it delegates event listener for new branch of an object and undelegates it for old one\n// used for non-asterisk events\nexport default function changeHandler({\n    previousValue,\n    value\n}, {\n    path,\n    name,\n    callback,\n    context,\n    info\n} = triggerOne.latestEvent.info.delegatedData) {\n    if (value && typeof value === 'object') {\n        const delegateListener = require('./'); // fixing circular ref\n\n        delegateListener(value, path, name, callback, context, info);\n    }\n\n    if (previousValue && typeof previousValue === 'object') {\n        undelegateListener(previousValue, path, name, callback, context, info);\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/on/_delegatelistener/changehandler.js\n **/","import undelegateListener from './_undelegatelistener';\n\n// removes tree listener from all object tree of fiven path\n// TODO: Pass context to removeTreeListener\nexport default function removeTreeListener(object, deepPath, handler) {\n    if (typeof deepPath === 'string') {\n        deepPath = deepPath.split('.'); // eslint-disable-line no-param-reassign\n    }\n\n    // iterate over keys of the path and undelegate given handler (can be undefined)\n    for (let i = 0; i < deepPath.length; i++) {\n        // TODO: Array.prototype.slice is slow\n        const listenedPath = deepPath.slice(0, i);\n\n        undelegateListener(\n            object,\n            listenedPath,\n            `_change:tree:${deepPath[i]}`,\n            handler\n        );\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/off/_removetreelistener.js\n **/","import set from '../set';\nimport deepFind from '../_helpers/deepfind';\nimport apply from '../_helpers/apply';\n\n// creates event handler for target object which will be fired when a source is changed\nexport default function createCalcHandler({\n    object,\n    eventOptions,\n    allSources,\n    target,\n    def,\n    handler\n}) {\n    return function calcHandler(changeEvent = {}) {\n        const values = [];\n        const { protector = {} } = changeEvent;\n        const protectKey = target + def.id;\n        const setEventOptions = {\n            protector,\n            ...eventOptions,\n            ...changeEvent\n        };\n\n        if (protectKey in protector) {\n            return;\n        }\n\n        protector[protectKey] = true;\n\n        nofn.forEach(allSources, ({\n            sourceObject,\n            sourceKey,\n            isDelegated\n        }) => {\n            const value = isDelegated ? deepFind(sourceObject, sourceKey) : sourceObject[sourceKey];\n            values.push(value);\n        });\n\n        const targetValue = apply(handler, object, values);\n        set(object, target, targetValue, setEventOptions);\n    };\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/calc/_createcalchandler.js\n **/","// gets value of a property in nested object\n// eg \"d\" from a.b.c.d\nexport default function deepFind(obj, givenPath) {\n    const paths = typeof givenPath === 'string' ? givenPath.split('.') : givenPath;\n    let current = obj;\n\n    for (let i = 0; i < paths.length; ++i) {\n        if (typeof current[paths[i]] === 'undefined') {\n            return undefined;\n        }\n\n        current = current[paths[i]];\n    }\n\n    return current;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/_helpers/deepfind.js\n **/","import parserData from './_parserdata';\nimport bindNode from '../bindnode';\n\nconst textNodeBinder = {\n    setValue(value) {\n        this.textContent = typeof value === 'undefined' ? '' : value;\n    }\n};\n\n// adds binding for text node\n// it splits up one text node into \"simple text nodes\"\n// and \"bound text nodes\" and removes original text node\nexport default function processTextNode({\n    object,\n    node,\n    textNode,\n    eventOptions\n}) {\n    const { bindingReg } = parserData;\n    const { textContent } = textNode;\n    const { document } = window;\n\n    bindingReg.lastIndex = 0;\n\n    // tokens variable contains normal text as odd items\n    // and bound keys as even items\n    // 'foo{{x}}bar{{y}}baz{{z}}' -> ['foo', 'x', 'bar', 'y', 'baz', 'z', '']\n    const tokens = textContent.split(bindingReg);\n\n    // fragment contains all new text nodes\n    const fragment = document.createDocumentFragment();\n\n    nofn.forEach(tokens, (token, index) => {\n        if (token) {\n            const newTextNode = document.createTextNode(token);\n            fragment.appendChild(newTextNode);\n\n            // if tokens item is even then it is a key\n            // which needs to be bound to newly created text node\n            if (index % 2 !== 0) {\n                bindNode(object, token, newTextNode, textNodeBinder, eventOptions);\n            }\n        }\n    });\n\n    node.insertBefore(fragment, textNode);\n    node.removeChild(textNode);\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/parsebindings/_processtextnode.js\n **/","import initMK from '../_core/init';\nimport defineProp from '../_core/defineprop';\nimport getNodes from './_getnodes';\nimport createBindingSwitcher from './_createbindingswitcher';\nimport bindSingleNode from './_bindsinglenode';\nimport checkObjectType from '../_helpers/checkobjecttype';\nimport matreshkaError from '../_helpers/matreshkaerror';\nimport addTreeListener from '../on/_addtreelistener';\n\n// initializes binsing between a property of an object to HTML node\nexport default function bindNode(object, key, node, binder, eventOptions) {\n    if (typeof this === 'object' && this.isMatreshka) {\n        // when context is Matreshka instance, use this as an object and shift other args\n        /* eslint-disable no-param-reassign */\n        eventOptions = binder;\n        binder = node;\n        node = key;\n        key = object;\n        object = this;\n        /* eslint-enable no-param-reassign */\n    } else {\n        // throw error when object type is wrong\n        checkObjectType(object, 'bindNode');\n    }\n\n    eventOptions = eventOptions || {}; // eslint-disable-line no-param-reassign\n    binder = binder || {}; // eslint-disable-line no-param-reassign\n\n    initMK(object);\n\n    const { temporaryOptionalFlag } = bindNode;\n\n    delete bindNode.temporaryOptionalFlag;\n\n    // throw an error when key is falsy\n    if (!key) {\n        throw matreshkaError('binding:falsy_key');\n    }\n\n    if (key instanceof Array) {\n        if (typeof key[0] === 'string') {\n            /*\n             * accept array of keys\n             * this.bindNode(['a', 'b', 'c'], node)\n             */\n            if (temporaryOptionalFlag) {\n                // eslint-disable-next-line no-param-reassign\n                eventOptions = { ...eventOptions, optional: true };\n            }\n\n            nofn.forEach(key, itemKey => bindNode(object, itemKey, node, binder, eventOptions));\n        } else {\n            /*\n             * accept array of objects\n             * this.bindNode([{key, node, binder, event}], { silent: true });\n             */\n            nofn.forEach(key, ({\n                key: itemKey,\n                node: itemNode,\n                binder: itemBinder,\n                event: itemEventOptions\n            }) => {\n                const commonEventOptions = node;\n                const mergedEventOptions = {};\n\n                if (temporaryOptionalFlag) {\n                    mergedEventOptions.optional = true;\n                }\n\n                if (commonEventOptions) {\n                    // extend event object by \"global\" event\n                    nofn.assign(mergedEventOptions, commonEventOptions);\n                }\n\n                if (itemEventOptions) {\n                    // extend event object by \"local\" event (\"event\" key of an object)\n                    nofn.assign(mergedEventOptions, itemEventOptions);\n                }\n\n                bindNode(object, itemKey, itemNode, itemBinder, mergedEventOptions);\n            });\n        }\n\n        return object;\n    }\n\n\n    if (typeof key === 'object') {\n        nofn.forOwn(key, (keyObjValue, keyObjKey) => {\n            // binder means eventOptions\n            if (temporaryOptionalFlag) {\n                // eslint-disable-next-line no-param-reassign\n                eventOptions = binder ? { ...binder, optional: true } : { optional: true };\n            } else {\n                eventOptions = binder; // eslint-disable-line no-param-reassign\n            }\n\n            if (\n                keyObjValue\n                && keyObjValue.constructor === Object\n                && 'node' in keyObjValue\n            ) {\n                // this.bindNode({ key: { node: $(), binder } ) }, { on: 'evt' }, { silent: true });\n                bindNode(object, keyObjKey, keyObjValue.node,\n                    keyObjValue.binder || node, eventOptions);\n            } else if (\n                keyObjValue\n                && keyObjValue.constructor === Array\n                && keyObjValue.length\n                && keyObjValue[0].constructor === Object\n                && 'node' in keyObjValue[0]\n            ) {\n                // this.bindNode({ key: [{\n                //   node: $(),\n                //   binder\n                // }] ) }, { on: 'evt' }, { silent: true });\n                nofn.forEach(keyObjValue, (keyObjValueItem) => {\n                    bindNode(object, keyObjKey, keyObjValueItem.node,\n                            keyObjValueItem.binder || node, eventOptions);\n                });\n            } else {\n                // this.bindNode({ key: $() }, { on: 'evt' }, { silent: true });\n                bindNode(object, keyObjKey, keyObjValue, node, eventOptions);\n            }\n        });\n\n        return object;\n    }\n\n    const {\n        optional = temporaryOptionalFlag || false, // check out bindOptionalNode\n        exactKey = false\n    } = eventOptions;\n    const $nodes = getNodes(object, node);\n\n    // check node existence\n    if (!$nodes.length) {\n        if (optional) {\n            return object;\n        }\n\n        throw matreshkaError('binding:node_missing', { key, node });\n    }\n\n    if (!exactKey) {\n        const deepPath = key.split('.');\n        const deepPathLength = deepPath.length;\n\n        if (deepPathLength > 1) {\n            // handle binding when key arg includes dots (eg \"a.b.c.d\")\n            const bindingSwitcher = createBindingSwitcher({\n                object,\n                deepPath,\n                $nodes,\n                binder,\n                eventOptions,\n                bindNode\n            });\n\n            addTreeListener(object, deepPath.slice(0, deepPathLength - 1), bindingSwitcher);\n\n            bindingSwitcher();\n\n            return object;\n        }\n    }\n\n    const propDef = defineProp(object, key);\n\n    if (object.isMatreshka) {\n        // if an object is Matreshka instance then extend \"$nodes\" and \"nodes\" objects\n        const { $nodes: $allNodes, nodes: allNodes } = object;\n\n        if (!$allNodes || !allNodes) {\n            throw matreshkaError('binding:instance_nodes_missing', {\n                $nodes: $allNodes,\n                nodes: allNodes\n            });\n        }\n\n        $allNodes[key] = $allNodes[key] && $allNodes[key].length\n            ? $allNodes[key].add($nodes)\n            : $nodes;\n\n        allNodes[key] = $allNodes[key][0];\n    }\n\n    // handle binding for every node separately\n    nofn.forEach($nodes, oneNode => bindSingleNode(object, {\n        $nodes,\n        node: oneNode,\n        key,\n        eventOptions,\n        binder,\n        propDef\n    }));\n\n    return object;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/bindnode/index.js\n **/","import selectNodes from './_selectnodes';\nimport dom from '../_dom';\n\nconst htmlReg = /</;\nconst customSelectorReg = /:sandbox|:bound\\(([^(]*)\\)/;\n\n// the function works just like DOM library accepting any kind of arg\n// (HTML string, Node, NodeList etc) bu allows to pass custom selector\n// eg :bound(KEY) and :sandbox\nexport default function getNodes(object, selector) {\n    let nodes;\n\n    if (\n        typeof selector === 'string'\n        && !htmlReg.test(selector)\n        && customSelectorReg.test(selector)\n    ) {\n        nodes = selectNodes(object, selector);\n    } else {\n        nodes = dom.$(selector);\n    }\n\n    return nodes;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/bindnode/_getnodes.js\n **/","import defs from '../_core/defs';\nimport toArray from '../_helpers/toarray';\nimport dom from '../_dom';\n\nconst customSelectorReg = /\\s*:bound\\(([^(]*)\\)\\s*([\\S\\s]*)\\s*|\\s*:sandbox\\s*([\\S\\s]*)\\s*/;\n\n// the function selects nodes based on a selector (including custom values, eg :sandbox)\n// TODO: selectNodes looks not good, it needs to be refactored and accelerated if possible\nexport default function selectNodes(object, givenSelector) {\n    const { props } = defs.get(object);\n    const selectors = givenSelector.split(',');\n    let result = dom.$();\n\n    nofn.forEach(selectors, (selector) => {\n        const execResult = customSelectorReg.exec(selector);\n        if (execResult) {\n            const boundKey = execResult[3] !== undefined ? 'sandbox' : execResult[1];\n            const subSelector = execResult[3] !== undefined ? execResult[3] : execResult[2];\n            const propDef = props[boundKey];\n\n            if (propDef) {\n                const { bindings } = propDef;\n                if (bindings) {\n                    const boundNodes = Array(bindings.length);\n                    nofn.forEach(bindings, (binding, i) => {\n                        boundNodes[i] = binding.node;\n                    });\n\n                    // if native selector passed after :bound(KEY) is not empty string\n                    // for example \":bound(KEY) .my-selector\"\n                    if (subSelector) {\n                        // if native selector contains children selector\n                        // for example \":bound(KEY) > .my-selector\"\n                        if (subSelector.indexOf('>') === 0) {\n                            // selecting children\n                            nofn.forEach(boundNodes, (node) => {\n                                const randomAttr = `m${Math.random()}`.replace('.', '');\n\n                                node.setAttribute(randomAttr, randomAttr);\n                                const selected = node.querySelectorAll(\n                                    `[${randomAttr}=\"${randomAttr}\"] ${subSelector}`\n                                );\n                                result = result.add(toArray(selected));\n                                node.removeAttribute(randomAttr);\n                            });\n                        } else {\n                            // if native selector doesn't contain children selector\n                            nofn.forEach(boundNodes, (node) => {\n                                const selected = node.querySelectorAll(subSelector);\n                                result = result.add(toArray(selected));\n                            });\n                        }\n                    } else {\n                        // if native selector is empty string just add bound nodes to result\n                        result = result.add(boundNodes);\n                    }\n                }\n            }\n        } else {\n            // if it's native selector (no custom things)\n            result = result.add(selector);\n        }\n    });\n\n    return result;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/bindnode/_selectnodes.js\n **/","// cheap conversion of an array-like object to Array instance\nexport default function toArray(object, start = 0) {\n    const { length } = object;\n    const array = Array(length);\n\n    for (let i = start; i < length; i++) {\n        array[i - start] = object[i];\n    }\n\n    return array;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/_helpers/toarray.js\n **/","import unbindNode from '../unbindnode';\n\n// returns a function which re-adds binding when object branch is changed\n// the function is called by bindNode when something like\n// 'foo.bar.baz' is passed to it as key argument value\n// this is one of the hardest things in the framework to understand\nexport default function createBindingSwitcher({\n    object,\n    deepPath,\n    $nodes,\n    binder,\n    eventOptions,\n    bindNode\n}) {\n    return function bindingSwitcher(changeEvent = {}) {\n        const deepPathLength = deepPath.length;\n        const lastDeepPathItem = deepPath[deepPathLength - 1];\n        const {\n            value, // new value of a branch\n            previousValue, // previous value of a branch\n            restPath // path starting currently changed branch (passed by addTreeListener)\n        } = changeEvent;\n        let target; // an object to call bindNode\n        let previousTarget; // an object to call unbindNode\n\n\n        if (value && typeof value === 'object' && restPath) {\n            // if rest path is given and new value is an object\n            target = value;\n            for (let i = 0; i < restPath.length; i++) {\n                target = target[restPath[i]];\n                if (!target) {\n                    break;\n                }\n            }\n        } else {\n            // if rest path is not given\n            target = object;\n            for (let i = 0; i < deepPathLength - 1; i++) {\n                target = target[deepPath[i]];\n                if (!target) {\n                    break;\n                }\n            }\n        }\n\n        // if rest path is given and previous value is an object\n        if (previousValue && typeof previousValue === 'object' && restPath) {\n            previousTarget = previousValue;\n            for (let i = 0; i < restPath.length; i++) {\n                previousTarget = previousTarget[restPath[i]];\n                if (!previousTarget) {\n                    break;\n                }\n            }\n        }\n\n        // add binding for new target\n        if (target && typeof target === 'object') {\n            bindNode(target, lastDeepPathItem, $nodes, binder, eventOptions);\n        }\n\n        // remove binding for previously used object\n        if (previousTarget && typeof previousTarget === 'object') {\n            unbindNode(previousTarget, lastDeepPathItem, $nodes);\n        }\n    };\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/bindnode/_createbindingswitcher.js\n **/","import checkObjectType from '../_helpers/checkobjecttype';\nimport defs from '../_core/defs';\nimport getNodes from '../bindnode/_getnodes';\nimport removeTreeListener from '../off/_removetreelistener';\nimport removeBinding from './_removebinding';\nimport dom from '../_dom';\n\n// unbinds a node\nexport default function unbindNode(object, key, node, eventOptions) {\n    if (typeof this === 'object' && this.isMatreshka) {\n        // when context is Matreshka instance, use this as an object and shift other args\n        /* eslint-disable no-param-reassign */\n        eventOptions = node;\n        node = key;\n        key = object;\n        object = this;\n        /* eslint-enable no-param-reassign */\n    } else {\n        // throw error when object type is wrong\n        checkObjectType(object, 'unbindNode');\n    }\n\n    if (key instanceof Array) {\n        if (typeof key[0] === 'string') {\n            /*\n             * accept array of keys\n             * this.unbindNode(['a', 'b', 'c'], node)\n             */\n\n            nofn.forEach(key, itemKey => unbindNode(object, itemKey, node, eventOptions));\n        } else {\n            /*\n             * acept array of objects\n             * this.unbindNode([{ key, node, binder, event }], { silent: true });\n             */\n            nofn.forEach(key, ({\n                key: itemKey,\n                node: itemNode,\n                event: itemEventOptions\n            }) => {\n                const commonEventOptions = node;\n                const mergedEventOptions = {};\n\n                if (commonEventOptions) {\n                    // extend event object by \"global\" event\n                    nofn.assign(mergedEventOptions, commonEventOptions);\n                }\n\n                if (itemEventOptions) {\n                    // extend event object by \"local\" event (\"event\" key of an object)\n                    nofn.assign(mergedEventOptions, itemEventOptions);\n                }\n\n                unbindNode(object, itemKey, itemNode, mergedEventOptions);\n            });\n        }\n\n        return object;\n    }\n\n    if (key && typeof key === 'object') {\n        nofn.forOwn(key, (keyObjValue, keyObjKey) => {\n            if (keyObjValue.constructor === Object && 'node' in keyObjValue) {\n                // this.unbindNode({ key: { node: $(), binder } ) }, { silent: true });\n                unbindNode(object, keyObjKey, keyObjValue.node, node);\n            } else if (\n                keyObjValue.constructor === Array\n                && keyObjValue.length\n                && keyObjValue[0].constructor === Object\n                && 'node' in keyObjValue[0]\n            ) {\n                // this.unbindNode({ key: [{ node: $(), binder }] ) }, { silent: true });\n                nofn.forEach(keyObjValue, (keyObjValueItem) => {\n                    unbindNode(object, keyObjKey, keyObjValueItem.node, node);\n                });\n            } else {\n                // this.unbindNode({ key: $() }, { silent: true });\n                unbindNode(object, keyObjKey, keyObjValue, node);\n            }\n        });\n        return object;\n    }\n\n    eventOptions = eventOptions || {}; // eslint-disable-line no-param-reassign\n    const { deep } = eventOptions;\n    const def = defs.get(object);\n\n    if (!def) {\n        return object;\n    }\n\n    const { props } = def;\n\n    // allow to pass null or undefined as key\n    // if passed then remove bindings of all keys for given object\n    if (key === null || typeof key === 'undefined') {\n        nofn.forOwn(props, (propsItem, propsKey) => {\n            unbindNode(object, propsKey, null, eventOptions);\n        });\n\n        return object;\n    }\n\n    // remove delegated binding\n    if (deep !== false) {\n        const deepPath = key.split('.');\n        const deepPathLength = deepPath.length;\n\n        if (deepPathLength > 1) {\n            let target = object;\n\n            for (let i = 0; i < deepPathLength - 1; i++) {\n                // TODO: Do we need to throw an error when a target is falsy?\n                target = target[deepPath[i]];\n            }\n\n            // TODO: Potential bug! This may undelegate listener for all bindings with the same path\n            // ...(cannot reproduce)\n            removeTreeListener(object, deepPath.slice(0, deepPathLength - 2));\n\n            unbindNode(target, deepPath[deepPathLength - 1], node, eventOptions);\n\n            return object;\n        }\n    }\n\n    const propDef = props[key];\n\n    // when no propdef do nothing\n    if (!propDef) {\n        return object;\n    }\n\n    const { bindings } = propDef;\n\n    // if the property doesn't have any bindings do nothing\n    if (!bindings) {\n        return object;\n    }\n\n    // if no node is pased remove all bindings for given key\n    if (!node) {\n        nofn.forEach(bindings, (binding) => {\n            removeBinding({ object, key, eventOptions, binding });\n        });\n\n        propDef.bindings = null;\n\n        // update nodes and $nodes for Matreshka instance\n        if (object.isMatreshka) {\n            delete object.nodes[key];\n            delete object.$nodes[key];\n        }\n\n        return object;\n    }\n\n    const $nodes = getNodes(object, node);\n    const retainBindings = [];\n    const retainNodes = [];\n\n    // iterate over all bindngs and compare their node with given nodes\n    nofn.forEach($nodes, (nodesItem) => {\n        nofn.forEach(bindings, (binding) => {\n            if (binding.node === nodesItem) {\n                removeBinding({ object, key, eventOptions, binding });\n            } else {\n                retainBindings.push(binding);\n                retainNodes.push(nodesItem);\n            }\n        });\n    });\n\n    // update nodes and $nodes for Matreshka instance\n    if (object.isMatreshka) {\n        if (retainNodes.length) {\n            object.nodes[key] = retainNodes[0];\n            object.$nodes[key] = dom.$(retainNodes);\n        } else {\n            delete object.nodes[key];\n            delete object.$nodes[key];\n        }\n    }\n\n    // update bindings object\n    if (retainBindings.length) {\n        propDef.bindings = retainBindings;\n    } else {\n        propDef.bindings = null;\n    }\n\n    return object;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/unbindnode/index.js\n **/","import removeListener from '../off/_removelistener';\nimport triggerOne from '../trigger/_triggerone';\n\nconst spaceReg = /\\s+/;\n\n// the function removes single binding for single object\n// called by unbindNode\nexport default function removeBinding({\n    object,\n    key,\n    eventOptions,\n    binding\n}) {\n    const {\n        bindingOptions,\n        binder,\n        node,\n        nodeHandler,\n        objectHandler\n    } = binding;\n    const { destroy, on } = binder;\n    const { silent } = eventOptions;\n\n    // if \"on\" is a function then disable it\n    // we cannot \"turn off\" custom listener defined by a programmer\n    // programmer needs to remove custom listener maually inside binder.destroy\n    if (typeof on === 'function') {\n        nodeHandler.disabled = true;\n    } else if (typeof on === 'string') {\n        // remove DOM event listener\n        // removeEventListener is faster than \"on\" method from any DOM library\n        nofn.forEach(on.split(spaceReg),\n            evtName => node.removeEventListener(evtName, nodeHandler));\n    }\n\n    // remove object event listener\n    removeListener(object, `_change:bindings:${key}`, objectHandler);\n\n    // if binder.destroy is given call it\n    if (destroy) {\n        destroy.call(node, bindingOptions);\n    }\n\n    // fire events\n    if (!silent) {\n        const extendedEventOptions = {\n            key,\n            node,\n            ...eventOptions\n        };\n\n        triggerOne(object, `unbind:${key}`, extendedEventOptions);\n        triggerOne(object, 'unbind', extendedEventOptions);\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/unbindnode/_removebinding.js\n **/","import lookForBinder from '../lookforbinder';\nimport createNodeHandler from './_createnodehandler';\nimport createObjectHandler from './_createobjecthandler';\nimport triggerOne from '../trigger/_triggerone';\nimport addListener from '../on/_addlistener';\nimport debounce from '../_helpers/debounce';\nimport matreshkaError from '../_helpers/matreshkaerror';\n\nconst spaceReg = /\\s+/;\n\n// handles binding for single property & node\n// the function is used at bindNode\nexport default function bindSingleNode(object, {\n    binder: givenBinder,\n    key,\n    $nodes,\n    node,\n    eventOptions,\n    propDef\n}) {\n    const {\n        silent,\n        getValueOnBind,\n        setValueOnBind,\n        // TODO: We probably need some general flag to cancel or force debouncing\n        // ... which overrides the following flags (something like debounceBinding)\n        debounceSetValue = true,\n        debounceGetValue = true,\n        debounceSetValueOnBind = false,\n        debounceGetValueOnBind = false,\n        debounceSetValueDelay = 0,\n        debounceGetValueDelay = 0,\n        useExactBinder = false\n    } = eventOptions;\n    // create bindings array in property definition object\n    const bindings = propDef.bindings = propDef.bindings || [];\n    const { value } = propDef;\n    const bindingOptions = {\n        self: object,\n        key,\n        value,\n        $nodes,\n        node\n    };\n    let isUndefined = typeof value === 'undefined';\n    let binder;\n    let objectHandler;\n    let nodeHandler;\n\n    // do not allow to bind more than 2 nodes to \"sandbox\" (for all nodes)\n    // and \"container\" (for Matreshka.Array)\n    if (\n        bindings.length\n        && (key === 'sandbox' || (object.isMatreshkaArray && key === 'container'))\n    ) {\n        throw matreshkaError('binding:magic_props_nodes_length');\n    }\n\n    // get actual binder\n    if (givenBinder !== null) {\n        // by default binder passed to bindNode is extended by default binder\n        // useExactBinder turns this behavior off\n        if (useExactBinder) {\n            binder = givenBinder;\n        } else {\n            // getting default binder\n            const foundBinder = lookForBinder(node);\n\n            // if default binder is found\n            if (foundBinder) {\n                // extend found binder by given binder\n                if (givenBinder) {\n                    nofn.assign(foundBinder, givenBinder);\n                }\n\n                binder = foundBinder;\n            } else {\n                // default binder is not found\n                binder = givenBinder || {};\n            }\n        }\n    }\n\n    const { getValue, setValue, on, initialize } = binder;\n\n    // call binder.initialize\n    if (initialize) {\n        initialize.call(node, bindingOptions);\n    }\n\n    // add needed event handlers to given node when getValue is given\n    if (getValue) {\n        const syncNodeHandler = createNodeHandler({\n            object,\n            key,\n            node,\n            propDef,\n            binder,\n            bindingOptions\n        });\n\n        let debouncedNodeHandler;\n\n        if (debounceGetValue || debounceGetValueOnBind) {\n            debouncedNodeHandler = debounce(syncNodeHandler, debounceGetValueDelay);\n        }\n\n        if (debounceGetValue) {\n            nodeHandler = debouncedNodeHandler;\n        } else {\n            nodeHandler = syncNodeHandler;\n        }\n\n        // TODO: Throw error when \"on\" and maybe other binder properties has wrong type\n        if (typeof on === 'function') {\n            on.call(node, nodeHandler, bindingOptions);\n        } else if (typeof on === 'string') {\n            // addEventListener is faster than \"on\" method from any DOM library\n            nofn.forEach(on.split(spaceReg),\n                evtName => node.addEventListener(evtName, nodeHandler));\n        }\n\n        if ((isUndefined && getValueOnBind !== false) || getValueOnBind === true) {\n            if (debounceGetValueOnBind) {\n                debouncedNodeHandler();\n            } else {\n                syncNodeHandler();\n            }\n        }\n\n        isUndefined = typeof propDef.value === 'undefined';\n    }\n\n    // add needed event handlers to the object when setValue is given\n    if (setValue) {\n        const syncObjectHandler = createObjectHandler({\n            node,\n            propDef,\n            binder,\n            bindingOptions,\n            eventOptions\n        });\n\n        let debouncedObjectHandler;\n\n        if (debounceSetValue || debounceSetValueOnBind) {\n            debouncedObjectHandler = debounce(syncObjectHandler, debounceSetValueDelay);\n        }\n\n        if (debounceSetValue) {\n            objectHandler = debouncedObjectHandler;\n        } else {\n            objectHandler = syncObjectHandler;\n        }\n\n        // TODO: Is it possible to get previous value of a property?\n        addListener(object, `_change:bindings:${key}`, objectHandler, null, { skipChecks: true });\n\n        if ((!isUndefined && setValueOnBind !== false) || setValueOnBind === true) {\n            if (debounceSetValueOnBind) {\n                debouncedObjectHandler();\n            } else {\n                syncObjectHandler();\n            }\n        }\n    }\n\n    // add binding data to bindings array\n    bindings.push({\n        on,\n        node,\n        binder,\n        objectHandler,\n        nodeHandler,\n        bindingOptions\n    });\n\n    // fire events\n    if (!silent) {\n        const extendedEventOptions = {\n            key,\n            node,\n            ...eventOptions\n        };\n\n        triggerOne(object, `bind:${key}`, extendedEventOptions);\n        triggerOne(object, 'bind', extendedEventOptions);\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/bindnode/_bindsinglenode.js\n **/","import is from '../_helpers/is';\nimport set from '../set';\n\n// returns a function which called when bound node state is changed (eg DOM event is fired)\nexport default function createNodeHandler({\n    object,\n    key,\n    node,\n    propDef,\n    binder,\n    bindingOptions\n}) {\n    return function nodeHandler(domEvent = {}) {\n        // nodeHandler.disabled = true is set in unbindNode\n        // we cannot \"turn off\" binder.on when its value is a function\n        // developer needs to clean memory (\"turn off\" callback) manualy in binder.destroy\n        if (nodeHandler.disabled) {\n            return;\n        }\n\n        const previousValue = propDef.value;\n        const { which, target, ctrlKey, altKey } = domEvent;\n        const { getValue } = binder;\n        const value = getValue.call(node, {\n            previousValue,\n            domEvent,\n            originalEvent: domEvent.originalEvent || domEvent, // jQuery thing\n            // will throw \"preventDefault is not a function\" when domEvent is empty object\n            preventDefault: () => domEvent.preventDefault(),\n            // will throw \"stopPropagation is not a function\" when domEvent is empty object\n            stopPropagation: () => domEvent.stopPropagation(),\n            which,\n            target,\n            ctrlKey,\n            altKey,\n            ...bindingOptions\n        });\n\n        if (!is(value, previousValue)) {\n            set(object, key, value, {\n                fromNode: true,\n                // the following properties are needed to avoid circular changes\n                // they are used at objectHandler\n                changedNode: node,\n                onChangeValue: value,\n                binder\n            });\n        }\n    };\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/bindnode/_createnodehandler.js\n **/","// returns a function which is called when property value is changed\nexport default function createObjectHandler({\n    node,\n    propDef,\n    binder,\n    bindingOptions\n}) {\n    return function objectHandler(eventOptions = {}) {\n        const { value } = propDef;\n        const { onChangeValue, changedNode, binder: evtBinder } = eventOptions;\n        const { setValue } = binder;\n        // dirty hack for https://github.com/matreshkajs/matreshka/issues/19\n        const dirtyHackValue = onChangeValue === 'string' && typeof value === 'number'\n            ? `${value}` : value;\n\n        // don't call setValue if a property is changed via getValue of the same binder\n        if (changedNode === node && onChangeValue === dirtyHackValue && evtBinder === binder) {\n            return;\n        }\n\n        setValue.call(node, value, {\n            value,\n            ...bindingOptions\n        });\n    };\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/bindnode/_createobjecthandler.js\n **/","import getBindingKey from './_getbindingkey';\nimport bindNode from '../../bindnode';\nimport lookForBinder from '../../lookforbinder';\n\n// a binder for instance of Attr\nconst attributeBinder = {\n    setValue(value) {\n        this.value = value;\n    }\n};\n\n// adds binding for an attribute\n// its logic is much harder than for text node\n// check out imported modules for more info\nexport default function processAttribute({\n    node,\n    attribute,\n    object,\n    eventOptions\n}) {\n    const { name, value } = attribute;\n    const { type } = node;\n    // get a key which will be actually bound to an attribute\n    // getBindingKey analyzes given value, creates computable property and returns its key\n    const key = getBindingKey({\n        object,\n        text: value\n    });\n    const probablyValueInput = name === 'value' && type !== 'checkbox' && type !== 'radio';\n    const probablyCheckableInput = name === 'checked' && (type === 'checkbox' || type === 'radio');\n\n    let defaultBinder;\n\n    if (probablyValueInput || probablyCheckableInput) {\n        defaultBinder = lookForBinder(node);\n    }\n\n    if (defaultBinder) {\n        // if deault binder is found then this is default HTML5 form element\n        // remove the attribute and use found binder\n        node.setAttribute(name, '');\n        bindNode(object, key, node, defaultBinder, eventOptions);\n    } else {\n        // simply bind an attribute\n        bindNode(object, key, attribute, attributeBinder, eventOptions);\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/parsebindings/_processattribute/index.js\n **/","import parserData from '../_parserdata';\nimport defineHiddenContentProperty from './_definehiddencontentproperty';\n\n// analyzes string and returns only one key which will be actually bound to an attribute\nexport default function getBindingKey({\n    object,\n    text // for example 'Hello, {{x}}'\n}) {\n    const { strictBindingReg, bindingReg } = parserData;\n    const keys = [];\n\n    let execResult;\n    let key;\n\n    strictBindingReg.lastIndex = 0;\n    bindingReg.lastIndex = 0;\n\n    // extract keys given in parser brackers\n    // '{{x}} {{y}}' -> ['x', 'y']\n    while ((execResult = bindingReg.exec(text))) {\n        keys.push(execResult[1]);\n    }\n\n    if (keys.length === 1 && strictBindingReg.test(text)) {\n        // if there is only one key and if only binding substring is present in a text\n        // in other words '{{x}}' is given instead of '{{x}} {{y}}' or '{{x}}foo'\n        // then don't create computable property and use that key (eg 'x') for binding\n        key = keys[0];\n    } else {\n        // create hidden computable property\n        key = defineHiddenContentProperty({\n            object,\n            keys,\n            text\n        });\n    }\n\n    return key;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/parsebindings/_processattribute/_getbindingkey.js\n **/","import calc from '../../calc';\nimport parserData from '../_parserdata';\n\nconst hiddenPropertyPrefix = `${Math.random()}`.replace('0.', 'hidden');\nlet hiddenPropertyIndex = 0;\n\n// defines hiden (without accessors) computed property\n// that dependent on given properties ('keys') as text template describes\n// for example if text='{{x}} blah {{y}}', x='foo', y='bar'\n// then the new property should have value 'foo blah bar'\nexport default function defineHiddenContentProperty({\n    object,\n    keys,\n    text\n}) {\n    const key = `${hiddenPropertyPrefix}${hiddenPropertyIndex}`;\n    const regs = {};\n    const { escLeftBracket, escRightBracket } = parserData;\n\n    hiddenPropertyIndex += 1;\n\n    // create and cache regular expressions which will help us to\n    // change target property value quickly when sources are changed\n    for (let i = 0; i < keys.length; i++) {\n        regs[keys[i]] = new RegExp(escLeftBracket + keys[i] + escRightBracket, 'g');\n    }\n\n    calc(object, key, keys, function calcHandler() {\n        let value = text;\n\n        // replace things like {{x}} by actual values\n        for (let i = 0; i < keys.length; i++) {\n            value = value.replace(regs[keys[i]], arguments[i]);\n        }\n\n        return value;\n    }, {\n        isTargetPropertyHidden: true,\n        debounceCalc: false\n    });\n\n    return key;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/parsebindings/_processattribute/_definehiddencontentproperty.js\n **/","import defs from '../../_core/defs';\nimport matreshkaError from '../../_helpers/matreshkaerror';\n\n// checks is item already rendered in an array\n// selfDef is given instead of itself (array) for perf optimisation\nexport default function checkAlreadyRendered({\n    item,\n    selfDef\n}) {\n    const itemDef = defs.get(item);\n    const { id: selfId } = selfDef;\n\n    // if item object is defined in object defs\n    if (itemDef) {\n        const { renderedInArrays } = itemDef;\n\n        // if item's node is already rendered for an array\n        // then throw an error\n        if (renderedInArrays && renderedInArrays[selfId]) {\n            throw matreshkaError('array:add_render_twice');\n        }\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/array/_processrendering/checkalreadyrendered.js\n **/","import renderItemNode from './renderitemnode';\nimport triggerOne from '../../trigger/_triggerone';\nimport checkAlreadyRendered from './checkalreadyrendered';\n\n// this function renders inserted items if possible when unshift or push method is called\nexport default function processUnshift({\n    self,\n    selfDef,\n    eventOptions,\n    container\n}) {\n    const { added, silent } = eventOptions;\n\n    // iterate over all added items in opposite order\n    for (let i = added.length - 1; i + 1; i--) {\n        const item = added[i];\n        if (item && typeof item === 'object') {\n            // if a node of an item is already rendered then throw an error\n            checkAlreadyRendered({\n                item,\n                selfDef\n            });\n\n            const { node, itemEventOptions } = renderItemNode({\n                selfDef,\n                self,\n                item,\n                eventOptions\n            });\n\n            if (node) {\n                if (container.firstChild) {\n                    container.insertBefore(node, container.firstChild);\n                } else {\n                    container.appendChild(node);\n                }\n\n                if (!silent) {\n                    triggerOne(item, 'afterrender', itemEventOptions);\n                }\n            }\n        }\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/array/_processrendering/processunshift.js\n **/","import renderItemNode from './renderitemnode';\nimport triggerOne from '../../trigger/_triggerone';\nimport defs from '../../_core/defs';\nimport matreshkaError from '../../_helpers/matreshkaerror';\nimport getAlreadyRendered from './getalreadyrendered';\n\n// this function renders inserted items if possible when recreate method is called\nexport default function processRecreate({\n    self,\n    selfDef,\n    eventOptions,\n    container\n}) {\n    const { removed, silent } = eventOptions;\n    const { id: selfId } = selfDef;\n\n    // iterate over removed items and remove their nodes\n    nofn.forEach(removed, (item) => {\n        const itemDef = defs.get(item);\n\n        if (itemDef) {\n            const { renderedInArrays } = itemDef;\n            const node = renderedInArrays && renderedInArrays[selfId];\n            if (node) {\n                delete itemDef.renderedInArrays[selfId];\n                container.removeChild(node);\n            }\n        }\n    });\n\n    const alreadyRenderedMap = {};\n\n    // iterate over all items\n    // the following approach allows to throw an error when two added objects are the same\n    // (not only compare existing items with old ones)\n    nofn.forEach(self, (item) => {\n        if (item && typeof item === 'object') {\n            let itemDef = defs.get(item);\n            let alreadyRenderedNode;\n\n            if (itemDef) {\n                alreadyRenderedNode = getAlreadyRendered({\n                    item,\n                    selfDef\n                });\n            }\n\n            if (alreadyRenderedNode) {\n                // if an item is already rendered (old item)\n                if (itemDef.id in alreadyRenderedMap) {\n                    // if an item is rendered twice throw an error\n                    throw matreshkaError('array:add_render_twice');\n                }\n\n                alreadyRenderedMap[itemDef.id] = true;\n\n                container.appendChild(alreadyRenderedNode);\n            } else {\n                // this is newly added item\n                const { node, itemEventOptions } = renderItemNode({\n                    selfDef,\n                    self,\n                    item,\n                    eventOptions\n                });\n\n                if (node) {\n                    // itemDef is defined at renderItemNode if not defined before\n                    // reload this variable\n                    itemDef = itemDef || defs.get(item);\n\n                    if (itemDef.id in alreadyRenderedMap) {\n                        // if newly added item is rendered twice throw an error\n                        throw matreshkaError('array:add_render_twice');\n                    }\n\n                    alreadyRenderedMap[itemDef.id] = true;\n\n                    container.appendChild(node);\n\n                    if (!silent) {\n                        triggerOne(item, 'afterrender', itemEventOptions);\n                    }\n                }\n            }\n        }\n    });\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/array/_processrendering/processrecreate.js\n **/","import defs from '../../_core/defs';\n\n// returns already rendered node of an object in given array\n// selfDef is given instead of  itself (array) for perf optimisation\nexport default function getAlreadyRendered({\n    item,\n    selfDef\n}) {\n    const itemDef = defs.get(item);\n    const { id: selfId } = selfDef;\n\n    // if item object is defined in object defs\n    if (itemDef) {\n        const { renderedInArrays } = itemDef;\n\n        // if item's node is already rendered for an array then return it\n        if (renderedInArrays && renderedInArrays[selfId]) {\n            return renderedInArrays[selfId];\n        }\n    }\n\n    return undefined;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/array/_processrendering/getalreadyrendered.js\n **/","import getAlreadyRendered from './getalreadyrendered';\n\n// this function gets called when array is sorted (via sort, orderBy or reverse)\nexport default function processSort({\n    self,\n    selfDef,\n    // eventOptions,\n    container\n}) {\n    // just re-insert rendered nodes in new order\n    nofn.forEach(self, (item) => {\n        if (item && typeof item === 'object') {\n            const node = getAlreadyRendered({\n                item,\n                selfDef\n            });\n\n            if (node) {\n                container.appendChild(node);\n            }\n        }\n    });\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/array/_processrendering/processsort.js\n **/","import defs from '../../_core/defs';\n\n// this function removes DOM nodes of removed items\n// called on splice, pull, pop and shift\nexport default function processRemove({\n    // self,\n    selfDef,\n    eventOptions,\n    container\n}) {\n    const { removed } = eventOptions;\n    const { id: selfId } = selfDef;\n    nofn.forEach(removed, (item) => {\n        if (item && typeof item === 'object') {\n            const itemDef = defs.get(item);\n            if (itemDef) {\n                const { renderedInArrays } = itemDef;\n                const node = renderedInArrays && renderedInArrays[selfId];\n                if (node) {\n                    delete renderedInArrays[selfId];\n                    container.removeChild(node);\n                }\n            }\n        }\n    });\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/array/_processrendering/processremove.js\n **/","import getAlreadyRendered from './getalreadyrendered';\nimport renderItemNode from './renderitemnode';\nimport triggerOne from '../../trigger/_triggerone';\n\n// this function re-inserts rendered DOM nodes of items\n// if they are rendered and forceRerender is falsy\n// and renders array items from scratch if they aren't rendered yet or forceRerender is truthy\nexport default function processRerender({\n    self,\n    selfDef,\n    eventOptions,\n    container\n}) {\n    const { forceRerender, silent } = eventOptions;\n\n    // iterate over all items\n    for (let i = 0; i < self.length; i++) {\n        const item = self[i];\n        if (item && typeof item === 'object') {\n            const alreadyRenderedNode = getAlreadyRendered({\n                item,\n                selfDef\n            });\n\n            // if item is already rendered and forceRerender is falsy then re-insert DOM node\n            // go to the next cycle iteration then\n            if (!forceRerender && alreadyRenderedNode) {\n                container.appendChild(alreadyRenderedNode);\n                continue;\n            }\n\n            // node removal is called when an item is rendered\n            // and forceRerender is truty\n            if (alreadyRenderedNode) {\n                if (container.contains(alreadyRenderedNode)) {\n                    container.removeChild(alreadyRenderedNode);\n                }\n            }\n\n            // render new node\n            const { node, itemEventOptions } = renderItemNode({\n                selfDef,\n                self,\n                item,\n                eventOptions\n            });\n\n            if (node) {\n                container.appendChild(node);\n\n                if (!silent) {\n                    triggerOne(item, 'afterrender', itemEventOptions);\n                }\n            }\n        }\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/array/_processrendering/processrerender.js\n **/","import renderItemNode from './renderitemnode';\nimport triggerOne from '../../trigger/_triggerone';\nimport checkAlreadyRendered from './checkalreadyrendered';\nimport getAlreadyRendered from './getalreadyrendered';\n\n// the function handles rendering of added items passed as third and rest arguments to splice method\nexport default function processSpliceAdd({\n    self,\n    selfDef,\n    eventOptions,\n    container\n}) {\n    const { added, silent } = eventOptions;\n    const nextIndex = self.lastIndexOf(added[added.length - 1]) + 1;\n    const next = self[nextIndex];\n    let nextNode;\n\n    // get a node of an item which is placed next to the last added item\n    // it is needed to insert newly rendered items before\n    if (next && typeof next === 'object') {\n        nextNode = getAlreadyRendered({\n            item: next,\n            selfDef\n        });\n    }\n\n    nofn.forEach(added, (item) => {\n        if (item && typeof item === 'object') {\n            // throw an error if node of an item is alread rendered\n            checkAlreadyRendered({\n                item,\n                selfDef\n            });\n\n            const { node, itemEventOptions } = renderItemNode({\n                selfDef,\n                self,\n                item,\n                eventOptions\n            });\n\n            if (node) {\n                if (nextNode) {\n                    container.insertBefore(node, nextNode);\n                } else {\n                    container.appendChild(node);\n                }\n\n                if (!silent) {\n                    triggerOne(item, 'afterrender', itemEventOptions);\n                }\n            }\n        }\n    });\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/array/_processrendering/processspliceadd.js\n **/","import reportModified from './_reportmodified';\nimport matreshkaError from '../_helpers/matreshkaerror';\n\n// removes array item by given index\nfunction shift(arr, index) {\n    for (let i = index; i < arr.length; i++) {\n        arr[i] = arr[i + 1];\n    }\n    delete arr[arr.length - 1];\n    arr.length -= 1;\n}\n\n// finds array item that equals to given value and removes it\n// returns removed value\nfunction pullByValue(arr, value) {\n    for (let i = 0; i < arr.length; i++) {\n        if (arr[i] === value) {\n            shift(arr, i);\n            return value;\n        }\n    }\n\n    return undefined;\n}\n\n// removes array item by given index if the index is not over array length\n// returns removed value\nfunction pullByIndex(arr, index) {\n    if (index < arr.length) {\n        const value = arr[index];\n        shift(arr, index);\n        return value;\n    }\n\n    return undefined;\n}\n\n// removes an array item by index (if number is given) or by value (if object is given)\nexport default function pull(toRemove, eventOptions = {}) {\n    const typeofToRemove = typeof toRemove;\n    let removed;\n\n    if (toRemove && typeofToRemove === 'object') {\n        removed = pullByValue(this, toRemove);\n    } else if (typeofToRemove === 'number') {\n        removed = pullByIndex(this, toRemove);\n    } else {\n        throw matreshkaError('pull:to_remove_type', { toRemove });\n    }\n\n    if (typeof removed !== 'undefined') {\n        reportModified(this, {\n            method: 'pull',\n            self: this,\n            added: [],\n            removed: [removed],\n            ...eventOptions\n        });\n    }\n\n    return removed;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/array/pull.js\n **/","import initMK from '../../_core/init';\nimport reportModified from '../_reportmodified';\nimport updateTracked from './_updatetracked';\n\n// recreates an array\nexport default function recreate(givenNewItems = [], eventOptions = {}) {\n    const def = initMK(this);\n    const { itemMediator } = def;\n    const newLength = givenNewItems.length;\n    const oldLength = this.length;\n    const lengthDiff = oldLength - newLength;\n    const was = this.toJSON(false);\n    const { trackBy } = this;\n    const { skipItemMediator, silent, dontRender } = eventOptions;\n    let added;\n    let removed;\n    let newItems;\n\n    if (trackBy) {\n        // if trackBy property is given then update givenNewItems array\n        newItems = updateTracked({\n            arr: this,\n            givenNewItems,\n            trackBy\n        });\n    } else {\n        // if trackBy is not given then use given new items as is\n        newItems = givenNewItems;\n    }\n\n    // call item mediator for every new item (but don't modify passed newItems)\n    if (itemMediator && !skipItemMediator) {\n        const toMediate = newItems;\n        newItems = Array(newLength);\n        for (let i = 0; i < newLength; i++) {\n            newItems[i] = itemMediator(toMediate[i], i);\n        }\n    }\n\n    // update array indexes with new values\n    for (let i = 0; i < newLength; i++) {\n        this[i] = newItems[i];\n    }\n\n    // remove old items that is out of new length\n    for (let i = 0; i < lengthDiff; i++) {\n        delete this[i + newLength];\n    }\n\n    // update length\n    this.length = newLength;\n\n    if (silent && dontRender) {\n        return this;\n    }\n\n    // create an array of removed items\n    // TODO: Optimize creation of \"added\" and \"removed\" options in recreate method\n    // ... (do not use indexOf)\n    if (newLength) {\n        if (oldLength) {\n            removed = [];\n            for (let i = 0; i < oldLength; i++) {\n                if (!~newItems.indexOf(was[i])) {\n                    removed.push(was[i]);\n                }\n            }\n        } else {\n            removed = [];\n        }\n    } else {\n        removed = was;\n    }\n\n    // create an array of added items\n    if (oldLength) {\n        if (newLength) {\n            added = [];\n            for (let i = 0; i < newLength; i++) {\n                if (!~was.indexOf(newItems[i])) {\n                    added.push(newItems[i]);\n                }\n            }\n        } else {\n            added = [];\n        }\n    } else {\n        added = newItems;\n    }\n\n    reportModified(this, {\n        added,\n        removed,\n        method: 'recreate',\n        self: this,\n        ...eventOptions\n    });\n\n    return this;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/array/recreate/index.js\n **/","import updateObject from './_updateobject';\n\n// the function gets called to update new items passed to recreate method when trackBy is present\n// TODO: Throw an error when two or more items of one array has the same value of trackBy\nexport default function updateTracked({\n    givenNewItems,\n    arr,\n    trackBy\n}) {\n    const newLength = givenNewItems.length;\n    const oldLength = arr.length;\n    const newItems = Array(newLength);\n\n    if (trackBy === '$index') {\n        // simply update items with the same index\n        for (let i = 0; i < newLength; i++) {\n            const item = arr[i];\n            const newItem = givenNewItems[i];\n\n            if (\n                item && typeof item === 'object'\n                && newItem && typeof newItem === 'object'\n            ) {\n                newItems[i] = updateObject(item, newItem);\n            } else {\n                newItems[i] = newItem;\n            }\n        }\n    } else {\n        const trackMap = {};\n\n        // fill trackMap object where keys are values of trackBy and values are corresponding items\n        for (let i = 0; i < oldLength; i++) {\n            const item = arr[i];\n\n            if (item && typeof item === 'object') {\n                if (trackBy in item) {\n                    trackMap[item[trackBy]] = item;\n                }\n            }\n        }\n\n        for (let i = 0; i < newLength; i++) {\n            const newItem = givenNewItems[i];\n\n            if (newItem && typeof newItem === 'object') {\n                const item = arr[i];\n\n                if (item && typeof item === 'object' && newItem[trackBy] in trackMap) {\n                    // if an item exists at trackMap then update it\n                    newItems[i] = updateObject(trackMap[newItem[trackBy]], newItem);\n                } else {\n                    // if not then use new value as is\n                    newItems[i] = newItem;\n                }\n            } else {\n                // newItem is not an object\n                newItems[i] = newItem;\n            }\n        }\n    }\n\n    return newItems;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/array/recreate/_updatetracked.js\n **/","// updates one single object by new data\n// for Matreshka.Array instance call recreate method\n// for Matreshka.Object instance call setData method\n// for other objects just extend them by properties of data parameter\nexport default function updateObject(instance, data) {\n    if (instance.isMatreshkaArray) {\n        instance.recreate(data);\n    } else if (instance.isMatreshkaObject) {\n        // QUESTION: Is it OK to just extend but not replace instance data?\n        instance.setData(data);\n    } else {\n        nofn.forOwn(data, (value, key) => {\n            instance[key] = value;\n        });\n    }\n\n    return instance;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/array/recreate/_updateobject.js\n **/","import processRendering from './_processrendering';\n\n// rerenders not rendered items in an array\n// force rerender when forceRerender event option is truthy\nexport default function rerender(eventOptions = {}) {\n    const { renderIfPossible = true } = this;\n    if (renderIfPossible) {\n        processRendering({\n            self: this,\n            eventOptions: {\n                method: 'rerender',\n                added: [],\n                removed: [],\n                ...eventOptions\n            }\n        });\n    }\n\n    return this;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/array/rerender.js\n **/","import initMK from '../_core/init';\nimport matreshkaError from '../_helpers/matreshkaerror';\nimport bindNode from '../bindnode';\nimport triggerOne from '../trigger/_triggerone';\nimport getNodes from '../bindnode/_getnodes';\n\n// restores Matreshka.Array from external nodes\nexport default function restore(selector, eventOptions = {}) {\n    const selfDef = initMK(this);\n    const { Model } = this;\n    const { silent } = eventOptions;\n    const newItems = [];\n    let nodes;\n\n    if (typeof selector === 'string') {\n        // get nodes by selector\n        nodes = getNodes(this, selector);\n    } else {\n        // get nodes from rendering container\n        const container = this.nodes.container || this.nodes.sandbox;\n\n        if (container) {\n            nodes = container.children;\n        } else {\n            // no container is bound, throw an error\n            throw matreshkaError('restore:no_nodes');\n        }\n    }\n\n    nofn.forEach(nodes, (node, index) => {\n        const item = Model ? new Model({}, this, index) : {}; // create new item\n        const { bindRenderedAsSandbox } = item;\n        const itemDef = initMK(item);\n\n        itemDef.renderedInArrays = {\n            [selfDef.id]: node\n        };\n\n        if (bindRenderedAsSandbox !== false) {\n            bindNode(item, 'sandbox', node, null, eventOptions);\n        }\n\n        if (!silent) {\n            // trigger needed events\n            const itemEventOptions = {\n                node,\n                self: item,\n                parentArray: this\n            };\n\n            const { onRender } = item;\n            const { onItemRender } = this;\n\n            if (onRender) {\n                onRender.call(item, itemEventOptions);\n            }\n\n            if (onItemRender) {\n                onItemRender.call(this, item, itemEventOptions);\n            }\n\n            triggerOne(item, 'render', itemEventOptions);\n\n            // call afterrender immediately because a node already exists in DOM tree\n            triggerOne(item, 'afterrender', itemEventOptions);\n        }\n\n        newItems.push(item);\n    });\n\n    // recreate an array but don't render newly added items\n    return this.recreate(newItems, {\n        dontRender: true,\n        ...eventOptions\n    });\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/array/restore.js\n **/","// converts Matreshka.Array instance to ordinary array\nexport default function toJSON(recursive = true) {\n    const result = new Array(this.length);\n\n    nofn.forEach(this, (item, index) => {\n        // when recursive is true and when an item has toJSON method then call it recusively\n        if (recursive && item && typeof item.toJSON === 'function') {\n            result[index] = item.toJSON(true);\n        } else {\n            result[index] = item;\n        }\n    });\n\n    return result;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/array/tojson.js\n **/","import createPseudoNativeMethod from './createpseudonativemethod';\nimport concat from './concat';\nimport keys from './keys';\nimport values from './values';\nimport entries from './entries';\n\nconst splitBySpaceReg = /\\s+/;\nconst methods = { concat, keys, values, entries };\n\n`push pop unshift shift sort reverse splice map filter slice every some reduce reduceRight\nforEach join indexOf lastIndexOf copyWithin fill includes find findIndex`\n    .split(splitBySpaceReg).forEach((name) => {\n        methods[name] = createPseudoNativeMethod(name);\n    });\n\n'push pop unshift shift sort reverse splice copyWithin fill'\n    .split(splitBySpaceReg).forEach((name) => {\n        methods[`${name}_`] = createPseudoNativeMethod(name, true);\n    });\n\nexport default methods;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/array/_pseudonativemethods/index.js\n **/","import toMatreshkaArray from '../_tomatreshkaarray';\nimport createSortingMethod from './createsortingmethod';\nimport createRemovingMethod from './createremovingmethod';\nimport createAddingMethod from './createaddingmethod';\nimport createSplice from './createsplice';\nimport createCopyWithin from './createcopywithin';\nimport createFill from './createfill';\nimport apply from '../../_helpers/apply';\nimport matreshkaError from '../../_helpers/matreshkaerror';\n\nconst arrayPrototype = Array.prototype;\n\n// creates pseudo native method and returns it (push, push_, sort, sort_...)\nexport default function createPseudoNativeMethod(name, hasOptions = false) {\n    switch (name) {\n        case 'forEach':\n            return function pseudoNativeMethod(callback, thisArg) {\n                arrayPrototype[name].call(this, callback, thisArg);\n                // return this for nicer chain calls\n                return this;\n            };\n        case 'map':\n        case 'filter':\n        case 'slice':\n            // TODO: Improve readability of pseudoNativeMethod, arguments \"a, b\" look not good\n            return function pseudoNativeMethod(a, b) {\n                return toMatreshkaArray(arrayPrototype[name].call(this, a, b));\n            };\n        case 'every':\n        case 'some':\n        case 'findIndex':\n        case 'find':\n            return function pseudoNativeMethod(callback, thisArg) {\n                const originalMethod = arrayPrototype[name];\n\n                /* istanbul ignore if  */\n                if (typeof originalMethod !== 'function') {\n                    throw matreshkaError('array:nonexistent_method', { method: name });\n                }\n                return originalMethod.call(this, callback, thisArg);\n            };\n        case 'join':\n            return function pseudoNativeMethod(separator = ',') {\n                return arrayPrototype[name].call(this, separator);\n            };\n        case 'indexOf':\n        case 'lastIndexOf':\n        case 'includes':\n            return function pseudoNativeMethod(searchElement, fromIndex) {\n                const originalMethod = arrayPrototype[name];\n\n                /* istanbul ignore if  */\n                if (typeof originalMethod !== 'function') {\n                    throw matreshkaError('array:nonexistent_method', { method: name });\n                }\n\n                if (typeof fromIndex === 'undefined') {\n                    return originalMethod.call(this, searchElement);\n                }\n\n                return originalMethod.call(this, searchElement, fromIndex);\n            };\n        case 'reduce':\n        case 'reduceRight':\n            return function pseudoNativeMethod() {\n                return apply(arrayPrototype[name], this, arguments);\n            };\n        case 'sort':\n        case 'reverse':\n            return createSortingMethod(name, hasOptions);\n        case 'pop':\n        case 'shift':\n            return createRemovingMethod(name, hasOptions);\n        case 'push':\n        case 'unshift':\n            return createAddingMethod(name, hasOptions);\n        case 'splice':\n            return createSplice(hasOptions);\n        case 'copyWithin':\n            return createCopyWithin(hasOptions);\n        case 'fill':\n            return createFill(hasOptions);\n        default:\n            return undefined;\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/array/_pseudonativemethods/createpseudonativemethod.js\n **/","// converts array-like to Matreshka.Array instance\nexport default function toMatreshkaArray(arrayLike) {\n    // fix circular dependency issue\n    const MatreshkaArray = require('./');\n\n    const result = new MatreshkaArray(arrayLike.length);\n\n    nofn.forEach(arrayLike, (item, index) => {\n        result[index] = item;\n    });\n\n    return result;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/array/_tomatreshkaarray.js\n **/","import initMK from '../../_core/init';\nimport reportModified from '../_reportmodified';\n\n// creates sorting method and returns it (sort, reverse, sort_, reverse_)\nexport default function createSortingMethod(name, hasOptions) {\n    return function pseudoNativeMethod(sortCallback) {\n        if (this.length < 2) return this;\n        initMK(this);\n\n        const givenEventOptions = hasOptions ? arguments[arguments.length - 1] : null;\n        const method = Array.prototype[name];\n\n        const eventOptions = {\n            method: name,\n            self: this,\n            added: [],\n            removed: []\n        };\n\n        // call original method\n        if (name === 'sort' && typeof sortCallback === 'function') {\n            method.call(this, sortCallback);\n        } else {\n            method.call(this);\n        }\n\n        // extend event options by custom event options if they are given\n        if (hasOptions) {\n            if (givenEventOptions && typeof givenEventOptions === 'object') {\n                nofn.assign(eventOptions, givenEventOptions);\n            }\n        }\n\n        reportModified(this, eventOptions);\n\n        return this;\n    };\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/array/_pseudonativemethods/createsortingmethod.js\n **/","import initMK from '../../_core/init';\nimport reportModified from '../_reportmodified';\n\n// creates removing method and returns it (pop, shift, pop_, shift_)\nexport default function createRemovingMethod(name, hasOptions) {\n    return function pseudoNativeMethod(givenEventOptions) {\n        if (!this.length) {\n            return undefined;\n        }\n        initMK(this);\n\n        // call original method\n        const returns = Array.prototype[name].call(this);\n        const eventOptions = {\n            method: name,\n            self: this,\n            added: [],\n            removed: [returns]\n        };\n\n        // extend event options by custom event options if they are given\n        if (hasOptions) {\n            if (givenEventOptions && typeof givenEventOptions === 'object') {\n                nofn.assign(eventOptions, givenEventOptions);\n            }\n        }\n\n        reportModified(this, eventOptions);\n\n        return returns;\n    };\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/array/_pseudonativemethods/createremovingmethod.js\n **/","import initMK from '../../_core/init';\nimport reportModified from '../_reportmodified';\n\n// creates methods: push, unshift, push_, unshift_\nexport default function createAddingMethod(name, hasOptions) {\n    return function pseudoNativeMethod() {\n        const { itemMediator } = initMK(this);\n        // +hasOptions is converted to 0 or 1 depending on its value (false/true)\n        const argsLength = arguments.length - +hasOptions;\n        const args = Array(argsLength);\n        const givenEventOptions = hasOptions ? arguments[arguments.length - 1] : null;\n        const useMediator = typeof itemMediator === 'function'\n            && (!givenEventOptions || !givenEventOptions.skipItemMediator);\n        const isPush = name === 'push';\n        let { length } = this;\n\n        // if no arguments are passed\n        if (!argsLength) {\n            return length;\n        }\n\n        // convert arguments to array and call item mediator on every item if it's possible\n        for (let i = 0; i < argsLength; i++) {\n            const arg = arguments[i];\n            if (useMediator) {\n                const index = isPush ? i + length : i;\n                args[i] = itemMediator(arg, index);\n            } else {\n                args[i] = arg;\n            }\n        }\n\n        if (isPush) {\n            // insert new items to the end of array\n            for (let i = 0; i < argsLength; i++) {\n                this[length + i] = args[i];\n            }\n        } else {\n            // move current items to new indexes\n            for (let i = length - 1; i >= 0; i--) {\n                this[argsLength + i] = this[i];\n            }\n            // insert new items to the begin of array\n            for (let i = 0; i < argsLength; i++) {\n                this[i] = args[i];\n            }\n        }\n\n        // update length\n        length += argsLength;\n        this.length = length;\n\n        const eventOptions = {\n            method: name,\n            self: this,\n            added: args,\n            removed: []\n        };\n\n        // extend event options by custom event options if they are given\n        if (hasOptions) {\n            if (givenEventOptions && typeof givenEventOptions === 'object') {\n                nofn.assign(eventOptions, givenEventOptions);\n            }\n        }\n\n        reportModified(this, eventOptions);\n\n        return length;\n    };\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/array/_pseudonativemethods/createaddingmethod.js\n **/","import initMK from '../../_core/init';\nimport reportModified from '../_reportmodified';\nimport toMatreshkaArray from '../_tomatreshkaarray';\nimport apply from '../../_helpers/apply';\n\n// creates splice or splice_ method and returns it\n// TODO: Improve readability of createSplice function\nexport default function createSplice(hasOptions) {\n    return function pseudoNativeMethod() {\n        const { itemMediator } = initMK(this);\n        const functionArguments = arguments;\n        const argsLength = functionArguments.length - +hasOptions;\n        const args = Array(argsLength);\n        const givenEventOptions = hasOptions\n            ? functionArguments[functionArguments.length - 1]\n            : null;\n        const useMediator = typeof itemMediator === 'function'\n            && (!givenEventOptions || !givenEventOptions.skipItemMediator);\n        const added = [];\n        let start = args[0];\n        const { length } = this;\n\n        start = start < 0 ? length + start : start;\n\n        // convert arguments to array and call item mediator on every new item if it's possible\n        args[0] = functionArguments[0];\n        args[1] = functionArguments[1];\n        for (let i = 2; i < argsLength; i++) {\n            const arg = functionArguments[i];\n            if (useMediator) {\n                args[i] = itemMediator(arg, start + (i - 2));\n            } else {\n                args[i] = arg;\n            }\n\n            added[i - 2] = args[i];\n        }\n\n        // call original method\n        // TODO: Change array manually in splice method for better performance\n        const returns = apply(Array.prototype.splice, this, args);\n        // removed items mean returned items\n        const removed = returns;\n\n        // if something is added or removed\n        if (added.length || removed.length) {\n            const eventOptions = {\n                added,\n                removed,\n                method: 'splice',\n                self: this\n            };\n\n            // extend event options by custom event options if they are given\n            if (hasOptions) {\n                if (givenEventOptions && typeof givenEventOptions === 'object') {\n                    nofn.assign(eventOptions, givenEventOptions);\n                }\n            }\n\n            reportModified(this, eventOptions);\n        }\n\n        return toMatreshkaArray(returns);\n    };\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/array/_pseudonativemethods/createsplice.js\n **/","import apply from '../../_helpers/apply';\nimport reportModified from '../_reportmodified';\nimport matreshkaError from '../../_helpers/matreshkaerror';\n\nexport default function createCopyWithin(hasOptions) {\n    return function copyWithin() {\n        const originalCopyWithin = Array.prototype.copyWithin;\n\n        /* istanbul ignore if  */\n        if (typeof originalCopyWithin !== 'function') {\n            throw matreshkaError('array:nonexistent_method', { method: 'copyWithin' });\n        }\n        // +hasOptions is converted to 0 or 1 depending on its value (false/true)\n        const argsLength = arguments.length - +hasOptions;\n        const args = Array(argsLength);\n        const givenEventOptions = hasOptions ? arguments[arguments.length - 1] : null;\n\n        for (let i = 0; i < argsLength; i++) {\n            args[i] = arguments[i];\n        }\n\n        apply(originalCopyWithin, this, args);\n\n        const eventOptions = {\n            method: 'copyWithin',\n            self: this,\n            added: [],\n            removed: []\n        };\n\n        // extend event options by custom event options if they are given\n        if (hasOptions) {\n            if (givenEventOptions && typeof givenEventOptions === 'object') {\n                nofn.assign(eventOptions, givenEventOptions);\n            }\n        }\n\n        reportModified(this, eventOptions);\n\n        return this;\n    };\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/array/_pseudonativemethods/createcopywithin.js\n **/","import apply from '../../_helpers/apply';\nimport reportModified from '../_reportmodified';\nimport matreshkaError from '../../_helpers/matreshkaerror';\n\nexport default function createFill(hasOptions) {\n    return function fill(value) {\n        const originalFill = Array.prototype.fill;\n\n        /* istanbul ignore if  */\n        if (typeof originalFill !== 'function') {\n            throw matreshkaError('array:nonexistent_method', { method: 'fill' });\n        }\n        // +hasOptions is converted to 0 or 1 depending on its value (false/true)\n        const argsLength = arguments.length - +hasOptions;\n        const args = Array(argsLength);\n        const givenEventOptions = hasOptions ? arguments[arguments.length - 1] : null;\n\n        for (let i = 0; i < argsLength; i++) {\n            args[i] = arguments[i];\n        }\n\n        apply(originalFill, this, args);\n\n        const eventOptions = {\n            method: 'fill',\n            self: this,\n            added: [value],\n            removed: []\n        };\n\n        // extend event options by custom event options if they are given\n        if (hasOptions) {\n            if (givenEventOptions && typeof givenEventOptions === 'object') {\n                nofn.assign(eventOptions, givenEventOptions);\n            }\n        }\n\n        reportModified(this, eventOptions);\n\n        return this;\n    };\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/array/_pseudonativemethods/createfill.js\n **/","import apply from '../../_helpers/apply';\n\n// the method works just like Array.prototype.concat but\n// - flattens both Array and Matreshka.Array\n// - returns Matreshka.Array\nexport default function concat() {\n    // fix circular dependency issue\n    const MatreshkaArray = require('../');\n\n    const args = Array(arguments.length);\n\n    // convert all instances of Matreshka.Array to Array\n    nofn.forEach(arguments, (arg, index) => {\n        if (arg && typeof arg === 'object' && arg.isMatreshkaArray) {\n            args[index] = arg.toJSON(false);\n        } else {\n            args[index] = arg;\n        }\n    });\n\n    // call original concat method\n    const nativeCallResult = apply(Array.prototype.concat, this.toJSON(false), args);\n\n    // convert returned value to Matreshka.Array\n    const result = new MatreshkaArray();\n    nofn.forEach(nativeCallResult, (item, index) => {\n        result[index] = item;\n    });\n\n    result.length = nativeCallResult.length;\n\n    return result;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/array/_pseudonativemethods/concat.js\n **/","// returns indexes\nexport default function keys() {\n    const { length } = this;\n    const result = new Array(length);\n\n    for (let i = 0; i < length; i++) {\n        result[i] = i;\n    }\n\n    return result;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/array/_pseudonativemethods/keys.js\n **/","// returns values\nexport default function values() {\n    const { length } = this;\n    const result = new Array(length);\n\n    for (let i = 0; i < length; i++) {\n        result[i] = this[i];\n    }\n\n    return result;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/array/_pseudonativemethods/values.js\n **/","// returns pairs like [index, value]\nexport default function values() {\n    const { length } = this;\n    const result = new Array(length);\n\n    for (let i = 0; i < length; i++) {\n        result[i] = [i, this[i]];\n    }\n\n    return result;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/array/_pseudonativemethods/entries.js\n **/","// Symbol.iterator of Matreshka.Array instances\nexport default function matreshkaArrayIterator() {\n    let i = 0;\n\n    return {\n        next: () => {\n            if (i > this.length - 1) {\n                return {\n                    done: true\n                };\n            }\n\n            return {\n                done: false,\n                value: this[i++] // eslint-disable-line no-plusplus\n            };\n        }\n    };\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/array/iterator.js\n **/","import from from './from'; // lol\nimport of from './of';\n\nexport default {\n    of,\n    from\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/array/_staticmembers.js\n **/","import cheapRecreate from './_cheaprecreate';\n\n// creates a new Matreshka.Array instance from an array-like or iterable object\nexport default function from(arrayLike, mapFn, thisArg) {\n    // allow to inherit this method by child classes\n    // require('./') fixes circular ref issue\n    const ParentClass = this || require('./');\n\n    const result = new ParentClass();\n    const length = arrayLike.length;\n    const arrayFrom = Array.from;\n    let newItems;\n\n    /* istanbul ignore else */\n    if (typeof arrayFrom === 'function') {\n        // if Array.from exist, let it do all the job (work with iterable objects etc)\n        newItems = arrayFrom(arrayLike, mapFn, thisArg);\n    } else {\n        // convert array-like object for older browsers\n        // @IE\n        newItems = Array(length);\n\n        for (let i = 0; i < length; i++) {\n            if (typeof mapFn === 'function') {\n                newItems[i] = mapFn.call(thisArg, arrayLike[i], i, arrayLike);\n            } else {\n                newItems[i] = arrayLike[i];\n            }\n        }\n    }\n\n    return cheapRecreate(result, newItems);\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/array/from.js\n **/","import cheapRecreate from './_cheaprecreate';\n\n// creates a new Matreshka.Array instance with a variable number of arguments,\n// regardless of number or type of the arguments\nexport default function of() {\n    // allow to inherit this method by child classes\n    // require('./') fixes circular ref issue\n    const ParentClass = this || require('./');\n\n    const result = new ParentClass();\n    const newItems = Array(arguments.length);\n\n    nofn.forEach(arguments, (item, index) => {\n        newItems[index] = arguments[index];\n    });\n\n    return cheapRecreate(result, newItems);\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/array/of.js\n **/","import html from './html';\nimport display from './display';\nimport className from './classname';\nimport prop from './prop';\nimport attr from './attr';\nimport input from './input';\nimport output from './output';\nimport textarea from './textarea';\nimport select from './select';\nimport progress from './progress';\nimport text from './text';\nimport style from './style';\nimport dataset from './dataset';\n\nexport {\n    html,\n    display,\n    className,\n    prop,\n    attr,\n    input,\n    output,\n    textarea,\n    select,\n    progress,\n    text,\n    style,\n    dataset\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/binders/index.js\n **/","// returns a binder for innerHTML of an element\nexport default function html() {\n    return {\n        on: 'input', // the event name fires only in contenteditable mode\n        getValue() {\n            return this.innerHTML;\n        },\n        setValue(value) {\n            this.innerHTML = `${value}`;\n        }\n    };\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/binders/html.js\n **/","//  returns a binder to switch visibility of an element\nexport default function display(switcher = true) {\n    return {\n        on: null,\n        getValue() {\n            const value = this.style.display\n                || window.getComputedStyle(this).getPropertyValue('display');\n            const none = value === 'none';\n            return switcher ? !none : none;\n        },\n        setValue(value) {\n            const { style } = this;\n            if (switcher) {\n                style.display = value ? '' : 'none';\n            } else {\n                style.display = value ? 'none' : '';\n            }\n        }\n    };\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/binders/display.js\n **/","import {\n    toggle,\n    contains\n} from './_classlist.js';\n\n// returns a binder for className of an element\n// switcher makes possible to turn property value\nexport default function className(elementClassName, switcher = true) {\n    return {\n        on: null,\n        getValue() {\n            const value = contains(this, elementClassName);\n            return switcher ? value : !value;\n        },\n        setValue(value) {\n            toggle(this, elementClassName, switcher ? !!value : !value);\n        }\n    };\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/binders/classname.js\n **/","// @IE9\n\nlet add;\nlet remove;\nlet contains; // eslint-disable-line import/no-mutable-exports\n\n/* istanbul ignore else */\nif (window.document.createElement('div').classList) {\n    add = (node, name) => node.classList.add(name);\n    remove = (node, name) => node.classList.remove(name);\n    contains = (node, name) => node.classList.contains(name);\n} else {\n    add = (node, name) => {\n        const re = new RegExp(`(^|\\\\s)${name}(\\\\s|$)`, 'g');\n        if (!re.test(node.className)) {\n            node.className = `${node.className} ${name}`\n                .replace(/\\s+/g, ' ')\n                .replace(/(^ | $)/g, '');\n        }\n    };\n\n    remove = (node, name) => {\n        const re = new RegExp(`(^|\\\\s)${name}(\\\\s|$)`, 'g');\n        node.className = node.className\n            .replace(re, '$1')\n            .replace(/\\s+/g, ' ')\n            .replace(/(^ | $)/g, '');\n    };\n\n    contains = (node, name) => new RegExp(`(\\\\s|^)${name}(\\\\s|$)`).test(node.className);\n}\n\nconst toggle = (node, name, switcher) => {\n    if (switcher) {\n        add(node, name);\n    } else {\n        remove(node, name);\n    }\n};\n\nexport {\n    toggle,\n    contains\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/binders/_classlist.js\n **/","// returns a binder to change properties of an element\nexport default function prop(propertyName) {\n    return {\n        on: null,\n        getValue() {\n            return this[propertyName];\n        },\n        setValue(value) {\n            // in case when you're trying to set read-only property\n            try {\n                this[propertyName] = value;\n            } catch (e) {\n                // cannot set given property (eg tagName)\n            }\n        }\n    };\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/binders/prop.js\n **/","// returns a binder for element attribute\nexport default function attr(attributeName) {\n    return {\n        on: null,\n        getValue() {\n            return this.getAttribute(attributeName);\n        },\n        setValue(value) {\n            this.setAttribute(attributeName, value);\n        }\n    };\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/binders/attr.js\n **/","// returns a binder for textContent of an element\nexport default function text() {\n    return {\n        on: 'input', // the event name fires only in contenteditable mode\n        getValue() {\n            return this.textContent;\n        },\n        setValue(value) {\n            this.textContent = `${value}`;\n        }\n    };\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/binders/text.js\n **/","// returns a binder for style properties\nexport default function style(property) {\n    return {\n        on: null,\n        getValue() {\n            return this.style[property]\n                || window.getComputedStyle(this).getPropertyValue(property);\n        },\n        setValue(value) {\n            this.style[property] = value;\n        }\n    };\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/binders/style.js\n **/","// replace namesLikeThis with names-like-this\nconst replacer = u => `-${u.toLowerCase()}`;\nconst toDashed = name => `data-${name.replace(/([A-Z])/g, replacer)}`;\n\n//  returns a binder for dataset of an element\n// old browsers are also supported @IE9 @IE10\nexport default function dataset(prop) {\n    return {\n        on: null,\n        getValue() {\n            if (this.dataset) {\n                return this.dataset[prop];\n            }\n\n            return this.getAttribute(toDashed(prop));\n        },\n        setValue(value) {\n            if (this.dataset) {\n                this.dataset[prop] = value;\n            } else {\n                this.setAttribute(toDashed(prop), value);\n            }\n        }\n    };\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/binders/dataset.js\n **/","import on from '../on';\nimport once from '../once';\nimport onDebounce from '../ondebounce';\nimport off from '../off';\nimport trigger from '../trigger';\nimport calc from '../calc';\nimport bindNode from '../bindnode';\nimport unbindNode from '../unbindnode';\nimport bindOptionalNode from '../bindoptionalnode';\nimport bindSandbox from '../bindsandbox';\nimport parseBindings from '../parsebindings';\nimport select from '../select';\nimport selectAll from '../selectall';\nimport set from '../set';\nimport remove from '../remove';\nimport instantiate from '../instantiate';\nimport mediate from '../mediate';\n\n// the following methods can be used as static methods and as instance methods\nexport {\n    on,\n    once,\n    onDebounce,\n    off,\n    trigger,\n    calc,\n    bindNode,\n    unbindNode,\n    bindOptionalNode,\n    bindSandbox,\n    parseBindings,\n    select,\n    selectAll,\n    set,\n    remove,\n    instantiate,\n    mediate\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/matreshka/_universalmethods.js\n **/","import splitBySpaceReg from './_splitbyspaceregexp';\nimport checkObjectType from '../_helpers/checkobjecttype';\nimport matreshkaError from '../_helpers/matreshkaerror';\nimport addListener from './_addlistener';\nimport delegateListener from './_delegatelistener';\n\n// adds event listener\nexport default function on(object, givenNames, callback, triggerOnInit, context) {\n    if (typeof this === 'object' && this.isMatreshka) {\n        // when context is Matreshka instance, use this as an object and shift other args\n        /* eslint-disable no-param-reassign */\n        context = triggerOnInit;\n        triggerOnInit = callback;\n        callback = givenNames;\n        givenNames = object;\n        object = this;\n        /* eslint-enable no-param-reassign */\n    } else {\n        // throw error when object type is wrong\n        checkObjectType(object, 'on');\n    }\n\n    const isNamesVarArray = givenNames instanceof Array;\n\n    // allow to pass name-handler object\n    if (givenNames && typeof givenNames === 'object' && !isNamesVarArray) {\n        nofn.forOwn(givenNames, (namesObjCallback, namesObjName) =>\n            on(object, namesObjName, namesObjCallback, callback, triggerOnInit));\n        return object;\n    }\n\n    if (typeof givenNames !== 'string' && !isNamesVarArray) {\n        throw matreshkaError('on:names_type', { names: givenNames });\n    }\n\n    // split by spaces\n    // TODO: Array of names passed to on method is non-documented feature\n    const names = isNamesVarArray ? givenNames : givenNames.split(splitBySpaceReg);\n\n    // flip triggerOnInit and context when triggerOnInit is not boolean\n    if (typeof triggerOnInit !== 'boolean' && typeof triggerOnInit !== 'undefined') {\n        // eslint-disable-next-line no-param-reassign\n        [context, triggerOnInit] = [triggerOnInit, context];\n    }\n\n    nofn.forEach(names, (name) => {\n        const delegatedEventParts = name.split('@');\n\n        if (delegatedEventParts.length > 1) {\n            // if @ exists in event name then this is delegated event\n            const [path, delegatedName] = delegatedEventParts;\n            delegateListener(object, path, delegatedName, callback, context || object);\n        } else {\n            // if not, this is simple event\n            addListener(object, name, callback, context);\n        }\n    });\n\n    // call callback immediatelly if triggerOnInit is true\n    if (triggerOnInit === true) {\n        callback.call(context || object, { triggerOnInit });\n    }\n\n    return object;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/on/index.js\n **/","// allows to split by spaces not inclusing ones inside of brackers\nexport default /\\s+(?![^(]*\\))/g;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/on/_splitbyspaceregexp.js\n **/","import on from './on';\nimport checkObjectType from './_helpers/checkobjecttype';\nimport off from './off';\nimport apply from './_helpers/apply';\n\n// adds event listener which will be removed immediately after its first call\nexport default function once(object, names, givenCallback, context) {\n    if (typeof this === 'object' && this.isMatreshka) {\n        // when context is Matreshka instance, use this as an object and shift other args\n        /* eslint-disable no-param-reassign */\n        context = givenCallback;\n        givenCallback = names;\n        names = object;\n        object = this;\n        /* eslint-enable no-param-reassign */\n    } else {\n        // throw error when object type is wrong\n        checkObjectType(object, 'once');\n    }\n\n    const isNamesVarArray = names instanceof Array;\n\n    // allow to pass name-handler object\n    if (names && typeof names === 'object' && !isNamesVarArray) {\n        nofn.forOwn(names, (namesObjCallback, namesObjName) =>\n            once(object, namesObjName, namesObjCallback, givenCallback));\n        return object;\n    }\n\n    const callback = function onceCallback() {\n        apply(givenCallback, this, arguments);\n        // remove event listener after its call\n        off(object, names, onceCallback, context);\n    };\n\n    // allow to remove event listener py passing original callback to \"off\"\n    callback._callback = givenCallback;\n\n    return on(object, names, callback, context);\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/once.js\n **/","import splitBySpaceReg from '../on/_splitbyspaceregexp';\nimport checkObjectType from '../_helpers/checkobjecttype';\nimport defs from '../_core/defs';\nimport removeListener from './_removelistener';\nimport undelegateListener from './_undelegatelistener';\n\n// removes event listener\nexport default function off(object, givenNames, callback, context) {\n    if (typeof this === 'object' && this.isMatreshka) {\n        // when context is Matreshka instance, use this as an object and shift other args\n        /* eslint-disable no-param-reassign */\n        context = callback;\n        callback = givenNames;\n        givenNames = object;\n        object = this;\n        /* eslint-enable no-param-reassign */\n    } else {\n        // throw error when object type is wrong\n        checkObjectType(object, 'off');\n    }\n\n    const isNamesVarArray = givenNames instanceof Array;\n    const def = defs.get(object);\n\n    // allow to pass name-handler object\n    // TODO: Name-handler object passed to off method is non-documented feature\n    if (givenNames && typeof givenNames === 'object' && !isNamesVarArray) {\n        nofn.forOwn(givenNames, (namesObjCallback, namesObjName) =>\n            off(object, namesObjName, namesObjCallback, callback));\n        return object;\n    }\n\n    if (!givenNames && !callback && !context) {\n        def.events = {};\n        return object;\n    }\n\n    // TODO: Array of names passed to off method is non-documented feature\n    // split by spaces\n    const names = isNamesVarArray ? givenNames : givenNames.split(splitBySpaceReg);\n\n    nofn.forEach(names, (name) => {\n        const delegatedEventParts = name.split('@');\n        if (delegatedEventParts.length > 1) {\n            const [path, delegatedName] = delegatedEventParts;\n            undelegateListener(object, path, delegatedName, callback, context);\n        } else {\n            removeListener(object, name, callback, context);\n        }\n    });\n\n    return object;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/off/index.js\n **/","import on from './on';\nimport checkObjectType from './_helpers/checkobjecttype';\nimport debounce from './_helpers/debounce';\n\n// adds debounced event listener\nexport default function onDebounce(\n    object,\n    names,\n    givenCallback,\n    givenDelay,\n    triggerOnInit,\n    context\n) {\n    if (typeof this === 'object' && this.isMatreshka) {\n        // when context is Matreshka instance, use this as an object and shift other args\n        /* eslint-disable no-param-reassign */\n        context = triggerOnInit;\n        triggerOnInit = givenDelay;\n        givenDelay = givenCallback;\n        givenCallback = names;\n        names = object;\n        object = this;\n        /* eslint-enable no-param-reassign */\n    } else {\n        // throw error when object type is wrong\n        checkObjectType(object, 'onDebounce');\n    }\n\n    const isNamesVarArray = names instanceof Array;\n\n    // allow to pass name-handler object\n    if (names && typeof names === 'object' && !isNamesVarArray) {\n        nofn.forOwn(names, (namesObjCallback, namesObjName) => onDebounce(\n            object,\n            namesObjName,\n            namesObjCallback,\n            givenCallback,\n            givenDelay,\n            triggerOnInit\n        ));\n\n        return object;\n    }\n\n    const delay = typeof givenDelay === 'number' ? givenDelay : 0;\n\n    const callback = debounce(givenCallback, delay);\n\n    // allow to remove event listener py passing original callback to \"off\"\n    callback._callback = givenCallback;\n\n    return on(object, names, callback, triggerOnInit, context);\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/ondebounce.js\n **/","import domEventReg from '../on/_domeventregexp';\nimport checkObjectType from '../_helpers/checkobjecttype';\nimport matreshkaError from '../_helpers/matreshkaerror';\nimport splitBySpaceReg from '../on/_splitbyspaceregexp';\nimport defs from '../_core/defs';\nimport triggerOne from './_triggerone';\nimport triggerDomEvent from './_triggerdomevent';\n\n// triggers an event\nexport default function trigger(...args) {\n    let object;\n    let givenNames;\n    let triggerArgs;\n\n    if (typeof this === 'object' && this.isMatreshka) {\n        // when context is Matreshka instance, use this as an object and shift other args\n        [givenNames, ...triggerArgs] = args;\n        object = this;\n    } else {\n        [object, givenNames, ...triggerArgs] = args;\n        // throw error when object type is wrong\n        checkObjectType(object, 'trigger');\n    }\n    let names;\n\n    // allow to use strings only as event name\n    if (typeof givenNames === 'string') {\n        names = givenNames.split(splitBySpaceReg);\n    } else {\n        throw matreshkaError('trigger:names_type', { names: givenNames });\n    }\n\n    const def = defs.get(object);\n\n    // if no definition do nothing\n    if (!def) {\n        return object;\n    }\n\n    const { events: allEvents } = def;\n\n    if (!allEvents) {\n        return object;\n    }\n\n    nofn.forEach(names, (name) => {\n        const domEvtExecResult = domEventReg.exec(name);\n\n        if (domEvtExecResult) {\n            // if EVT::KEY(SELECTOR) ia passed as event name then trigger DOM event\n            const [, eventName, key = 'sandbox', selector] = domEvtExecResult;\n            triggerDomEvent(object, key, eventName, selector, triggerArgs);\n        } else {\n            // trigger ordinary event\n            triggerOne(object, name, triggerArgs);\n        }\n    });\n\n    return object;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/trigger/index.js\n **/","import triggerOneDOMEvent from './_triggeronedomevent';\nimport defs from '../_core/defs';\n\n// triggers DOM event on bound nodes\nexport default function triggerDOMEvent(object, key, eventName, selector, triggerArgs) {\n    const def = defs.get(object);\n\n    if (!def) {\n        return;\n    }\n\n    const { props } = def;\n    const propDef = props[key];\n\n    if (!propDef) {\n        return;\n    }\n\n    const { bindings } = propDef;\n\n    if (!bindings) {\n        return;\n    }\n\n    nofn.forEach(bindings, ({ node }) => {\n        if (selector) {\n            // if selector is given trigger an event on all node descendants\n            const descendants = node.querySelectorAll(selector);\n            nofn.forEach(descendants, (descendant) => {\n                triggerOneDOMEvent({\n                    node: descendant,\n                    eventName,\n                    triggerArgs\n                });\n            });\n        } else {\n            // trigger an event for single node\n            triggerOneDOMEvent({\n                node,\n                eventName,\n                triggerArgs\n            });\n        }\n    });\n\n    return;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/trigger/_triggerdomevent.js\n **/","// triggers given DOM event on given node\nexport default function triggerOneDOMEvent({\n    node,\n    eventName,\n    triggerArgs\n}) {\n    const { document, Event } = window;\n    let event;\n\n    // polyfill for older browsers\n    if (document.createEvent) {\n        /* istanbul ignore next */\n        event = document.createEvent('Event');\n        event.initEvent(eventName, true, true);\n    } else if (typeof Event !== 'undefined') {\n        event = new Event(eventName, {\n            bubbles: true,\n            cancelable: true\n        });\n    }\n\n    // matreshkaTriggerArgs will be used in a handler created by addDOMListener\n    event.matreshkaTriggerArgs = triggerArgs;\n\n    node.dispatchEvent(event);\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/trigger/_triggeronedomevent.js\n **/","import bindNode from './bindnode';\nimport apply from './_helpers/apply';\n\n// TODO: Adds a binding, not throwing an error when a node is missing\nexport default function bindOptionalNode() {\n    // this hack allows to keep bindOptionalNode as compact as possible\n    // and doesn't require to flip args and support all bindNode variations\n    bindNode.temporaryOptionalFlag = true;\n    return apply(bindNode, this, arguments);\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/bindoptionalnode.js\n **/","import bindNode from './bindnode';\nimport unbindNode from './unbindnode';\nimport checkObjectType from './_helpers/checkobjecttype';\n\n// binds or rebinds sandbox node\nexport default function bindSandbox(object, node, evt) {\n    if (typeof this === 'object' && this.isMatreshka) {\n        // when context is Matreshka instance, use this as an object and shift other args\n        /* eslint-disable no-param-reassign */\n        evt = node;\n        node = object;\n        object = this;\n        /* eslint-enable no-param-reassign */\n    } else {\n        // throw error when object type is wrong\n        checkObjectType(object, 'bindSandbox');\n    }\n\n    unbindNode(object, 'sandbox', null, evt);\n    return bindNode(object, 'sandbox', node, null, evt);\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/bindsandbox.js\n **/","import defs from './_core/defs';\nimport selectNodes from './bindnode/_selectnodes';\nimport checkObjectType from './_helpers/checkobjecttype';\n\nconst customSelectorTestReg = /:sandbox|:bound\\(([^(]*)\\)/;\n\n// selects one node based on given selector\nexport default function select(object, selector) {\n    if (typeof this === 'object' && this.isMatreshka) {\n        // when context is Matreshka instance, use this as an object and shift other args\n        /* eslint-disable no-param-reassign */\n        selector = object;\n        object = this;\n        /* eslint-enable no-param-reassign */\n    } else {\n        // throw error when object type is wrong\n        checkObjectType(object, 'select');\n    }\n\n    // the selector includes \"custom\" things like :sandbox or :bound(KEY)\n    if (customSelectorTestReg.test(selector)) {\n        return selectNodes(object, selector)[0] || null;\n    }\n    const def = defs.get(object);\n\n    if (!def || typeof selector !== 'string') {\n        return null;\n    }\n\n    const propDef = def.props.sandbox;\n\n    if (!propDef) {\n        return null;\n    }\n\n    const { bindings } = propDef;\n\n    if (bindings) {\n        // iterate over all bound nodes trying to find a descendant matched given selector\n        for (let i = 0; i < bindings.length; i++) {\n            const { node } = bindings[i];\n            const selected = node.querySelector(selector);\n\n            if (selected) {\n                return selected;\n            }\n        }\n    }\n\n    return null;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/select.js\n **/","import defs from './_core/defs';\nimport dom from './_dom';\nimport selectNodes from './bindnode/_selectnodes';\nimport toArray from './_helpers/toarray';\nimport checkObjectType from './_helpers/checkobjecttype';\n\nconst customSelectorTestReg = /:sandbox|:bound\\(([^(]*)\\)/;\n\n// selects nodes based on given selector\nexport default function selectAll(object, selector) {\n    if (typeof this === 'object' && this.isMatreshka) {\n        // when context is Matreshka instance, use this as an object and shift other args\n        /* eslint-disable no-param-reassign */\n        selector = object;\n        object = this;\n        /* eslint-enable no-param-reassign */\n    } else {\n        // throw error when object type is wrong\n        checkObjectType(object, 'selectAll or $');\n    }\n\n    // the selector includes \"custom\" things like :sandbox or :bound(KEY)\n    if (customSelectorTestReg.test(selector)) {\n        return selectNodes(object, selector);\n    }\n\n    const def = defs.get(object);\n    let result = dom.$();\n\n    if (!def || typeof selector !== 'string') {\n        return result;\n    }\n\n    const propDef = def.props.sandbox;\n\n    if (!propDef) {\n        return result;\n    }\n\n    const { bindings } = propDef;\n\n    if (bindings) {\n        // iterate over all bindings and add found nodes\n        nofn.forEach(bindings, ({ node }) => {\n            const selected = node.querySelectorAll(selector);\n            result = result.add(toArray(selected));\n        });\n    }\n\n    return result;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/selectall.js\n **/","import unbindNode from './unbindnode';\nimport triggerOne from './trigger/_triggerone';\nimport removeListener from './off/_removelistener';\nimport defs from './_core/defs';\nimport checkObjectType from './_helpers/checkobjecttype';\nimport matreshkaError from './_helpers/matreshkaerror';\n\n// removes a property, its bindings and its events\n// TODO: remove function does not correctly removes delegated events, bindings, tree listeners etc\nexport default function remove(object, givenKey, eventOptions) {\n    if (typeof this === 'object' && this.isMatreshka) {\n        // when context is Matreshka instance, use this as an object and shift other args\n        /* eslint-disable no-param-reassign */\n        eventOptions = givenKey;\n        givenKey = object;\n        object = this;\n        /* eslint-enable no-param-reassign */\n    } else {\n        // throw error when object type is wrong\n        checkObjectType(object, 'remove');\n    }\n\n    eventOptions = eventOptions || {}; // eslint-disable-line no-param-reassign\n    const def = defs.get(object);\n    const { silent } = eventOptions;\n    // allow to pass single key or an array of keys\n    const keys = givenKey instanceof Array ? givenKey : [givenKey];\n\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n\n        // if non-string is passed as a key\n        if (typeof key !== 'string') {\n            throw matreshkaError('remove:key_type', { key });\n        }\n\n        const props = def && def.props;\n        const propDef = props && props[key];\n\n        // if no object definition then simply delete the property\n        if (!propDef) {\n            delete object[key];\n            continue;\n        }\n\n        const { value } = propDef;\n\n        // remove all bindings\n        unbindNode(object, key);\n\n        // TODO: Manual listing of event prefixes may cause problems in future\n        const removeEventPrefies = [\n            '_change:deps',\n            '_change:bindings',\n            '_change:delegated',\n            '_change:tree',\n            'change',\n            'beforechange',\n            'bind',\n            'unbind'\n        ];\n\n        // remove all events\n        nofn.forEach(removeEventPrefies, prefix => removeListener(object, `${prefix}:${key}`));\n\n        // delete property definition\n        delete props[key];\n\n        // delete the property itself\n        delete object[key];\n\n        const extendedEventOptions = {\n            key,\n            value,\n            ...eventOptions\n        };\n\n        // trigger delegated events logic removal for asterisk events (*.*.*@foo)\n        triggerOne(object, '_delete:delegated', extendedEventOptions);\n\n        // fire events if \"silent\" is not true\n        if (!silent) {\n            triggerOne(object, 'delete', extendedEventOptions);\n            triggerOne(object, `delete:${key}`, extendedEventOptions);\n        }\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/remove.js\n **/","import checkObjectType from './_helpers/checkobjecttype';\nimport mediate from './mediate';\n\n// the function is used when no update function is given\nfunction defaultUpdateFunction(instance, data) {\n    if (instance.isMatreshkaArray) {\n        instance.recreate(data);\n    } else if (instance.isMatreshkaObject) {\n        instance.setData(data, { replaceData: true });\n    } else {\n        // for other objects just extend them with given data\n        nofn.assign(instance, data);\n    }\n}\n\n// returns mediator which controls assignments\nfunction createInstantiateMediator({\n    UsedClass,\n    updateFunction\n}) {\n    return function mediator(value, previousValue, key, object) {\n        if (previousValue instanceof UsedClass) {\n            updateFunction.call(object, previousValue, value, key);\n            return previousValue;\n        }\n\n        return new UsedClass(value, object, key);\n    };\n}\n\n// creates an instance of given class as property value\n// and updates an instance on new value assignment instead of actual assignment\nexport default function instantiate(object, givenKeys, UsedClass, givenUpdateFunction) {\n    if (typeof this === 'object' && this.isMatreshka) {\n        // when context is Matreshka instance, use this as an object and shift other args\n        /* eslint-disable no-param-reassign */\n        givenUpdateFunction = UsedClass;\n        UsedClass = givenKeys;\n        givenKeys = object;\n        object = this;\n        /* eslint-enable no-param-reassign */\n    } else {\n        // throw error when object type is wrong\n        checkObjectType(object, 'instantiate');\n    }\n\n    const isKeysArray = givenKeys instanceof Array;\n\n    // allow to use key-class object\n    if (typeof givenKeys === 'object' && !isKeysArray) {\n        nofn.forOwn(givenKeys, (objVal, objKey) => instantiate(object, objKey, objVal, UsedClass));\n        return object;\n    }\n\n    // allow to use both single key and an array of keys\n    const keys = isKeysArray ? givenKeys : [givenKeys];\n    const updateFunction = givenUpdateFunction || defaultUpdateFunction;\n    const mediator = createInstantiateMediator({\n        UsedClass,\n        updateFunction\n    });\n\n    // iterate over all keys and define created mediator for all of them\n    nofn.forEach(keys, key => mediate(object, key, mediator));\n\n    return object;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/instantiate.js\n **/","import initMK from './_core/init';\nimport defineProp from './_core/defineprop';\nimport checkObjectType from './_helpers/checkobjecttype';\nimport set from './set';\nimport matreshkaError from './_helpers/matreshkaerror';\n\n// creates property mediator\nfunction createMediator({\n    object,\n    propDef,\n    key,\n    mediator\n}) {\n    return function propMediator(value) {\n        // args: value, previousValue, key, object itself\n        return mediator.call(object, value, propDef.value, key, object);\n    };\n}\n\n// transforms property value on its changing\nexport default function mediate(object, givenKeys, mediator) {\n    if (typeof this === 'object' && this.isMatreshka) {\n        // when context is Matreshka instance, use this as an object and shift other args\n        /* eslint-disable no-param-reassign */\n        mediator = givenKeys;\n        givenKeys = object;\n        object = this;\n        /* eslint-enable no-param-reassign */\n    } else {\n        // throw error when object type is wrong\n        checkObjectType(object, 'mediate');\n    }\n\n    const isKeysArray = givenKeys instanceof Array;\n\n    // allow to use key-mediator object as another method variation\n    if (typeof givenKeys === 'object' && !isKeysArray) {\n        nofn.forOwn(givenKeys, (objVal, objKey) => mediate(object, objKey, objVal));\n        return object;\n    }\n\n    initMK(object);\n\n    // allow to use both single key and an array of keys\n    const keys = isKeysArray ? givenKeys : [givenKeys];\n\n    nofn.forEach(keys, (key) => {\n        // if non-string is passed as a key\n        if (typeof key !== 'string') {\n            throw matreshkaError('mediate:key_type', { key });\n        }\n\n        const propDef = defineProp(object, key);\n\n        const propMediator = propDef.mediator = createMediator({\n            object,\n            propDef,\n            key,\n            mediator\n        });\n\n        // set new value\n        set(object, key, propMediator(propDef.value), {\n            fromMediator: true\n        });\n    });\n\n    return object;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/mediate.js\n **/","import dom from './_dom';\nimport mq from './_dom/mq';\n\n// forces Matrsahka to use jQuery-like DOM library for internal stuff\nexport default function useDOMLibrary(library) {\n    if (typeof library === 'function') {\n        dom.$ = library;\n    } else {\n        dom.$ = mq;\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/usedomlibrary.js\n **/","import * as universalMethods from './_universalmethods';\nimport assign from '../_helpers/assign';\nimport _afterInit from './_afterinit';\n\nexport default assign({\n    _afterInit,\n    isMatreshka: true,\n    $: universalMethods.selectAll\n}, universalMethods);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/matreshka/_prototype.js\n **/"],"sourceRoot":""}