/**
@class Matreshka
@lang ru
@version 0.3
@author Акндрей Губанов <a@odessite.com.ua>
@license {@link https://raw.github.com/finom/matreshka/master/LICENSE MIT}
Version 2.0, January 2004
@alias MK
@see {@link Class}
@classdesc The class Matreshka is a core of the Matreshka.js framework which is inherited by {@link Matreshka.Array}, {@link Matreshka.Object} and every class of the application you create. It contains the main functionality of the framework, among which there are some very useful functions, such as {@link Matreshka#mediate mediators}, {@link Matreshka#linkProps dependencies}, {@link Matreshka#bindNode binders to DOM}, {@link Matreshka#on an event engine}, etc. The inheritance of this class, the same as the inheritance of any other class, is carried out with the help of the {@link Class} function. 

As a rule, this class, (like {@link Matreshka.Array} and {@link Matreshka.Object}), isn't used directly. Instead, it is inherited by the classes that you create. Therefore, the examples to the properties and methods in this documentation, as a rule, will be given with the use of the keyword ``this``.
@example <caption>Creating of the instance</caption>
var mk = new Matreshka;
@example <caption>In short: MK instead of Matreshka</caption>
var mk = new MK;
@example <caption>Inheritance</caption>
var MyClass = Class({
	'extends': Matreshka,
	constructor: function() {
		this.sayHello();
	},
	sayHello: function() {
		alert("Hello World!");
	}
});
@example <caption>Matreshka uses prototypes for implementing the inheritance. The {@link Class} function just brings in some syntactic sugar and adds some hacks for the Internet Explorer 8. That's why you can use any other way of the inheritance you like, for example, using classes from ECMAScript 2015</caption>
class MyClass extends Matreshka {
	constructor() {
		this.sayHello();
	}
	sayHello() {
		alert("Hello World!");
	}
}
*/


/**
@member {boolean} Matreshka#isMK
@summary ``isMK`` always equals ``true``. This property is used for defining whether  the object is an instance of the {@link Matreshka} class
@example
alert(object.isMK);
*/


/** 
@method Matreshka#on
@summary adds the event handler
@desc The {@link Matreshka#on} method adds the event handler for the instance of the ``Matreshka`` class. Refer to the complete list of possible events with the description here: {@link #typedef-eventNames}.
@see {@link Matreshka#onDebounce}
@see {@link Matreshka#once}
@see {@link Matreshka#off}
@see {@link Matreshka#trigger}
@param {eventNames} names - The event name or some names which are separated by a space (for example, ``"change:x ajaxcomplete change:y"``)
@param {eventHandler} callback - The function which is caused by the event
@param {boolean} [triggerOnInit=false] - If the ``triggerOnInit`` argument  equals ``true``, the handler will be  called immediately after the initialization.
@param {object} [context] - The context of the handler. In other words, ``this`` when called ``callback``
@returns {matreshka} self
@example
this.on( 'foo', function() {
	alert( 'customEvent is fired' );
});
this.trigger( 'foo' );
@example <caption>Passing the context</caption>
this.on( 'foo', function() {
	alert( this.a ); // 5
}, { a: 5 } );
this.trigger( 'foo', 'Hello world' );
@example <caption>Calling the handler immediately after the initialization</caption>
//Displays "bar" at once and waits for the generation of the event "foo"
this.on( 'foo', function() {
	alert( 'bar' );
}, true );
*/  


/** 
@method Matreshka#onDebounce
@summary adds the event handler which is called only once during a definite period of time
@desc The method allows to add the event handler to the instance of the {@link Matreshka} class, debouncing the handler. The function can be called only once during a definite period of time. As to the rest the method works the same as {@link Matreshka#on}.
@see {@link Matreshka#on}
@see {@link Matreshka#once}
@see {@link Matreshka#off}
@see {@link Matreshka#trigger}
@see {@link Matreshka.debounce}
@see {@link http://habrahabr.ru/post/60957/ The article on Habr micropattern debounce}
@param {eventNames} names - The event name or some names which are separated by a space (for example, ``"change:x ajaxcomplete change:y"``).
@param {eventHandler} callback - The function which is caused by the event
@param {number} [debounceDelay=0] - The delay
@param {boolean} [triggerOnInit=false] - If the ``triggerOnInit`` equals ``true``, the handler will be  called immediately after the initialization.
@param {object} [context] - The context of the handler. In other words, ``this`` when called ``callback``
@returns {matreshka} self
@example
this.onDebounce( 'change:x', function() {
	alert( 'x = ' + this.x ); // x = 100
}, 300 );

this.x = 1;

for( var i = 0; i < 100; i++ ) {
	this.x++;
}
*/ 


/** 
@method Matreshka#once
@summary adds the event handler which is called only once
@desc The method works the same as {@link Matreshka#on} but the passing handler can be called only once. Note  the method lacks the <code>triggerOnInit</code> argument.
@see {@link Matreshka#on}
@see {@link Matreshka#off}
@see {@link Matreshka#onDebounce}
@see {@link Matreshka#trigger}
@param {eventNames} names - The event name or some names which are separated by a space (for example, <code>"change:x ajaxcomplete change:y"</code>)
@param {eventHandler} callback - The function which is caused by the event
@param {object} [context] - The context of the handler
@returns {matreshka} self
@example
this.x = 1;

this.once( 'change:x', function() {
	alert( 'x is changed' );
});

this.x = 2; // displays 'x is changed'

this.x = 3; // does nothing
*/


/**
@method Matreshka#off
@summary deletes the event handler
@desc It deletes the  handler which has been created before. All the three arguments are optional. You can delete both all the events (without passing a single argument) and separate ones (having passed only the event name, the event name and the handler, the event name and the handler and the context)
@see {@link Matreshka#on}
@see {@link Matreshka#once}
@see {@link Matreshka#onDebounce}
@see {@link Matreshka#trigger}
@param {eventNames} [names] - The list of the event names which is separated by spaces (for example, ``"change:x ajaxcomplete change:y"``)
@param {eventHandler} [callback] - The function-handler
@param {object} [context] - The context
@returns {matreshka} self
@example
this.off( 'change:x bind' );
@example <caption>The deletion of all events</caption>
this.off();
@example <caption>The deletion of the event with the definite handler</caption>
var handler = function() { 
	//...
}
this.on( 'change:x', handler );
this.off( 'change:x', handler );
@example <caption>The deletion of the event with the definite context</caption>
var object = {};
this.on( 'change:x', handler, object );
this.off( 'change:x', handler, object );
*/


/**
@method Matreshka#trigger
@summary generates an event
@desc After adding the event handlers with the help of the {@link Matreshka#on}, {@link Matreshka#onDebounce} or {@link Matreshka#once}, method , the event can be generated manually using this method.
@see {@link Matreshka#on}
@see {@link Matreshka#once}
@see {@link Matreshka#onDebounce}
@see {@link Matreshka#off}
@param {eventNames} [names] - The event name or some names which are separated by a space
@param {...*} [arg] - The arguments which will be passed to the handlers
@returns {matreshka} self
@example
this.on( 'jigurda ohyeah', function( a, b, c ) {
	alert( a, b, c );
});
this.trigger( 'ohyeah', 1, 2, 3 ); // alerts 6
*/


/**
@method Matreshka#bindNode
@fires bind
@fires bind:KEY
@summary binds the property of the object with the HTML element
@desc {@link Matreshka#bindNode} is the only method of the {@link Matreshka}, class  which is responsible for changing DOM. It creates a bridge between the value of the property and the state of the HTML element on the page: from a simple input to a complicated widget (the complexity of elements is unlimited). ``bindNode``can be truly regarded as the main method of the framework. After binding the property of the instance and the HTML element, it isn't necessary to monitor the synchronization of the data and the representation.

For two-way binding of the element and the value of the property, three arguments: **a property name** (key), **HTML element** (or a selector) and a **binding rule** are passed to the method.In its turn, the binder is an ordinary object and it can have the following properties: ``on``, ``getValue``, ``setValue``, ``initialize`` (Read more {@link #typedef-binder}). All the four properties are optional. It also allows to declare one-way bindings.

> The ``bindNode`` method  supports the "many to many" bindings . Several elements can be bound to one property and several properties  can be bound to one element, including ones from different instances of various classes.

```js
this.bindNode( 'myKey', '.my-element'. {
	on: 'click',
	getValue: function() { ... },
	setValue: function() { ... }
});
```

For example, you want to bind the property of the object to the ``input[type="checkbox"]`` element:
```js
this.bindNode( 'myKey', '.my-checkbox'. {
	// when is the element state changed?
	// - after the event 'click'
	on: 'click',
	// how to extract the element state?
	// - return the value 'checked'
	getValue: function() {
		return this.checked;
	},
	// how to set the element state?
	// - set the value 'checked'
	setValue: function( v ) {
		this.checked = !!v;
	}
});
```

After the declaration of the binding, you can set the value of the object property in your most habitual way and the element (in this case, a checkbox) will change its state in no time. After clicking on the checkbox, the property value will be changed to the corresponding one as well.
```js
// sets checked = false
this.myKey = true;
```

> If the property value of the class instance is not given, after the binding Matreshka will try to extract its value from the HTML node using ``getValue``. This behavior can be cancelled by passing the ``assignDefaultValue: false`` property to the object of the event.
```js
this.bindNode( 'myKey', '.my-element', binder, {
	assignDefaultValue: false
});
```

More complicated example: binding the object property to the  jQuery UI widget
```html
<div class="my-slider"></div>
```

```js
this.bindNode( 'myKey', '.my-slider', {
	// when is the element state changed?
	// - after the event 'slide'
	on: 'slide',
	// how to extract the element state?
	// - return the value of the 'value' widget
	getValue: function() {
		return $( this ).slider( 'option', 'value' );
	},
	// how to set the element state?
	// - set the 'value' value
	setValue: function( v ) {
		$( this ).slider( 'option', 'value', v );
	},
	// how to initialize the widget?
	// you can initialize the slider in any way,
	// but initialize provides some syntactic sugar
	initialize: function() {
		$( this ).slider({ min: 0, max: 100 });
	}
});
```

```js
// will set the slider value 42
this.myKey = 42;
```

It looks easy but you may ask a question: "What should I do to avoid writing these rules every time?". The question is absolutely correct. Indeed, there can be a lot of elements of the same type on the page: text fields, drop down menus, new fields from the specification of HTML5 as well as third party widgets (see the example above).

As observed in the documentation, the third argument is not obligatory for  the ones of the {@link Matreshka#bindNode} method (see below). This problem is solved by the {@link Matreshka.defaultBinders} array which contains functions checking an HTML element against a set of rules. You get an opportunity to reduce your code a great deal, putting  binding rules into a separate part of your code and to use a syntax for binding without  the third argument:
```js
this.bindNode( 'myKey', '.my-element' );
```
How to do it? You should add the function checking  your element against a set of rules to the beginning of the {@link Matreshka.defaultBinders} array. The example below can be used as a template for creating your default binder.
```js
// add the binder to the collection of binders
// it is necessary to keep the possibility of overriding
Matreshka.binders.checkbox = function() {
	return {
		on: 'click',
		getValue: function() {
			return this.checked;
		},
		setValue: function( v ) {
			this.checked = !!v;
		}
	}
};

// the shift method adds the function to the beginning of the array Matreshka.defaultBinders
Matreshka.defaultBinders.shift( function( node ) {
	// check if the element is a checkbox
	if( node.tagName == 'INPUT' && node.type == 'checkbox' ) {
		// if checking is OK, return a new binder
		return Matreshka.binders.checkbox();
	}
});
```
```js
this.bindNode( 'myKey', '.my-checkbox' );
this.myKey = true;
```

What should you do if you need to pass  arguments for initializing some plug-in or a widget? It is a piece of cake: you can do with adding the binder to the {@link Matreshka.binders}, collection  without creating a function for {@link Matreshka.defaultBinders}.
```js
Matreshka.binders.uiSlider = function( min, max ) {
	return {
		on: 'slide',
		getValue: function() {
			return $( this ).slider( 'option', 'value' );
		},
		setValue: function( v ) {
			$( this ).slider( 'option', 'value', v );
		},
		initialize: function() {
			$( this ).slider({ min: min, max: max });
		}
	}
};
```
```js
this.bindNode( 'myKey1', '.my-slider1', Matreshka.binders.uiSlider( 0, 100 ) );
this.bindNode( 'myKey2', '.my-slider2', Matreshka.binders.uiSlider( 1, 1000 ) );
this.myKey1 = 42;
this.myKey2 = 999;
```

{@link Matreshka.defaultBinders} OOB, starting with the version 0.3, has a support for **all forms** of HTML elements without any exception: ``select`` (including ``multiple``), ``textarea``, ``input`` (including all types from the specification of HTML5: ``text``, ``checkbox``, ``radio``, ``range``, ``number``, ``date``, ``search``, ``time``, ``datetime``, ``datetime-local``, ``color`` and others). ЭThat means it is not necessary to designate a binder for standard elements.
```html
<input type="color" class="my-color-input">
```
```js
this.bindNode( 'myColor', '.my-color-input' );
this.myColor = '#66bb6a';
```


Besides, after the binding, a new non-standard ``:bound(KEY)`` CSS selector is available for you.
```js
this.bindNode( 'myKey', '.my-element' );

// will find the element '.my-inner-element' inside '.my-element'
this.bindNode( 'myAnotherKey', ':bound(myKey) .my-inner-element' );
```

And the syntax of possible event names is extended:
```js
this.bindNode( 'myKey', '.my-element' );

// will catch the click on the .my-element element
this.on( 'click::myKey', functinon() { ... });

// will catch the click on the .my-inner-element element
this.on( 'click::myKey(.my-inner-element)', functinon() { ... });
```


#### The creation of the sandbox
{@link Matreshka#bindNode} can associate a class instance with the "main" HTML element on the page creating the so-called **sandbox**. It is necessary to limit the instance influence on HTML elements contained in another sandbox (i. e. in another HTML element). A special property ``'sandbox'`` is used for binding the sandbox.
```html
<div class="my-sandbox">
	<!-- your HTML code -->
</div>
```

```js
this.bindNode( 'sandbox', '.my-sandbox' );
```

The definition of the sandbox adds lots of conveniences for a programmer. For example:
+ allows to use the {@link Matreshka#select} and {@link Matreshka#$} methods
+ allows to use the {@link Matreshka#bound} and {@link Matreshka#$bound} methods without specifying an argument
+ adds a new ``:sandbox`` selector in the {@link Matreshka#bindNode}, {@link Matreshka#select}, {@link Matreshka#$} methods and others
+ adds syntactic sugar for the delegated DOM events in the {@link Matreshka#on} method


```js
// declare a sandbox
this.bindNode( 'sandbox', '.my-sandbox' );

// .my-element is being searched for in the sandbox
this.bindNode( 'myKey', ':sandbox .my-element' );

// it is not required to specify a key for the delegated events inside the sandbox
this.on( 'click::(.my-button)', function() { ... } );

//  will put a sandbox element into the console
console.log( this.$bound() );

// will put the  .inner-node element which is inside the sandbox into the console
console.log( this.$( '.inner-node' ) );
```



@see {@link Matreshka#unbindNode}
@see {@link Matreshka#bindOptionalNode}
@see {@link Matreshka#$}
@see {@link Matreshka#$bound}
@see {@link Matreshka.binders}
@see {@link Matreshka.defaultBinders}


@param {string|matreshka} key - A key (a property name)
@param {string|node|$nodes} node - an HTML element which must be with the instance property
@param {binder} [binder] - The binder containing the following properties: ``on`` - which event must happen to an HTML element, informing that a user has changed something (for example, ``keyup`` or ``click``), ``getValue`` -  how to get the value from an HTML element, ``setValue`` - how to set a new value to the element and ``initialize`` - a function which is executed once after the initialization of the binding. You can get more detailed information about binders in their documentation: see {@link #typedef-binder}. 
@param {eventOptions} [eventOptions] - The event object which the ``"silent"`` ((without generating the ``"bind"`` and ``"bind:KEY"`` events), ``"assignDefaultValue"`` or other data can be passed to.
@returns {matreshka} self

@example <caption>A custom checkbox. This example demonstrates the creation of the custom element whose ``"checked"`` class is changed after clicking on it.</caption>
this.bindNode( 'myKey', '.custom-checkbox', {
	on: 'click',
	getValue: function() {
		return $( this ).hasClass( 'checked' );
	},
	setValue: function( v ) {
		$( this ).toggleClass( 'checked', !!v );
	},
	// initialize the element behavior
	// the presence of the class 'checked' is changed after clicking on the element
	initialize: function() {
		$( this ).on( 'click', function() {
			$( this ).toggleClass( 'checked' );
		});
	}
});

@example <caption>A custom checkbox 2. This example is the same as the previous one but it uses {@link Matreshka#defaultBinders}, and checks the element if the ``custom-checkbox``. class is present. If checking is OK, it returns the binder.</caption>
// add the binder to the collection of binders
Matreshka.binders.customCheckbox = function() {
	return {
		on: 'click',
		getValue: function() {
			return $( this ).hasClass( 'checked' );
		},
		setValue: function( v ) {
			$( this ).toggleClass( 'checked', !!v );
		},
		initialize: function() {
			$( this ).on( 'click', function() {
				$( this ).toggleClass( 'checked' );
			});
		}
	}
};

MK.defaultBinders.shift( function( element ) {
	// check if the element has the "custom-checkbox" class
	if( $( element ).hasClass( 'custom-checkbox' ) ) {
		// if checking is OK,  return a new binder
		return Matreshka.binders.customCheckbox();
	}
});

this.bindNode( 'myKey', '.my-custom-checkbox' );

@example <caption>The ``"bind"`` event which is generated after binding any property and HTML node</caption>
this.on( 'bind', function() { alert( 'ok!' ); });
this.bindNode( 'myKey', '.my-element' ); // alerts "ok!"

@example <caption>The ``"bind:KEY"`` event which is generated after binding the specific property and HTML node</caption>
this.on( 'bind:myKey', function() { alert( 'ok!' ); });
this.bindNode( 'myKey', '.my-element' ); // alerts "ok!"

@example <caption>The DOM event overriding for the default binder. For example, we want to bind ``input[type="text"]`` to the property. On default,  the standard binder contains the ``"on"`` property with the ``"keydown paste"`` value for this element. It means that the value of the instance property and the element state will be synchronized when a user releases a key of the keyboard or pastes from clipboard. In case if you want synchronization to be performed after the ``"blur"`` DOM event ,  you will have to pass the object containing the only ``"on"`` property as the third argument. This object will join a default binder, having retained ``getValue`` and ``setValue`` values at the same time.</caption>
this.bindNode( 'myKey', '.my-input', { on: "blur" });


@example <caption>If the element is not found, the ``"Bound element is missing"`` exception is thrown. In order to avoid the mistake, use the {@link Matreshka#bindOptionalNode} method</caption>
var $el = $();
this.bindNode( 'x', $el ); // an error because $el is empty

@example <caption>Synchronization of the property value and HTML contents of the element</caption>
this.bindNode( 'myKey', '.my-element', {
	setValue: function( v ) {
		this.innerHTML = v;
	}
});

// it can be done easier
this.bindNode( 'myKey', '.my-element', MK.binders.innerHTML() );
*/


/**
@method Matreshka#bindNode
@variation 2
@summary alternative syntax: "key-element" pairs
@desc In the {@link Matreshka#bindNode} method the object with the  key-element pairs can be passed to avoid the multiple invocation of the method and reduce the code.

@param {object} keyElementPairs - (see the example)
@param {binder} [binder] - (see above)
@param {eventOptions} [eventOptions] - (see above)

@example
this.bindNode({
	myKey1: '.custom-checkbox',
	myKey2: 'textarea'
});
*/


/**
@method Matreshka#bindNode
@variation 3
@summary alternative syntax: "set of arguments"
@desc Another syntax for the {@link Matreshka#bindNode} method. This way may seem unattractive but sometimes you have need of binding lots of elements to different binders  at one sitting. With such a syntax you can assign definite binders to some variable and then easily delete all at once using {@link Matreshka#unbindNode}.

@param {array} setOfArguments - The array of argument arrays (see the example)
@param {eventOptions} [eventOptions] - (see above)

@example
this.bindNode([
	[{
		myKey1: '.my-element1',
		myKey2: '.my-element2'
	}],
	[{
		myKey3: '.my-element3',
		myKey4: '.my-element4'
	}, {
		on: 'click',
		getValue: function() { ... },
		setValue: function() { ... }
	}],
	[{
		myKey5: '.my-element5',
		myKey6: '.my-element6'
	}, {
		on: 'somethingelse',
		getValue: function() { ... },
		setValue: function() { ... }
	}]
]);
*/

/**
@method Matreshka#bindOptionalNode
@since 0.3
@summary works just the same as {@link Matreshka#bindNode} but it does not throw an exception if the ``node`` argument  is an empty array, ``undefined`` or non-existent.
@see {@link Matreshka#bindNode}
@example
this.bindOptionalNode( 'myKey', '.my-element' );
*/

/**
@method Matreshka#unbindNode
@fires unbind
@fires unbind:KEY
@summary breaks the binding between the property and the HTML element.
@desc Using this method you can delete the binding between the property and the HTML element, which has been added recently and no longer necessary.
@param {string|null} The key or a list of keys which are separated by spaces. If you pass null instead of the key, all bindings for the given instance will be deleted
@param {string|node|$nodes} [node] - an HTML element that is not dealt with  by the property any more
@param {eventOptions} [eventOptions] -  The event object where some data for the handler or the ``"silent"`` key which  disables generating the events ``"unbind"`` and ``"unbind:KEY"`` can be passed to.
@returns {matreshka} self
@example
this.bindNode( 'myKey', '.my-element' );

// changes the property value and the state of the HTML element
this.myKey = true; 

this.unbindNode( 'myKey', '.my-element' );

// only the property value is being changed now
this.myKey = false; 
*/


/**
@method Matreshka#unbindNode
@variation 2
@summary alternative syntax {@link Matreshka#unbindNode} "key-element" for {@link Matreshka#unbindNode}
@see {@link Matreshka#bindNode(2)}
@param {object} keyElementPairs (see the example)
@param {eventOptions} [eventOptions] (see above)
@returns {matreshka} self
@example
this.unbindNode({
	myKey1: '.my-element1' 
	myKey1: '.my-element2' 
});
*/


/**
@method Matreshka#unbindNode
@variation 3
@summary alternative syntax {@link Matreshka#unbindNode} "a great deal of arguments"
@see {@link Matreshka#bindNode(3)}
@param {array} setOfArguments - The array of argument arrays (see the example)
@param {eventOptions} [eventOptions] (see above)
@returns {matreshka} self
@example
var temporaryBindings = [
	[{
		myKey1: '.my-element1'
		myKey2: '.my-element2'
	}],
	[{
		myKey3: '.my-element3'
		myKey4: '.my-element4'
	}, {
		on: 'click',
		getValue: function() { ... },
		setValue: function() { ... }
	}],
	[{
		myKey5: '.my-element5'
		myKey6: '.my-element6'
	}, {
		on: 'somethingelse',
		getValue: function() { ... },
		setValue: function() { ... }
	}]
];

this.bindNode( temporaryBindings );

// these bindings are no longer needed
this.unbindNode( temporaryBindings );
*/


/**
@method Matreshka#boundAll
@summary Returns the collection of the bound elements
@desc After binding the properties and HTML elements, you can get a collection of these elements with the help of the ``boundAll`` method.
@param {string} [key] - The key of the property (or the list of the keys separated by spaces), which bound elements we want to get. If the argument is not passed, the element which is a sandbox for the instance will return.
@returns {$nodes} the bound elements
@example
this.bindNode( 'myKey', '.my-element' );
this.boundAll( 'myKey' ); // will return $( '.my-element' )
@example <caption>A sandbox return</caption>
this.bindNode( 'sandbox', '.app' );
this.boundAll(); // will return $( '.app' )
*/


/**
@method Matreshka#$bound
@summary does the same as {@link Matreshka#boundAll}
@example
this.$bound( 'myKey' );
*/


/**
@method Matreshka#bound
@summary Returns the first bound element or null
@param {string} [key] - The key of the property (or the list of the keys separated by spaces), which bound elements we want to get.  If the argument is not passed, the element which is a sandbox for the instance will return.
@returns {node|null} The bound element
@example
this.bindNode( 'myKey', '.my-element' );
this.bound( 'mykey' ); // will return $( '.my-element' )[0]
@example <caption>the "sandbox" return</caption>
this.bindNode( 'sandbox', '.app' );
this.bound(); // will return $( '.app' )[0]
*/


/**
@method Matreshka#selectAll
@summary Returns  elements corresponding to the selector from the sandbox
@desc After the sandbox creation by the {@link Matreshka#bindNode} method, you can get and use elements which are located in it. Besides, the method supports the ``:bound(KEY)`` selector
@param {string} The selector
@returns {$nodes}
@example
this.bindNode( 'sandbox', '.app' );
this.selectAll( '.my-element' );
// the same as
this.$bound().find( '.my-element' );
// the same as
$( '.app' ).find( '.my-element' );

@example <caption>The ``:bound(KEY)`` selector</caption>
this.bindNode( 'myKey', '.my-element' );
this.selectAll( ':bound(myKey) .my-another-element' );
// the same as
this.$bound( 'myKey' ).find( '.my-another-element' );
// the same as
$( '.my-element' ).find( '.my-another-element' );
*/


/**
@method Matreshka#$
@variation instance
@summary Делает то же самое, что и {@link Matreshka#selectAll}
@example
this.$( '.my-element' );
*/


/**
@method Matreshka#select
@summary Возвращает элемент из песочницы, соответствующий селектору
@desc Метод очнеь похож на {@link Matreshka#selectAll}, но возвращает лишь один элемент или ``null``
@param {string} Селектор
@returns {node}
@example
this.bindNode( 'sandbox', '.app' );
this.select( '.my-element' );
// то же самое, что и
this.bound().querySelector( '.my-element' );
// и то же самое, что и
$( '.app' ).find( '.my-element' )[ 0 ];
*/


/**
@method Matreshka#eq
@since 0.0.2
@summary Проверяет экземпляр на равенство другому объекту
@desc Internet Explorer 8 бросает исключение при попытке традиционного сравнения на равенство, используя ``==`` или ``===``. Метод ``.eq`` решает эту проблему. Если поддержка IE8 не нужна, то метод использовать не обязательно.
@param {object} object - Объект, с которым нужно сравнить экземпляр
@example
this.eq( object ); // true или false
@example <caption>Ошибка в IE8</caption>
this === object; //иногда IE8 выкидывает "Class doesn't support Automation"
*/


/**
@method Matreshka#defineGetter
@summary Устанавливает кастомный геттер для свойства
@desc Этот метод позволяет установить геттер (getter), используя нативный метод ``Object.defineProperty`` и работает во всех браузерах, начиная с Internet Explorer 8. Возвращаемое значение свойства вычисляется при каждом обращении к свойству, поэтому более предпочтительным методом, с точки зрения производительности, является {@link Matreshka#linkProps}.
@param {string} key - Ключ свойства, для которого устанавливается геттер
@param {function} getter - Функция-геттер
@example
this.defineGetter( 'myKey', function() {
	return 42; // функция может возвращать любое вычисляемое значение
});
*/


/**
@method Matreshka#defineGetter
@variation 2
@summary Альтернативный синтаксис метода {@link Matreshka#defineGetter} для установки геттера "ключ-геттер"
@param {object} keyGetterPairs - Объект со свойствами ключ-геттер
@example
this.defineGetter({
	myKey1: function() { return 1; } 
	myKey2: function() { return 2; } 
});
*/


/**
@method Matreshka#defineSetter
@summary Устанавливает кастомный сетер для свойства
@desc Этот метод позволяет установить сеттер (setter), используя нативный метод ``Object.defineProperty`` и работает во всех браузерах, начиная с Internet Explorer 8. При использовании этого метода следует иметь в виду, что он переписывет встроенный Матрешкой сеттер и, таким образом убирает возможность отлова событий, типа ``change:КЛЮЧ``. Используйте этот метод только если точно знаете, что делаете. Медоды {@link Matreshka#on} и {@link Matreshka#mediate} безопасны с точки зрения стабильности создаваемого приложения, лучше используйте их.
@param {string} key - Ключ, для которого требуется установить сеттер
@param {function} setter - Функция-сеттер
@example
this.defineSetter( 'mykey', function( v ) {
	alert( v );
});
*/


/**
@method Matreshka#defineSetter
@variation 2
@summary Альтернативный синтаксис метода {@link Matreshka#defineSetter} для установки сеттера "ключ-сеттер"
@param {object} keySetterPairs - Объект со свойствами ключ-сеттер
@example
this.defineSetter({
	myKey1: function( v ) { alert( v ); } 
	myKey2: function( v ) { alert( v ); } 
});
*/


/**
@method Matreshka#mediate
@since 0.1
@summary Трансформирует значение свойства при его изменении
@desc Этот метод используется для преобразования значения свойства при его изменении. Например, вам нужно, чтоб значение свойства всегда было либо определенного типа, либо целым числом, либо быть не менее нуля и не более ста и т. д.
@param {string|array} key - Ключ или массив ключей или список ключей, разделенных пробелами
@param {function} mediator - Функция-посредник (медиатор, mediator), возвращающая новое значение
@example
this.mediate( 'x', function() {
	return String( s );
});
this.x = 1;
alert( typeof this.x ); // "string"
@example <caption>Список ключей, разделенных пробелами</caption>
this.mediate( 'x y', function() {
	return String( s );
});
@example <caption>Массив ключей</caption>
this.mediate( [ 'x', 'y' ], function() {
	return String( s );
});
*/


/**
@method Matreshka#mediate
@variation 2
@since 0.1
@summary Альтернативный синтаксис метода {@link Matreshka#mediate}, принимающий в качестве аргумента объект "ключ-медиатор"
@param {object} keyMediatorPairs - Объект со свойствами ключ-медиатор
@example
this.mediate({
	x: String,
	y: Number,
	z: Boolean
});
this.x = 1;
this.y = 2;
this.z = 3;
alert( typeof this.x ); // "string"
alert( typeof this.y ); // "number"
alert( typeof this.z ); // "boolean"
@example <caption>Список ключей, разделенных пробелами</caption>
this.mediate({
	'u v': String,
	'w x': Number,
	'y z': Boolean
});
*/


/**
@method Matreshka#linkProps
@since 0.1
@summary Создает зависимость значения одного свойства от значений других
@desc Метод ``linkProps`` создает зависимость значения свойства (первый аргумент) от значений других свойств (второй аргумент). Метод защищен от цикличных ссылок (например a зависит от b, b зависит от c, а c зависит от a) и при ошибке вычислений не блокирует страницу и не бросает исключение о переполнении стека.
@param {string|array} keys1 - Свойство (свойства) которое зависит от других свойств
@param {string|array} keys2 - От каких свойств зависит искомое свойство (свойства)
@param {function} [handler=function(v){return v}] - Функция, возвращающая новое значение
@param {boolean} [setOnInit=true] - Установить ли значение свойства сразу после объявления зависимости
@example
this.linkProps( 'greeting', 'name', function() {
	return 'Hello, ' + this.name + '!';
});

this.name = 'Joe';

alert( this.greeting ); // 'Hello, Joe!'

@example <caption>Сложный пример: вычисление периметра прямоугольника по двум сторонам (и сторон по периметру). Как видите, ``linkProps`` можно использовать и для решения математических задач, где каждый член уравнения можно использовать, как неизвестное</caption>
this.a = 3;

this.b = 4;

this.linkProps( 'p', 'a b', function( a, b ) {
	return ( a + b ) * 2;
});

this.linkProps( 'a', 'p b', function( p, b ) {
	return p/2 - b;
});

this.linkProps( 'b', 'p a', function( p, a ) {
	return p/2 - a;
});

alert( this.p ); // 14

this.on( 'change:p', function() {
	alert( 'периметр изменен и равен ' + this.p );
});

this.a = 5; // alerts "периметр изменен и равен 18"
*/


/**
@method Matreshka#linkProps
@variation 2
@since 0.2
@summary Дополнительная возможность метода {@link Matreshka#linkProps}: зависимость от значений свойств других экземпляров
@param {string|array} keys - Свойство (свойства) которое зависит от других свойств
@param {array} instancesAndKeys - Массив, который содержит экземпляры (четные элементы) их ключи (нечетные элементы), от которых зависит искомое свойство (свойства). Такой, возможно, странный синтаксис является следствием ограничений синтаксиса JavaScript.
@param {function} [handler=function(v){return v}] - Функция, возвращающая новое значение 
@param {boolean} [setOnInit=true] - Установить ли значение свойства сразу после объявления зависимости
@example <caption>Свойство ``sum`` является суммой свойств ``a`` и ``b`` других экземпляров и вычисляется каждый раз при их изменении</caption>
anotherInstance1.a = 2;

anotherInstance2.b = 3;

this.linkProps( 'sum', [
	anotherInstance1, 'a',
	anotherInstance2, 'b'
], function( a, b ) {
	return a + b;
});

alert( this.sum ); // 5

this.on( 'change:sum', function() {
	alert( 'this.sum равен ' + this.sum );
});

anotherInstance1.a = 5; // "this.sum равен 8"
*/


/**
@method Matreshka#get
@summary Возвращает значение свойства
@param {string} key
@example
// то же самое, что и this[ 'myKey' ] или this.myKey
this.get( 'myKey' );
*/


/**
@method Matreshka#set
@fires change
@fires change:KEY
@summary Устанавливает значение свойства, позволяя передать объект события в качестве третьего аргумента
@desc Список поддерживаемых флагов:
+ ``silent`` - не вызывать события ``change`` и ``change:KEY``
+ ``silentHTML`` - не менять состояние привязанных элементов
+ ``force`` - вызвать события ``change`` и ``change:KEY`` даже если значение свойства не изменилось
+ ``forceHTML`` - изменить состояние привязанного элемента, даже если значение свойства не изменилось. Эта опция нужна, если привязанный элемент был отрисован после привязки (например, в ``select`` были добавлены теги ``option``)
+ ``skipMediator`` - предотвращает трансформацию свойства медиатором (см. {@link Matreshka#mediate})
+ ``skipLinks`` - предотвращает работу зависимостей, созданных с помощью {@link Matreshka#linkProps}
@param {string} key - Ключ
@param {*} value - Значение
@param {eventOptions} [eventOptions] - Объект события
@example
this.on( 'change:myKey', function( eventOptions ) {
	alert( eventOptions.value );
});

// то же самое, что и this[ 'myKey' ] = 3
// или this.myKey = 3
// выводит на экран 3
this.set( 'myKey', 3 );
@example <caption>Используя ``eventOptions``</caption>
this.on( 'change:myKey', function( eventOptions ) {
	alert( eventOptions.value );
});

// alert на срабатывает
this.set( 'myKey', 4, {
	silent: true
});

@example <caption>Передача произвольных данных в обработчик</caption>
this.on( 'change:myKey', function( eventOptions ) {
	alert( eventOptions.myCustomFlag );
});

// выводит на экран 42
this.set( 'myKey', 4, {
	myCustomFlag: 42
});
*/


/**
@method Matreshka#set
@variation 2
@summary Альтернативный синтаксис метода {@link Matreshka#set} "ключ-значение"
@param {object} keyValuePairs - Объект, содаржащий пары ключ-значение
@param {eventOptions} [eventOptions] - Объект события
@example
this.set({
	myKey1: 1,
	myKey2: 2
});
@example <caption>Педедача ``eventOptions`` в качестве второго аргумента</caption>
this.set({
	myKey: 3
}, {
	myFlag: 'Jigurda'
});
*/


/**
@method Matreshka#remove
@fires delete
@fires delete:KEY
@summary Удаляет свойство
@param {string} key - Ключ или ключи, разделенные пробелом
@param {eventOptions} [eventOptions] - Объект события
@returns {matreshka} self
@example
this.remove( 'myKey' );
this.remove( 'myKey1 myKey2' );
@example <caption>Использование ``eventOptions``</caption>
this.remove( 'myKey', {
	silent: true
});
*/


/**
@method Matreshka#define
@summary Полностью переписывает дескриптор свойства, используя ``Object.defineProperty``
@desc Обратите внимание, ``Object.defineProperty`` работает некорректно в Internet Explorer 8. Используйте метод только тогда, когда знаете, что делаете.
@param {string} key - Ключ
@param {function} descriptor - Дескриптор
@returns {matreshka} self
@example <caption>Простой пример</caption>
this.define( 'myKey', {
	get: function() { ... }
	set: function() { ... }
});
*/


/**
@method Matreshka#define
@variation 2
@summary Альтернативный синтаксис для метода {@link Matreshka#define} "ключ-дескриптор"
@desc Работа метода очень похожа на ``Object.defineProperties``
@param {object} keyObjectPairs - Объект, содаржащий пары ключ-дескриптор
@returns {matreshka} self
@example
this.define({
	myKey1: {
		get: function() { ... }
		set: function() { ... }
	},
	myKey2: {
		get: function() { ... }
		set: function() { ... }
	}
});
*/

/**
@method Matreshka#delay
@since 0.3
@summary Выполняет функцию после заданной задержки
@desc Работа метода очень похожа на ``setTimaout``. В качестве контекста принимается текущий экземпляр или переданный объект.
@see {@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers.setTimeout setTimeout на MDN}
@param {function} f - Функция, которая должна быть выполнена после истечения таймера
@param {number} [delay=0] - Задержка в миллисекундах
@param {object} [thisArg] - Контекст
@returns {matreshka} self
@example
this.on( 'change:x', function() {
	alert( this.x ); // 1 ... 2
});

this.delay( function() {
	this.x = 2;
}, 100 );

this.x = 1;
*/


/**
@method Matreshka.extend
@summary Небольшая вспомогательная функция, которая расширяет один объект свойствами другого объекта
@prop {object} o1
@prop {...object} o2
@returns {object} o1
@example
var o1 = { a: 3 },
	o2 = { b: 4 };
	
MK.extend( o1, o2 );
*/


/**
@member {string} Matreshka.version
@summary Версия Матрешки
@example
alert( Matreshka.version );
*/


/**
@method Matreshka.Class
@since 0.2
@summary Содержит ссылку на глобальную функцию {@link Class}
@desc Такой способ применения функции Class употребляется тогда, когда разрабатываемое приложение использует {@link https://github.com/amdjs/amdjs-api/blob/master/AMD.md AMD}
@example
MK.Class({
	method: function() {}
});

// то же самое, что и
Class({
	method: function() {}
});
*/


/**
@method Matreshka.$
@variation static
@summary Библиотека, используемая Матрешкой (jQuery, Zepto, {@link Matreshka.$b Balalaika} или др.)
@example
MK.$( '.my-element' );
*/


/**
@method Matreshka.$b
@summary Встроенная микро-библиотека {@link $b Балалайка}
@example
MK.$b( '.my-element' );
*/


/**
@method Matreshka.useAs$
@since 0.2
@summary Завтавляет использовать определенную библиотеку для работы с DOM
@desc По умолчанию, Матрешка использует в качестве библиотеки ту, которая находится по ссылке ``window.$``. Если такой переменной нет в глобальном пространстве имен, либо же она не включает в себя наобходимый набор методов, то используется встроенная микро библиотека {@link $b Балалайка}.

Метод {@link Matreshka.useAs$} заставляет Матрешку использовать ту библиотеку, которую вы захотите использовать, не смотря на отсутствие таковой в глобальном пространстве имен или по другой причине (например, если используется две разных версии jQuery на странице). Желательно, чтобы метод был запущен перед объявлением какого-либо класса, так как никакой ковертации в объект новой библиотеки не происходит.
@param {function} $ - Любмая библиотека (jQuery, Zepto, Balalaika или др.)
@todo Конвертировать все коллекции привязанных элементов в объект переданной библиотеки.
@example
Matreshka.useAs$( jQuery.noConflict() );
*/


/**
@member {boolean} Matreshka.isXDR
@summary Использует ли Матрешка хак с XDomainRequest. Другими словами, является ли текущий браузер Internet Explorer 8
@example
alert( Matreshka.isXDR );
*/


/**
@member {array} Matreshka.defaultBinders
@enum {function}
@summary Массив функций, возвращающих соответствующий байндер
@desc {@link Matreshka.defaultBinders} - массив функций, которые по очереди проверяют элемент на соответствие заданным в этих функциях правилам и возвращающих байндер (см. {@link #typedef-binder}). Этот массив используется тогда, когда в метод {@link Matreshka#bindNode} не был передан третий аргумент. Подробную инфорацию о привязках смотрите в документации к {@link Matreshka#bindNode}.
@see {@link Matreshka#bindNode}
@see {@link Matreshka.lookForBinder}
@example <caption>Кастомный чекбокс</caption>
// добавляем байндер в коллекцию байндеров
MK.binders.customCheckbox = function() {
	return {
		on: 'click',
		getValue: function() {
			return $( this ).hasClass( 'checked' );
		},
		setValue: function( v ) {
			$( this ).toggleClass( 'checked', !!v );
		},
		initialize: function() {
			$( this ).toggleClass( 'checked' );
		}
	}
};

// метод shift добавляет функцию в начало массива Matreshka.defaultBinders
MK.defaultBinders.shift( function( element ) {
	// проверяем, есть ли у элемента класс "custom-checkbox"
	if( $( element ).hasClass( 'custom-checkbox' ) ) {
		// если проверка пройдена, возвращаем новый байндер
		return MK.binders.customCheckbox();
	}
});

// ...

this.bindNode( 'myKey', '.custom-checkbox' );
*/


/**
@method Matreshka.noop
@summary Пустая функция, которая ничего не делает
@example
this.on( 'x', MK.noop );
*/


/**
@method Matreshka.each
@summary Итерирует любой объект, прогоняя каждое его свойство через функцию ``callback``
@desc Этот статичный метод схож с работой ``Array.prototype.forEach``.
@param {object} o - Объект
@param {function} callback - Функция, запускаемая на каждой итерации
@param {*} [thisArg] - Объект, который используется в качестве ``this`` при вызове ``callback``
@example
var myObject = {
	a: 1,
	b: 2
};
MK.each( myObject, function( value, key ) {
	// ...
});
*/


/**
@method Matreshka.debounce
@since 0.3
@summary Запускает функцию лишь однажды после истечения таймера. С каждой попыткой запуска таймер обновляется
@desc Этот метод - реализация микропаттерна **debounce**, который решает проблему многократного вызова обработчика событий за определенный промежуток времени. См. пример и {@link http://habrahabr.ru/post/60957/ статью на Хабре}.
@param {function} f - Оригинальная функция, 
@param {number} [duration=0] - Задержка
@param {*} [thisArg] - Контекст, в котором функция должна быть запущена
@example
var debounced = MK.debounce( function( x ) {
	console.log( x );
}, 10 );

for( var i = 0; i < 100; i++ ) {
	debounced( i );
}

// >>> 100
*/

/**
@method Matreshka.lookForBinder
@desc Возвращает байндер, соответствующий элементу. Если таковой не найден, возвращает ``undefined``. Функция использует {@link Matreshka.defaultBinders}.
@see {@link Matreshka#bindNode}
@see {@link Matreshka.defaultBinders}
@param {node} node
@returns {object} properties
@example
console.log( Matreshka.lookForBinder( $( 'input[type="text"]' ) ) );

// вернет объект
{
	on: 'keyup paste',
	getValue: function() { return this.value; },
	setValue: function( v ) {
		if( this.value != v ) {
			this.value = v;
		}
	}
}
*/

/**
@method Matreshka.randomString
@summary Функция, которая возвращает уникальную псевдо-случайную строку
@desc Для генерации строки используются функции ``new Date().getTime`` и ``Math.random()``, так что возвращаемая строка уникальна.
@returns {string} случайная строка
@example
var id = MK.ramdomString();
*/

