/**
@class Matreshka.Array
@classdesc The ``Matreshka.Array`` serves as a collection in the Matreshka framework . It is inherited from the {@link Matreshka} class, obtaining all the parent possibilities without exception. Besides, ``Matreshka.Array`` has all the methods that an ordinary array has.

#### All the methods which have been adopted from the built-in Array work like their  originals.
A programmer familiar to the methods of the native ``Array`` can understand immediately by means of which method  the element can be added (``push``, ``unshift``, ``splice``), deleted (``pop``, ``shift``, ``splice``), sorted (``sort``, ``reverse``) etc. An exception from this rule is the ``forEach`` method which in its original form always returns ``undefined`` and in case with {@link Matreshka.Array} it returns itself for the chained call possibility. For the reason that the methods work exactly the same as the original ones, they are not presented in this documentation separately but they are gathered in the {@link Matreshka.Array#METHOD} section.
```js
this.push( 1, 2, 3 );
this.pop();
```

#### The ``method_ `` syntax is used for this, where Low line at the end of the method name means that the last argument is the event object. Such methods are not given in this documentation  because it is necessary to remember their syntax only. See {@link Matreshka.Array#METHOD_}.
```js
this.push_( 1, 2, 3, {
	silent: true
});
this.pop_({
	silent: true
});
```

#### A developer has an opportunity of catching any data modification.

__While using the methods adopted from the built-in ``Array`` the events with the corresponding name are generated.__ Calling the ``push`` method, the ``push`` event  is generated, calling the ``pull`` method, the ``pull`` event is generated,  calling the ``sort`` method, the ``sort`` event is generated,  and so on... The list of arguments can be obtained addressing the ``args`` property.
```js
this.on( 'push', function( evt ) {
	console.log( evt.args ); // [1,2,3]
});

this.push( 1, 2, 3 );
```


__While adding the elements, the ``add`` and ``addone`` events are generated.__ The first one is generated once on adding (for example, you have added some elements with the help of ``push`` and the event has been called only once), the second one is generated once on every added element. On the ``add``event triggering, the array of the added elements is passed to the event object (the ``added`` property) and on the ``addone``triggering, each particular added element is passed to it.
```js
this.on( 'add', function( evt ) {
	console.log( evt.added ); // [1,2,3]
});

this.push( 1, 2, 3 );
```
```js
// the handler will be launched three times,
// as three new elements have been added to the array
this.on( 'addone', function( evt ) {
	console.log( evt.added ); // 1 ... 2 ... 3
});

this.push( 1, 2, 3 );
```


__On removing the elements the same logic is observed__: ``remove`` triggers once even though several elements have been removed and the ``removeone``  event triggers for each removed element individually. The ``removed`` elements are contained in the removed property of the event object.
```js
this.push( 1, 2, 3, 4, 5 );

this.on( 'remove', function( evt ) {
	console.log( evt.removed ); // [2,3,4]
});

this.splice( 1, 3 );
```
```js
this.push( 1, 2, 3, 4, 5 );

// the handler will be launched three times,
// as three new elements have been added to the array
this.on( 'removeone', function( evt ) {
	console.log( evt.added ); // 2 ... 3 ... 4
});

this.splice( 1, 3 );
```
__On every modification of the array the ``modify`` event is generated__, allowing to catch all changes in the array (adding, removing, re-sorting) without any exception.
```js
this.on( 'modify', function( evt ) {
	...
});
```

__``length``  is an ordinary property which can be bound to the__ HTML element or you can catch changes with the help of the ``change:length`` event.

> For example, on adding three elements with the help of the ``push`` method with three arguments, the following events: ``push``, ``add``, ``addone`` (three times), ``modify``, ``change:length`` are generated..

#### Model
The {@link Matreshka.Array#Model} property defines the element class which will be kept in the collection. Its behavior is very similar to the one of the ``model`` property from ``Backbone.Collection``. It is recommended to inherit ``Model`` from the {@link Matreshka.Object} class or the {@link Matreshka.Array}  one (in case if it is necessary to get the collection of the collections) in order to get the opportunity of converting the array into the ordinary one by means of the {@link Matreshka.Array#toJSON} method.
```js
// define Model
var MyModel = Class({
	//  it is inherited from MK.Object
	'extends': MK.Object,
	constructor: function( data ) {
		// set the passed property by the jset method
		this.jset( data );
	}
});

// define the class for the collection
var MyArray = Class({
	'extends': MK.Array,
	Model: MyModel
});

// create the class instance
var myArray = new MyArray;

// add two elements
myArray.push({
	a: 1,
	b: 2
}, {
	a: 3,
	b: 4
})

// will return [{ a: 1, b: 2 }, { a: 3, b: 4 }]
myArray.toJSON();
```

#### Automatic rendering
``Matreshka.Array`` can render the elements on the page automatically **in any modifications of** the array. The {@link Matreshka.Array#itemRenderer} property is used for that. A programmer does not have to worry about rebuilding the HTML tree, ``Matreshka.Array`` does it for him. The example of the usage of  automatic list rendering is below.
```html
<ul class="my-list"></ul>
```
```js
var MyModel = MK.Class({
	'extends': MK.Object,
	constructor: function( data ) {
		this.jset( data );
		
		// wait for the 'render' event
		this.on( 'render', function() {
			// and bind the 'value' property
			// to the newly created <li> HTML element
			this.bindNode( 'value', ':sandbox', MK.binders.innerHTML() );
		});
	}
});

var MyArray = MK.Class({
	'extends': MK.Array,
	Model: MyModel,
	// define the renderer for each element of the collection
	itemRenderer: '<li>',
	constructor: function() {
		// create a sandbox
		this.bindNode( 'sandbox', '.my-list' );
	}
});

var myArray = new MyArray;
myArray.push({
	value: 'Hello'
}, {
	value: 'World'
});
```
For more detailed information read the documentation of {@link Matreshka.Array#itemRenderer}.

@see {@link Matreshka.Array#itemRenderer}
@see {@link Matreshka.Array#Model}
@see {@link Matreshka#bindNode}

@inherits Matreshka
@example <caption>The instance creation</caption>
new MK.Array;
@example <caption>The instance creation with length specifying</caption>
new MK.Array( 42 );
@example <caption>The element passing on creation</caption>
new MK.Array( 'Hi', { a: 'b' } );
@example <caption>The inheritance</caption>
var MyClass = Class({
	'extends': MK.Array,
	constructor: function() {
		this.sayHello();
	},
	sayHello: function() {
		alert("Hello World!");
	}
});
@example <caption>The inheritance using the ECMAScript 2015 syntax</caption>
class MyClass extends MK.Array {
	constructor() {
		this.sayHello();
	}
	sayHello() {
		alert("Hello World!");
	}
}
@example <caption>The data enumerating, using the for..of cycle from ECMAScript 2015</caption>
var mkArray = new MK.Array( 1, 2, 3 );
for(let item of mkArray) {
	console.log( item ); // 1 .. 2 .. 3
}
@example <caption>Listening to the events</caption>
this.on( 'modify', function( evt ) {
	alert( '1) the method has been called ' + evt.method );
});

this.on( 'shift', function( evt ) {
	alert( '2) the method has been called ' + evt.method );
});

this.push( 1 ); // 1) the push method has been called

this.shift(); // 1) the shift method has been called, 2) the shift method has been called

@example <caption>The object event passing to the built-in ``Array`` method </caption>
this.on( 'modify', function( evt ) {
	alert( evt.customData );
});

this.push_( 1, {
	silent: true // the event is not generated
}); 

this.shift_({
	customData: 42 // 42
}); 
*/
	

/**
@member {boolean} Matreshka.Array#isMKArray
@summary ``isMKArray`` always equals ``true``. This property is used to define whether the object is an instance of the {@link Matreshka.Array} class.
@example
alert(object.isMKArray);
*/

/**
@member {boolean} Matreshka.Array#useBindingsParser
@summary The property launches the experimental parser if it is assigned ``true``
@see {@link Matreshka.Array#itemRenderer}
@example
var MyArray = Class({
	'extends': MK.Array,
	useBindingsParser: true,
	itemRenderer: '<li>{{property}}'
});
*/

/**
@member {boolean} Matreshka.Array#renderIfPossible
@summary The ``renderIfPossible`` property cancels the array rendering
@see {@link Matreshka.Array#itemRenderer}
@example
var MyArray = Class({
    'extends': MK.Array,
	itemRenderer: '<li>'
    renderIfPossible: false,
    // ...
});
*/

/**
@member {string|function} Matreshka.Array#itemRenderer
@abstract
@since 0.1
@summary The HTML  string, selector or function which is responsible for rendering the elements of the array on the page.
@desc The ``itemRenderer`` property is  an overridden one which allows to render the elements of the array without a programmer's participation. On the new element insertion into the array, the HTML node is created automatically. This node becomes a sandbox (see. {@link Matreshka#bindNode})  for the inserted element and it is  inlined into the HTML container which is defined in the array.

#### Where is the created element inserted?
In order to define the HTML container where the rendered HTML nodes will be inserted, it is necessary to define the **container**. The HTML sandbox should be declared for the array or a special ``container`` key should be bound to the  HTML  container for that.  Read more detailed information about the bindings and the sandbox in {@link Matreshka#bindNode}.
The example of the sandbox usage as a container:
```html
<ul class="my-list"></ul>
```
```js
var MyArray = Class({
	'extends': MK.Array,
	itemRenderer: '<li>',
	Model: MyModel,
	constructor: function() {
		// define a sandbox
		this.bindNode( 'sandbox', '.my-list' );
	}
});
```
Now all newly created ``<li>``  nodes will get into the ``.my-list`` node.

If you do not want to insert the HTML nodes straight into the sandbox, you can bind the ``container`` key to the necessary element. This logic is required in case if the sandbox is not limited by the collection elements alone and it includes other HTML nodes.
```html
<div class="my-widget">
	<h1>This is my awesome list</h1>
	<ul class="my-list"></ul>
</div>
```
```js
var MyArray = Class({
	'extends': MK.Array,
	itemRenderer: '<li>',
	Model: MyModel,
	constructor: function() {
		// define a sandbox
		this.bindNode( 'sandbox', '.my-widget' );
		// define a container for the HTML elements
		this.bindNode( 'container', '.my-list' );
	}
});
```
In the example above the HTML nodes will be inserted into ``.my-list`` instead of ``.my-widget``.

The ``itemRenderer`` property supports a few variants of defining, but they all must contain or return the only HTML node.
#### HTML строка в качестве значения свойства
As you can see from the example above ``itemRenderer`` can be defined as an HTML string.
```js
var MyArray = Class({
	'extends': MK.Array,
	Model: MyModel,
	itemRenderer: '<div class="my-div">Be cool</div>',
	constructor: function() { ... }
});
```
#### The selector as the property value
In case if you carry over the templates for the elements to the HTML page, ``itemRenderer`` supports the selector as the value. When this occurs, {@link Matreshka.Array} will search for the HTML element in the DOM tree and it will extract ``innerHTML`` of the found element. In case if the element is not found, the HTML exception is thrown. The text is different from the selector  due to the presence of the ``<``symbol in the string.
```html
<script type="text/html" id="be-cool-template">
	<div class="my-div">Be cool</div>
</script>
```
```js
var MyArray = Class({
	'extends': MK.Array,
	Model: MyModel
	itemRenderer: '#be-cool-template',
	constructor: function() { ... }
});
```
#### Функция в качестве значения свойства
Использование функции в качестве значения свойства ``itemRenderer`` даёт дополнительную гибкость кода, если есть нужда динамически генерировать элемент для рендеринга. Функция может возвращать:

__HTML строку__
```js
var MyArray = Class({
	'extends': MK.Array,
	Model: MyModel,
	itemRenderer: function() {
		return '<div class="my-div">Be cool</div>';
	},
	constructor: function() { ... }
});
```

__Селектор__
```js
var MyArray = Class({
	'extends': MK.Array,
	Model: MyModel,
	itemRenderer: function() {
		return '#be-cool-template';
	},
	constructor: function() { ... }
});
```

__DOM узел__
```js
var MyArray = Class({
	'extends': MK.Array,
	itemRenderer: function() {
		return document.createElement( 'div' );
	}
});
```

#### Переопределение родительского рендерера свойством ``render``
Иногда удобно объявлять рендерер внутри класса {@link Matreshka.Array#Model}, как это делает ``Backbone``. Свойство ``renderer`` переопределяет значение ``itemRenderer``, если оно задано для дочернего элемента коллекции.
```js
var MyModel = Class({
	'extends': MK.Object,
	renderer: '<div class="my-div">Be cool</div>',
	constructor: function( data ) { ... }
});

var MyArray = Class({
	'extends': MK.Array,
	Model: MyModel,
	itemRenderer: '<frameset>Not cool</frameset>',
	constructor: function() { ... }
});
```
В этом случае, можно вовсе не указывать ``itemRenderer``, так как ``render`` дочернего элемента перенимает все его возможности. Синтаксис остаётся такими же: можно использовать HTML, селектор или функцию.

#### Событие ``render``
После того, как элемент вставлен в массив, а его HTML узел уже создан, но еще не вставлен в контейнер, генерируется событие ``render`` на вставленном элементе. После его генерации можно объявить привязки свойств к HTML узлам, содержащимся внутри вставленного.
```html
<form class="my-form"></form>
```
```js
var MyModel = Class({
	'extends': MK.Object,
	constructor: function( data ) {
		this.set( data );
		
		// ждем генерации события
		this.on( 'render', function() {
			this.bindNode( 'isChecked', ':sandbox .my-checkbox' );
			this.bindNode( 'text', ':sandbox .text', MK.binders.innerHTML() );
		});
	}
});

var MyArray = Class({
	'extends': MK.Array,
	Model: MyModel,
	itemRenderer: '<label>\
		<input type="checkbox" class="my-checkbox">\
		<span class="text"></span>\
	</label>',
	constructor: function() {
		this.bindNode( 'sandbox', '.my-form' );
		this.push({
			isChecked: true,
			text: 'Be cool'
		}, {
			isChecked: false,
			text: 'Produce shitcode'
		});
	}
});

var app = new MyArray();
```
Код выше создаст такое HTML дерево:
```html
<form class="my-form">
	<label>
		<input type="checkbox" class="my-checkbox">
		<span class="text">Be cool</span>
	</label>
	<label>
		<input type="checkbox" class="my-checkbox">
		<span class="text">Produce shitcode</span>
	</label>
</form>
```
И свяжет чекбоксы с соответствующими свойствaми ``isChecked`` и ``text``. <a href="http://jsbin.com/zetuya/1/" target="_blank">Живой пример</a>

Не забывайте, что в Матрешке реализована возможность отлова всплывающих событий. Т. е. сам массив может отловить собвтие рендеринга элемента, используя имя события ``@render`` (см. документацию к {@link #typedef-eventNames}).
```js
this.on( '@render', function( evt ) {
	alert( 'Child element is rendered' );
});
```

> Отрисованный HTML узел становится песочницей для вставленного элемента, позволяя использовать селектор ``:sandbox`` и другие возможности после рендеринга. Если элемент входит сразу в несколько коллекций, установите ему свойство ``bindRenderedAsSandbox: false``, чтобы отменить это поведение.
```js
var MyModel = Class({
	'extends': MK.Object,
	bindRenderedAsSandbox: false
	// ...
});
```


#### Экспериментальный шаблонизатор
Взглянув на примеры использования {@link Matreshka.Array} и {@link Matreshka.Array#itemRenderer} можно обратить внимание на то, что вся логика, отвечающая за двустороннюю и одностороннюю привязку данных заключена в HTML коде. Это одно из главных преимуществ Матрешки. Но когда разрабатываешь очень простую коллекцию, не включающую в себя сложную логику, массу привязок и пр. хотелось бы иметь более краткий вариант объявления привязок. Для этого, в ``itemRenderer`` может быть передан шаблон, включающий привязки. Для того, чтоб включить шаблонизацию, используйте ключ {@link Matreshka.Array#useBindingsParser}, установленный, как ``true``.
```js
var MyArray = Class({
	'extends': MK.Array,
	useBindingsParser: true,
	Model: MK.Object,
	itemRenderer: '<label>\
		<input type="checkbox" checked="&#123;{isChecked}}">&#123;{text}}\
	</label>',
	constructor: function() {
		this.bindNode( 'sandbox', '.my-form' );
		this.push({
			isChecked: true,
			text: 'Be cool'
		}, {
			isChecked: false,
			text: 'Produce shitcode'
		});
	}
});

var app = new MyArray();
```
Пример выше полностью повторяет предыдущий, но не требует создания отдельного класса для Модели, так как нам не требуется отлавливать событие ``render`` и объявлять привязки вручную. <a href="http://jsbin.com/wabiyi/1/" target="_blank">Живой пример</a>

Такой подход выглядит очень привлекательно, но он имеет несколько особенностей из-за которых рекомендуется избегать экспериментальный шаблонизатор:
+ Шаблонизатор - это экспериментальная возможность Матрешки. Он может рыботать нестабильно в некоторых, неучтенных случаях.
+ Скорость кода с шаблонизатором ниже, чем без него. Это происходит из-за того, что анализ строки, перебор ключей в цикле (при использовании нескольких ключей в одном атрибуте), замена подсток регулярным выражением и пр. требуют больше ресурсов.
+ Дополнительного синтаксиса не предусмотрено. Условия и циклы должны быть объявлены в JavaScript коде, а обращение к дочернему объекту не учтено (т. е. такой код не сработает: &#123;{a.b}})

В целом, используйте шаблонизатор только тогда, когда разрабатываемое приложение не велико и не требовательно к производительности.

#### Отмена рендеринга
Как видно выше, если у дочернего элемента задано свойство ``render``, ``Matreshka.Array`` попробует его отрисовать. Для того, чтоб полностью отменить рендеринг для массива, присвойте свойству ``renderIfPossible: false``.
```js
var MyArray = Class({
	'extends': MK.Array,
	renderIfPossible: false,
	// ...
});
```


@see {@link Matreshka#bindNode}
@see {@link Matreshka.Array#Model}
*/


/**
@method Matreshka.Array#Model
@since 0.2
@abstract
@summary Свойство определяет класс элементов, которые будет содержать коллекция
@desc При каждом добавлении элементов в массив, встроенный обработчик проверяет, является ли добавленный элемент экземпляром ``Model`` и конвертирует его в таковой, если проверка не пройдена. Это поведение очень напоминает поведение свойства ``model`` из ``Backbone.Collection``. Рекомендуется наследовать ``Model`` от класса {@link Matreshka.Object} или {@link Matreshka.Array} (на случай, если тебуется получить коллекцию коллекций), чтоб получить возможность конвертации массива в обычный массив методом {@link Matreshka.Array#toJSON}.

Для более гибкого контроля класса элементов (например, если для одних элементов нужно использовать одну Модель, а для других - другую), используйте {@link Matreshka.Array#mediateItem}.

@see {@link Matreshka.Array#mediateItem}
@see {@link Matreshka.Array#itemRenderer}

@param {object} data - Данные, переданные в конструктор
@param {matreshkaArray} mkArray - Массив, в который добавили элемент  

@example
// определяем Модель
var MyModel = Class({
	// она наследуется от MK.Object
	'extends': MK.Object,
	constructor: function( data ) {
		// устанавливаем переданные свойства методом jset
		this.jset( data );
		this.doSomething();
	},
	doSomething: function() { ... }
});

// опеределяем класс для коллекции
var MyArray = Class({
    'extends': MK.Array,
    Model: MyModel
});

// создаем экземпляр класса
var myArray = new MyArray;

// добавляем два элемента
myArray.push({
    a: 1,
    b: 2
}, {
    a: 3,
    b: 4
})

// вернет [{ a: 1, b: 2 }, { a: 3, b: 4 }]
myArray.toJSON();

*/


/**
@method Matreshka.Array#mediateItem
@since 0.1
@see {@link Matreshka.Array#Model}
@see {@link Matreshka#mediate}
@summary Трансформирует значение элемента при вставке
@desc Этот метод служит для того, чтоб установить типизацию для вставляемых элементов. Обратите внимание, метод переопределяет свойство {@link Matreshka.Array#Model}.
@example
// все элементы массива - числа
this.mediateItem( Number );
@example 
this.push( 1, 2, 3, 4, 5 );

// все элементы массива - строки
this.mediateItem( function( value ) {
	return String( value );
});

this.push( 6, 7 );

this.unshift( true, {} );

// [ "true", "[object Object]", "1", "2", "3", "4", "5", "6", "7" ]
console.log( mkArray.toJSON() );
@example <caption>Условная Модель</caption>
this.mediateItem( function( item ) {
	if( item.something ) {
		return new FirstModel( item );
	} else {
		return new SecondModel( item );
	}
});
*/


/**
@method Matreshka.Array#on
@since 0.2
@summary Работает так же, как и {@link Matreshka#on}, но дополнительно позволяет динамически навешивать обработчики на вставленные элементы.
@example
this.on( '@something', function() {
	alert( 'something happens' )
});

this.push( new MK );

this[0].trigger( 'something' );
*/ 

/**
@method Matreshka.Array#recreate
@fires recreate
@fires modify
@fires add
@fires addone
@fires remove
@fires removeone
@summary Пересоздает экземпляр {@link Matreshka.Array}
@desc Метод позволяет конвертировать любой массив (или объект, подобный массиву) в экземпляр {@link Matreshka.Array}. Если ничего не передано в качестве первого аргумента, экземпляр очищается.
@param {array} [array] - Массив
@param {eventOptions} [eventOptions] - Объект события
@returns {matreshkaArray} self
@example
// очищаем массив и добавляем 5 новых элементов
this.recreate( [1, 2, 3, 4, 5] );

// очищаем массив
this.recreate();
*/


/**
@method Matreshka.Array#toArray
@summary Конвертирует {@link Matreshka.Array} в обычный массив, но не конвертирует входящие в него элемены
@returns {array}
@example
this.toArray();
*/


/**
@method Matreshka.Array#toNative
@summary Делает то же самое, что и {@link Matreshka.Array#toArray}
@returns {array}
@example
this.toNative();
*/


/**
@method Matreshka.Array#rerender
@since 0.3
@summary Перерисовывает DOM узлы элементов, входящих в массив
@desc Этот метод, как правило, используется тогда, когда свойство {@link Matreshka.Array#itemRenderer} устанавливается после того, как элементы были добавлены в массив.
@returns {matreshkaArray} self
@example
var mkArray = new MK.Array;

// DOM не меняется, так как itemRenderer еще не определен
mkArray.push( ... );

// определяем itemRenderer
mkArray.itemRenderer = function() { '<div>MyDiv</div>' };

// DOM перерисовывается
mkArray.rerender();
*/


/**
@method Matreshka.Array#hasOwnProperty
@summary Существует ли свойство в экземпляре (индекс или свойство ``length``)
@returns {boolean}
@example
var mkArray = new MK.Array( 42 ); // создает массив длиной 42

mkArray.hasOwnProperty( 5 ); // true

mkArray.hasOwnProperty( 100500 ); // false

mkArray.hasOwnProperty( 'length' ); // true

mkArray.hasOwnProperty( 'blah' ); // false
*/


/**
@method Matreshka.Array#toJSON
@summary Конвертирует экземпляр и элементы, входящие в него в обычный массив
@returns {object}
@example
var data = this.toJSON();
*/


/**
@method Matreshka.Array#pull
@since 0.1
@fires pull
@fires remove
@fires removeone
@fires modify
@summary Удаляет элемент с заданным индексом из массива и возвращает этот элемент. Начиная с версии 0.3, метод поддерживает удаляемый элемент в качестве аргумента.
@param {string|number|*} index - Индекс элемента, который нужно удалить (число или строка) либо сам удаляемый элемент (не являющийся ни числом ни строкой)
@param {eventOptions} [evtOptions] - Объект события на случай, если нужно передать в обработчик события какие-нибудь данные или установить флаг ``silent``, предотвращающий срабатывание события
@returns {*|null} Удаленный элемент или ``null``
@example <caption>Передача индекса массива</caption>
var removed;

this.recreate( [ 'a', 'b', 'c' ] );

removed = this.pull( 1 );

alert( removed ); // 'b'

alert( this.toString() ); // 'a,c'
@example <caption>Передача удаляемого элемента</caption>
var object1 = {},
	object2 = {},
	object3 = {},
	removed;

this.push( object1, object2, object3 );

removed = this.pull( object2 );

alert( removed === object2 ); // true

alert( this.length ); // 2
*/


/**
@method Matreshka.Array#each
@summary Работает точно так же, как и метод ``forEach``, который перебирает элементы массива
@param {function} callback - Функция, запускаемая на каждой итерации
@param {*} [thisArg] - Объект, который используется в качестве ``this`` при вызове ``callback``
@returns {matreshkaArray} self
@example
this.each( function( item, index ) {
	console.log( index, item ); 
});
*/


/**
@method Matreshka.Array#METHOD
@summary Любой метод из ``Array.prototype``
@desc {@link Matreshka.Array} включает в себя все методы, входящие в нативный JavaScript массив:
<ul>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat" target="_blank">concat</a></li>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join" target="_blank">join</a></li>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/pop" target="_blank">pop</a></li>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push" target="_blank">push</a></li>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse" target="_blank">reverse</a></li>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/shift" target="_blank">shift</a></li>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" target="_blank">slice</a></li>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort" target="_blank">sort</a></li>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice" target="_blank">splice</a></li>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString"  target="_blank">toString</a></li>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift" target="_blank">unshift</a></li>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every" target="_blank">every</a></li>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" target="_blank">filter</a></li>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" target="_blank">forEach</a></li>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf">indexOf</a></li>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf" target="_blank">lastIndexOf</a></li>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank">map</a></li>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some" target="_blank">some</a></li>
</ul>
При этом, они работают точно так же, как и методы ``Array.prototype``. Есть лишь несколько оговорок:
+ Метод ``forEach`` возвращает себя вместо ``undefined``
+ Методы, которые в оригинальном виде возвращают новый массив (``splice``, ``slice``, ``filter``, ``map``...), в Матрешке возвращают новый экземпляр ``Matreshka.Array``.

Кроме всего, методы генерируют события связанные с любой модификацией массива. Подробнее см. {@link Matreshka.Array}.

@see {@link Matreshka.Array#_METHOD}
@example
this.push( 1, 2, 3 );
@example
var mapped = this
	.forEach( function( value, index ) {
		//...
	})
	.map( function( value, index ) {
		//...
	})
;
alert( mapped.isMKArray );
@example
this.reverse();
*/

/**
@method Matreshka.Array#METHOD_
@summary Любой метод из ``Array.prototype`` с возможностью передать объект события
@desc Ознакомившись с {@link Matreshka.Array#METHOD} становится понятно, что методы не поддерживают передачу объекта события, так как в точности повторяют синтаксис и количество аргументов встроенного ``Array``. Синтаксис ``МЕТОД_`` позволяет передать в обработчик события какие-нибудь данные либо установить служебные флаги, отвечающие за поведение массива после вызова метода.

Список доступных флагов:
+ ``silent: true`` - отключает генерацию событий
+ ``dontRender: true`` - отключает {@link Matreshka.Array#itemRenderer рендеринг}
+ ``skipMediator: true`` - отключает {@link Matreshka.Array#mediateItem медиаторы}


@see {@link Matreshka.Array#METHOD}
@example
this.push_( 1, 2, 3, {
    silent: true
});

this.pop_({
    silent: true
});
@example
this.on( 'modify', function( evt ) {
	alert( evt.flag ); // 42
});

this.push_( 1, 2, 3, {
	flag: 42
});
*/

