/**
@class Matreshka.Array
@classdesc The ``Matreshka.Array`` serves as a collection in the Matreshka framework . It is inherited from the {@link Matreshka} class, obtaining all the parent possibilities without exception. Besides, ``Matreshka.Array`` has all the methods that an ordinary array has.

#### All the methods which have been adopted from the built-in Array work like their  originals.
A programmer familiar to the methods of the native ``Array`` can understand immediately by means of which method  the element can be added (``push``, ``unshift``, ``splice``), deleted (``pop``, ``shift``, ``splice``), sorted (``sort``, ``reverse``) etc. An exception from this rule is the ``forEach`` method which in its original form always returns ``undefined`` and in case with {@link Matreshka.Array} it returns itself for the chained call possibility. For the reason that the methods work exactly the same as the original ones, they are not presented in this documentation separately but they are gathered in the {@link Matreshka.Array#METHOD} section.
```js
this.push( 1, 2, 3 );
this.pop();
```

#### The ``method_ `` syntax is used for this, where Low line at the end of the method name means that the last argument is the event object. Such methods are not given in this documentation  because it is necessary to remember their syntax only. See {@link Matreshka.Array#METHOD_}.
```js
this.push_( 1, 2, 3, {
	silent: true
});
this.pop_({
	silent: true
});
```

#### A developer has an opportunity of catching any data modification.

__While using the methods adopted from the built-in ``Array`` the events with the corresponding name are generated.__ Calling the ``push`` method, the ``push`` event  is generated, calling the ``pull`` method, the ``pull`` event is generated,  calling the ``sort`` method, the ``sort`` event is generated,  and so on... The list of arguments can be obtained addressing the ``args`` property.
```js
this.on( 'push', function( evt ) {
	console.log( evt.args ); // [1,2,3]
});

this.push( 1, 2, 3 );
```


__While adding the elements, the ``add`` and ``addone`` events are generated.__ The first one is generated once on adding (for example, you have added some elements with the help of ``push`` and the event has been called only once), the second one is generated once on every added element. On the ``add``event triggering, the array of the added elements is passed to the event object (the ``added`` property) and on the ``addone``triggering, each particular added element is passed to it.
```js
this.on( 'add', function( evt ) {
	console.log( evt.added ); // [1,2,3]
});

this.push( 1, 2, 3 );
```
```js
// the handler will be launched three times,
// as three new elements have been added to the array
this.on( 'addone', function( evt ) {
	console.log( evt.added ); // 1 ... 2 ... 3
});

this.push( 1, 2, 3 );
```


__On removing the elements the same logic is observed__: ``remove`` triggers once even though several elements have been removed and the ``removeone``  event triggers for each removed element individually. The ``removed`` elements are contained in the removed property of the event object.
```js
this.push( 1, 2, 3, 4, 5 );

this.on( 'remove', function( evt ) {
	console.log( evt.removed ); // [2,3,4]
});

this.splice( 1, 3 );
```
```js
this.push( 1, 2, 3, 4, 5 );

// the handler will be launched three times,
// as three new elements have been added to the array
this.on( 'removeone', function( evt ) {
	console.log( evt.added ); // 2 ... 3 ... 4
});

this.splice( 1, 3 );
```
__On every modification of the array the ``modify`` event is generated__, allowing to catch all changes in the array (adding, removing, re-sorting) without any exception.
```js
this.on( 'modify', function( evt ) {
	...
});
```

__``length``  is an ordinary property which can be bound to the__ HTML element or you can catch changes with the help of the ``change:length`` event.

> For example, on adding three elements with the help of the ``push`` method with three arguments, the following events: ``push``, ``add``, ``addone`` (three times), ``modify``, ``change:length`` are generated..

#### Model
The {@link Matreshka.Array#Model} property defines the element class which will be kept in the collection. Its behavior is very similar to the one of the ``model`` property from ``Backbone.Collection``. It is recommended to inherit ``Model`` from the {@link Matreshka.Object} class or the {@link Matreshka.Array}  one (in case if it is necessary to get the collection of the collections) in order to get the opportunity of converting the array into the ordinary one by means of the {@link Matreshka.Array#toJSON} method.
```js
// define Model
var MyModel = Class({
	//  it is inherited from MK.Object
	'extends': MK.Object,
	constructor: function( data ) {
		// set the passed property by the jset method
		this.jset( data );
	}
});

// define the class for the collection
var MyArray = Class({
	'extends': MK.Array,
	Model: MyModel
});

// create the class instance
var myArray = new MyArray;

// add two elements
myArray.push({
	a: 1,
	b: 2
}, {
	a: 3,
	b: 4
})

// will return [{ a: 1, b: 2 }, { a: 3, b: 4 }]
myArray.toJSON();
```

#### Automatic rendering
``Matreshka.Array`` can render the elements on the page automatically **in any modifications of** the array. The {@link Matreshka.Array#itemRenderer} property is used for that. A programmer does not have to worry about rebuilding the HTML tree, ``Matreshka.Array`` does it for him. The example of the usage of  automatic list rendering is below.
```html
<ul class="my-list"></ul>
```
```js
var MyModel = MK.Class({
	'extends': MK.Object,
	constructor: function( data ) {
		this.jset( data );
		
		// wait for the 'render' event
		this.on( 'render', function() {
			// and bind the 'value' property
			// to the newly created <li> HTML element
			this.bindNode( 'value', ':sandbox', MK.binders.innerHTML() );
		});
	}
});

var MyArray = MK.Class({
	'extends': MK.Array,
	Model: MyModel,
	// define the renderer for each element of the collection
	itemRenderer: '<li>',
	constructor: function() {
		// create a sandbox
		this.bindNode( 'sandbox', '.my-list' );
	}
});

var myArray = new MyArray;
myArray.push({
	value: 'Hello'
}, {
	value: 'World'
});
```
For more detailed information read the documentation of {@link Matreshka.Array#itemRenderer}.

@see {@link Matreshka.Array#itemRenderer}
@see {@link Matreshka.Array#Model}
@see {@link Matreshka#bindNode}

@inherits Matreshka
@example <caption>The instance creation</caption>
new MK.Array;
@example <caption>The instance creation with length specifying</caption>
new MK.Array( 42 );
@example <caption>The element passing on creation</caption>
new MK.Array( 'Hi', { a: 'b' } );
@example <caption>The inheritance</caption>
var MyClass = Class({
	'extends': MK.Array,
	constructor: function() {
		this.sayHello();
	},
	sayHello: function() {
		alert("Hello World!");
	}
});
@example <caption>The inheritance using the ECMAScript 2015 syntax</caption>
class MyClass extends MK.Array {
	constructor() {
		this.sayHello();
	}
	sayHello() {
		alert("Hello World!");
	}
}
@example <caption>The data enumerating, using the for..of cycle from ECMAScript 2015</caption>
var mkArray = new MK.Array( 1, 2, 3 );
for(let item of mkArray) {
	console.log( item ); // 1 .. 2 .. 3
}
@example <caption>Listening to the events</caption>
this.on( 'modify', function( evt ) {
	alert( '1) the method has been called ' + evt.method );
});

this.on( 'shift', function( evt ) {
	alert( '2) the method has been called ' + evt.method );
});

this.push( 1 ); // 1) the push method has been called

this.shift(); // 1) the shift method has been called, 2) the shift method has been called

@example <caption>The object event passing to the built-in ``Array`` method </caption>
this.on( 'modify', function( evt ) {
	alert( evt.customData );
});

this.push_( 1, {
	silent: true // the event is not generated
}); 

this.shift_({
	customData: 42 // 42
}); 
*/
	

/**
@member {boolean} Matreshka.Array#isMKArray
@summary ``isMKArray`` always equals ``true``. This property is used to define whether the object is an instance of the {@link Matreshka.Array} class.
@example
alert(object.isMKArray);
*/

/**
@member {boolean} Matreshka.Array#useBindingsParser
@summary The property launches the experimental parser if it is assigned ``true``
@see {@link Matreshka.Array#itemRenderer}
@example
var MyArray = Class({
	'extends': MK.Array,
	useBindingsParser: true,
	itemRenderer: '<li>{{property}}'
});
*/

/**
@member {boolean} Matreshka.Array#renderIfPossible
@summary The ``renderIfPossible`` property cancels the array rendering
@see {@link Matreshka.Array#itemRenderer}
@example
var MyArray = Class({
    'extends': MK.Array,
	itemRenderer: '<li>'
    renderIfPossible: false,
    // ...
});
*/

/**
@member {string|function} Matreshka.Array#itemRenderer
@abstract
@since 0.1
@summary The HTML  string, selector or function which is responsible for rendering the elements of the array on the page.
@desc The ``itemRenderer`` property is  an overridden one which allows to render the elements of the array without a programmer's participation. On the new element insertion into the array, the HTML node is created automatically. This node becomes a sandbox (see. {@link Matreshka#bindNode})  for the inserted element and it is  inlined into the HTML container which is defined in the array.

#### Where is the created element inserted?
In order to define the HTML container where the rendered HTML nodes will be inserted, it is necessary to define the **container**. The HTML sandbox should be declared for the array or a special ``container`` key should be bound to the  HTML  container for that.  Read more detailed information about the bindings and the sandbox in {@link Matreshka#bindNode}.
The example of the sandbox usage as a container:
```html
<ul class="my-list"></ul>
```
```js
var MyArray = Class({
	'extends': MK.Array,
	itemRenderer: '<li>',
	Model: MyModel,
	constructor: function() {
		// define a sandbox
		this.bindNode( 'sandbox', '.my-list' );
	}
});
```
Now all newly created ``<li>``  nodes will get into the ``.my-list`` node.

If you do not want to insert the HTML nodes straight into the sandbox, you can bind the ``container`` key to the necessary element. This logic is required in case if the sandbox is not limited by the collection elements alone and it includes other HTML nodes.
```html
<div class="my-widget">
	<h1>This is my awesome list</h1>
	<ul class="my-list"></ul>
</div>
```
```js
var MyArray = Class({
	'extends': MK.Array,
	itemRenderer: '<li>',
	Model: MyModel,
	constructor: function() {
		// define a sandbox
		this.bindNode( 'sandbox', '.my-widget' );
		// define a container for the HTML elements
		this.bindNode( 'container', '.my-list' );
	}
});
```
In the example above the HTML nodes will be inserted into ``.my-list`` instead of ``.my-widget``.

The ``itemRenderer`` property supports a few variants of defining, but they all must contain or return the only HTML node.
#### HTML строка в качестве значения свойства
As you can see from the example above ``itemRenderer`` can be defined as an HTML string.
```js
var MyArray = Class({
	'extends': MK.Array,
	Model: MyModel,
	itemRenderer: '<div class="my-div">Be cool</div>',
	constructor: function() { ... }
});
```
#### The selector as the property value
In case if you carry over the templates for the elements to the HTML page, ``itemRenderer`` supports the selector as the value. When this occurs, {@link Matreshka.Array} will search for the HTML element in the DOM tree and it will extract ``innerHTML`` of the found element. In case if the element is not found, the HTML exception is thrown. The text is different from the selector  due to the presence of the ``<``symbol in the string.
```html
<script type="text/html" id="be-cool-template">
	<div class="my-div">Be cool</div>
</script>
```
```js
var MyArray = Class({
	'extends': MK.Array,
	Model: MyModel
	itemRenderer: '#be-cool-template',
	constructor: function() { ... }
});
```
#### The function as the property value
The usage of the function as the ``itemRenderer`` property value gives an additional code flexibility if it is necessary to dynamically generate the element for rendering. The function can return:

__the HTML string__
```js
var MyArray = Class({
	'extends': MK.Array,
	Model: MyModel,
	itemRenderer: function() {
		return '<div class="my-div">Be cool</div>';
	},
	constructor: function() { ... }
});
```

__the selector__
```js
var MyArray = Class({
	'extends': MK.Array,
	Model: MyModel,
	itemRenderer: function() {
		return '#be-cool-template';
	},
	constructor: function() { ... }
});
```

__the DOM node__
```js
var MyArray = Class({
	'extends': MK.Array,
	itemRenderer: function() {
		return document.createElement( 'div' );
	}
});
```

#### The parent renderer overriding by the ``render property``
Sometimes it is convenient to declare a renderer inside the {@link Matreshka.Array#Model} class as ``Backbone`` does. The ``renderer property`` overrides the ``itemRenderer`` value if it is specified for the child element of the collection.
```js
var MyModel = Class({
	'extends': MK.Object,
	renderer: '<div class="my-div">Be cool</div>',
	constructor: function( data ) { ... }
});

var MyArray = Class({
	'extends': MK.Array,
	Model: MyModel,
	itemRenderer: '<frameset>Not cool</frameset>',
	constructor: function() { ... }
});
```
In this case you do not have to  designate ``itemRenderer`` at all because ``render`` of the child element adopts all its possibilities. The syntax remains the same:  HTML, the selector or the function can be used.

#### The  ``render event``
After the element has been inserted into the array and its HTML node has already been created but it hasn't been inserted into the container yet, the ``render`` event is generated on the inserted element. After its generation you can declare the property bindings to the HTML nodes which are located inside the inserted one.
```html
<form class="my-form"></form>
```
```js
var MyModel = Class({
	'extends': MK.Object,
	constructor: function( data ) {
		this.set( data );
		
		// wait for the event generation
		this.on( 'render', function() {
			this.bindNode( 'isChecked', ':sandbox .my-checkbox' );
			this.bindNode( 'text', ':sandbox .text', MK.binders.innerHTML() );
		});
	}
});

var MyArray = Class({
	'extends': MK.Array,
	Model: MyModel,
	itemRenderer: '<label>\
		<input type="checkbox" class="my-checkbox">\
		<span class="text"></span>\
	</label>',
	constructor: function() {
		this.bindNode( 'sandbox', '.my-form' );
		this.push({
			isChecked: true,
			text: 'Be cool'
		}, {
			isChecked: false,
			text: 'Produce shitcode'
		});
	}
});

var app = new MyArray();
```
The code above will create the following HTML tree:
```html
<form class="my-form">
	<label>
		<input type="checkbox" class="my-checkbox">
		<span class="text">Be cool</span>
	</label>
	<label>
		<input type="checkbox" class="my-checkbox">
		<span class="text">Produce shitcode</span>
	</label>
</form>
```
And it will bind the checkboxes to the corresponding ``isChecked`` and ``text`` properties. <a href="http://jsbin.com/zetuya/1/" target="_blank"> The live example</a>

Remember, the opportunity of catching the pop-up events is implemented in Matreshka. The array can catch the event of the element rendering itself, using the ``@render`` event name (see the documentation of {@link #typedef-eventNames}).
```js
this.on( '@render', function( evt ) {
	alert( 'Child element is rendered' );
});
```

> The rendered HTML  node becomes a sandbox for the inserted element allowing to use the ``:sandbox`` selector and other possibilities after rendering. If the element enters a few collections at once,  set the ``bindRenderedAsSandbox: false`` property to it so as to cancel this behavior.
```js
var MyModel = Class({
	'extends': MK.Object,
	bindRenderedAsSandbox: false
	// ...
});
```


#### The experimental template engine
If you have a look at the examples of using {@link Matreshka.Array} and {@link Matreshka.Array#itemRenderer}, you can notice that all logic which is responsible for the two-way and one-way  data binding  is contained in the HTML code. It is one of the main Matreshka advantages. But when you develop a very simple collection which does not include complicated logic, lots of bindings, etc, you would like to have a shorter variant of the binding declaration. The template including the bindings can be passed to ``itemRenderer`` or that. Use the {@link Matreshka.Array#useBindingsParser} key which is set as ``true`` in order to launch templating.
```js
var MyArray = Class({
	'extends': MK.Array,
	useBindingsParser: true,
	Model: MK.Object,
	itemRenderer: '<label>\
		<input type="checkbox" checked="&#123;{isChecked}}">&#123;{text}}\
	</label>',
	constructor: function() {
		this.bindNode( 'sandbox', '.my-form' );
		this.push({
			isChecked: true,
			text: 'Be cool'
		}, {
			isChecked: false,
			text: 'Produce shitcode'
		});
	}
});

var app = new MyArray();
```
The example above is completely the same as the previous one, but it does not require to create a separate class for the Model as we do not have to catch the ``render`` event and to declare the bindings manually. <a href="http://jsbin.com/wabiyi/1/" target="_blank">The live example</a>

This approach looks attractive but it has a few features which make us recommend to avoid using the experimental template engine:
+ The template engine is an experimental possibility of Matreshka. It can be unstable in some  unaccounted cases.
+ The code speed is lower with the template engine than without it. It happens because the string analysis, the key enumerating in the cycle (while using several keys in one attribute), the substring substitution to a regular expression. etc require more resources.
+ The additional syntax is not supported. The conditions and cycles must be declared in the JavaScript code and  the addressing to the child object  is left out (i. e. such a code is not going to work: &#123;{a.b}})

On the whole, use the template engine only when the application you develop is not large and it is not performance demanding.

#### The cancellation of rendering.
As is seen from above  if the ``render`` property of the child element is specified, ``Matreshka.Array`` will try to render it. In order to completely cancel rendering for the array, assign ``renderIfPossible: false`` to the property.
```js
var MyArray = Class({
	'extends': MK.Array,
	renderIfPossible: false,
	// ...
});
```


@see {@link Matreshka#bindNode}
@see {@link Matreshka.Array#Model}
*/


/**
@method Matreshka.Array#Model
@since 0.2
@abstract
@summary Свойство определяет класс элементов, которые будет содержать коллекция
@desc При каждом добавлении элементов в массив, встроенный обработчик проверяет, является ли добавленный элемент экземпляром ``Model`` и конвертирует его в таковой, если проверка не пройдена. Это поведение очень напоминает поведение свойства ``model`` из ``Backbone.Collection``. Рекомендуется наследовать ``Model`` от класса {@link Matreshka.Object} или {@link Matreshka.Array} (на случай, если тебуется получить коллекцию коллекций), чтоб получить возможность конвертации массива в обычный массив методом {@link Matreshka.Array#toJSON}.

Для более гибкого контроля класса элементов (например, если для одних элементов нужно использовать одну Модель, а для других - другую), используйте {@link Matreshka.Array#mediateItem}.

@see {@link Matreshka.Array#mediateItem}
@see {@link Matreshka.Array#itemRenderer}

@param {object} data - Данные, переданные в конструктор
@param {matreshkaArray} mkArray - Массив, в который добавили элемент  

@example
// определяем Модель
var MyModel = Class({
	// она наследуется от MK.Object
	'extends': MK.Object,
	constructor: function( data ) {
		// устанавливаем переданные свойства методом jset
		this.jset( data );
		this.doSomething();
	},
	doSomething: function() { ... }
});

// опеределяем класс для коллекции
var MyArray = Class({
    'extends': MK.Array,
    Model: MyModel
});

// создаем экземпляр класса
var myArray = new MyArray;

// добавляем два элемента
myArray.push({
    a: 1,
    b: 2
}, {
    a: 3,
    b: 4
})

// вернет [{ a: 1, b: 2 }, { a: 3, b: 4 }]
myArray.toJSON();

*/


/**
@method Matreshka.Array#mediateItem
@since 0.1
@see {@link Matreshka.Array#Model}
@see {@link Matreshka#mediate}
@summary Трансформирует значение элемента при вставке
@desc Этот метод служит для того, чтоб установить типизацию для вставляемых элементов. Обратите внимание, метод переопределяет свойство {@link Matreshka.Array#Model}.
@example
// все элементы массива - числа
this.mediateItem( Number );
@example 
this.push( 1, 2, 3, 4, 5 );

// все элементы массива - строки
this.mediateItem( function( value ) {
	return String( value );
});

this.push( 6, 7 );

this.unshift( true, {} );

// [ "true", "[object Object]", "1", "2", "3", "4", "5", "6", "7" ]
console.log( mkArray.toJSON() );
@example <caption>Условная Модель</caption>
this.mediateItem( function( item ) {
	if( item.something ) {
		return new FirstModel( item );
	} else {
		return new SecondModel( item );
	}
});
*/


/**
@method Matreshka.Array#on
@since 0.2
@summary Работает так же, как и {@link Matreshka#on}, но дополнительно позволяет динамически навешивать обработчики на вставленные элементы.
@example
this.on( '@something', function() {
	alert( 'something happens' )
});

this.push( new MK );

this[0].trigger( 'something' );
*/ 

/**
@method Matreshka.Array#recreate
@fires recreate
@fires modify
@fires add
@fires addone
@fires remove
@fires removeone
@summary Пересоздает экземпляр {@link Matreshka.Array}
@desc Метод позволяет конвертировать любой массив (или объект, подобный массиву) в экземпляр {@link Matreshka.Array}. Если ничего не передано в качестве первого аргумента, экземпляр очищается.
@param {array} [array] - Массив
@param {eventOptions} [eventOptions] - Объект события
@returns {matreshkaArray} self
@example
// очищаем массив и добавляем 5 новых элементов
this.recreate( [1, 2, 3, 4, 5] );

// очищаем массив
this.recreate();
*/


/**
@method Matreshka.Array#toArray
@summary Конвертирует {@link Matreshka.Array} в обычный массив, но не конвертирует входящие в него элемены
@returns {array}
@example
this.toArray();
*/


/**
@method Matreshka.Array#toNative
@summary Делает то же самое, что и {@link Matreshka.Array#toArray}
@returns {array}
@example
this.toNative();
*/


/**
@method Matreshka.Array#rerender
@since 0.3
@summary Перерисовывает DOM узлы элементов, входящих в массив
@desc Этот метод, как правило, используется тогда, когда свойство {@link Matreshka.Array#itemRenderer} устанавливается после того, как элементы были добавлены в массив.
@returns {matreshkaArray} self
@example
var mkArray = new MK.Array;

// DOM не меняется, так как itemRenderer еще не определен
mkArray.push( ... );

// определяем itemRenderer
mkArray.itemRenderer = function() { '<div>MyDiv</div>' };

// DOM перерисовывается
mkArray.rerender();
*/


/**
@method Matreshka.Array#hasOwnProperty
@summary Существует ли свойство в экземпляре (индекс или свойство ``length``)
@returns {boolean}
@example
var mkArray = new MK.Array( 42 ); // создает массив длиной 42

mkArray.hasOwnProperty( 5 ); // true

mkArray.hasOwnProperty( 100500 ); // false

mkArray.hasOwnProperty( 'length' ); // true

mkArray.hasOwnProperty( 'blah' ); // false
*/


/**
@method Matreshka.Array#toJSON
@summary Конвертирует экземпляр и элементы, входящие в него в обычный массив
@returns {object}
@example
var data = this.toJSON();
*/


/**
@method Matreshka.Array#pull
@since 0.1
@fires pull
@fires remove
@fires removeone
@fires modify
@summary Удаляет элемент с заданным индексом из массива и возвращает этот элемент. Начиная с версии 0.3, метод поддерживает удаляемый элемент в качестве аргумента.
@param {string|number|*} index - Индекс элемента, который нужно удалить (число или строка) либо сам удаляемый элемент (не являющийся ни числом ни строкой)
@param {eventOptions} [evtOptions] - Объект события на случай, если нужно передать в обработчик события какие-нибудь данные или установить флаг ``silent``, предотвращающий срабатывание события
@returns {*|null} Удаленный элемент или ``null``
@example <caption>Передача индекса массива</caption>
var removed;

this.recreate( [ 'a', 'b', 'c' ] );

removed = this.pull( 1 );

alert( removed ); // 'b'

alert( this.toString() ); // 'a,c'
@example <caption>Передача удаляемого элемента</caption>
var object1 = {},
	object2 = {},
	object3 = {},
	removed;

this.push( object1, object2, object3 );

removed = this.pull( object2 );

alert( removed === object2 ); // true

alert( this.length ); // 2
*/


/**
@method Matreshka.Array#each
@summary Работает точно так же, как и метод ``forEach``, который перебирает элементы массива
@param {function} callback - Функция, запускаемая на каждой итерации
@param {*} [thisArg] - Объект, который используется в качестве ``this`` при вызове ``callback``
@returns {matreshkaArray} self
@example
this.each( function( item, index ) {
	console.log( index, item ); 
});
*/


/**
@method Matreshka.Array#METHOD
@summary Любой метод из ``Array.prototype``
@desc {@link Matreshka.Array} включает в себя все методы, входящие в нативный JavaScript массив:
<ul>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat" target="_blank">concat</a></li>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join" target="_blank">join</a></li>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/pop" target="_blank">pop</a></li>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push" target="_blank">push</a></li>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse" target="_blank">reverse</a></li>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/shift" target="_blank">shift</a></li>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" target="_blank">slice</a></li>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort" target="_blank">sort</a></li>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice" target="_blank">splice</a></li>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString"  target="_blank">toString</a></li>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift" target="_blank">unshift</a></li>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every" target="_blank">every</a></li>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" target="_blank">filter</a></li>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" target="_blank">forEach</a></li>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf">indexOf</a></li>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf" target="_blank">lastIndexOf</a></li>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank">map</a></li>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some" target="_blank">some</a></li>
</ul>
При этом, они работают точно так же, как и методы ``Array.prototype``. Есть лишь несколько оговорок:
+ Метод ``forEach`` возвращает себя вместо ``undefined``
+ Методы, которые в оригинальном виде возвращают новый массив (``splice``, ``slice``, ``filter``, ``map``...), в Матрешке возвращают новый экземпляр ``Matreshka.Array``.

Кроме всего, методы генерируют события связанные с любой модификацией массива. Подробнее см. {@link Matreshka.Array}.

@see {@link Matreshka.Array#_METHOD}
@example
this.push( 1, 2, 3 );
@example
var mapped = this
	.forEach( function( value, index ) {
		//...
	})
	.map( function( value, index ) {
		//...
	})
;
alert( mapped.isMKArray );
@example
this.reverse();
*/

/**
@method Matreshka.Array#METHOD_
@summary Любой метод из ``Array.prototype`` с возможностью передать объект события
@desc Ознакомившись с {@link Matreshka.Array#METHOD} становится понятно, что методы не поддерживают передачу объекта события, так как в точности повторяют синтаксис и количество аргументов встроенного ``Array``. Синтаксис ``МЕТОД_`` позволяет передать в обработчик события какие-нибудь данные либо установить служебные флаги, отвечающие за поведение массива после вызова метода.

Список доступных флагов:
+ ``silent: true`` - отключает генерацию событий
+ ``dontRender: true`` - отключает {@link Matreshka.Array#itemRenderer рендеринг}
+ ``skipMediator: true`` - отключает {@link Matreshka.Array#mediateItem медиаторы}


@see {@link Matreshka.Array#METHOD}
@example
this.push_( 1, 2, 3, {
    silent: true
});

this.pop_({
    silent: true
});
@example
this.on( 'modify', function( evt ) {
	alert( evt.flag ); // 42
});

this.push_( 1, 2, 3, {
	flag: 42
});
*/

