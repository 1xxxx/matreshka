<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: object.mk.js</title>
    
    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">
    
    <h1 class="page-title">Source: object.mk.js</h1>
    
    


    
    <section>
        <article>
            <pre class="prettyprint source"><code>"use strict";// tests, 
// BIG TODO: make Array.prototype default methods work in IE!
// @todo pass arguments to the methods as event property
( function( MK ) {
	if( !MK ) {
		throw Error( 'Matreshka is not defined' );
	}
	
	/**
	 * @class Matreshka.Object
	 * @classdesc Matreshka Object class. Extends {@link Matreshka}.
	 * @inherits Matreshka
	 * @example &lt;caption>Basic usage&lt;/caption>
	 * new MK.Object;
	 * @example &lt;caption>Passing object&lt;/caption>
	 * // creates Matreshka.Object instance with 2 enumerable keys (a, b)
	 * new MK.Object({ a: 1, b: 2 });
	 * // same as new MK.Object().jset({ a: 1, b: 2 });
	 * @example &lt;caption>Inheriting&lt;/caption>
	 * var MyClass = Class({
	 *	'extends': MK.Object,
	 * 	constructor: function() {
	 * 		// calls MK.Object constructor with this context and given arguments
	 * 		MyClass.parent.constructor( this, arguments );
	 *	},
	 * 	method: function() {}
	 * });
	 */
	MK.Object = Class({
		'extends': MK,
		constructor: function( object ) {
			this.initMK();
			if( object ) {
				this.jset( object );
			}
		},
		
		/**
		 * @method Matreshka.Object#keys
		 * @summary Returns an array of keys of the {@link Matreshka.Object} instance
		 * @returns {string[]} keys
		 * @example &lt;caption>Basic usage&lt;/caption>
		 * var keys = this.keys();
		 */
		keys: function() {
			var keys = [];
			for( var p in this._keys ) if( this._keys.hasOwnProperty( p ) ) {
				keys.push( p );
			}
			return keys;
		},
		
		/**
		 * @method Matreshka.Object#initMK
		 * @summary Initializes {@link Matreshka.Object} instance
		 * @returns {mkObject} self
		 * @example &lt;caption>Basic usage&lt;/caption>
		 * var MyClass = Class({
		 * 	'extends': MK.Object,
		 *  constructor: function() {
		 *  	this.initMK();
		 * 	}
		 * });
		 */
		initMK: function() {
			MK.Object.parent.initMK( this, arguments );
			
			return this
				.defineNotEnum( '_keys', {} )
				.on( 'remove', function( opts ) {
					if( !opts || !opts.silent ) {
						this.trigger( 'modify', opts );
					}
				})
				.on( 'change', function( opts ) {
					if( opts && ( opts.key in this._keys ) && !opts.silent ) {
						this.trigger( 'modify', opts );
					}
				})
			;
		},
		
		/**
		 * @method Matreshka.Object#hasOwnProperty
		 * @summary Checks is {@link Matreshka.Object} instance has own property key
		 * @param {string} key
		 * @returns {mkObject} self
		 * @example &lt;caption>Basic usage&lt;/caption>
		 * var mkObject = new MK.Object( { a: 1, b: 2 } );
		 * mkObject.hasOwnProperty( 'a' ); // true
		 * mkObject.hasOwnProperty( 'b' ); // true
		 * mkObject.hasOwnProperty( 'c' ); // false
		 */
		hasOwnProperty: function( key ) {
			return this._keys.hasOwnProperty( key );
		},
		
		/**
		 * @method Matreshka.Object#toObject
		 * @summary Converts {@link Matreshka.Object} instance to native object
		 * @returns {Object}
		 * @example &lt;caption>Basic usage&lt;/caption>
		 * var mkObject = new MK.Object( { a: 1, b: 2 } );
		 * mkObject.toObject(); // returns { a: 1, b: 2 }
		 */
		toObject: function() {
			var o = {},
				_keys = this._keys;
			for( var p in _keys ) if( _keys.hasOwnProperty( p ) ) {
				o[ p ] = this[ p ];
			}
			return o;
		},
		
		/**
		 * @method Matreshka.Object#toNative
		 * @summary Does same as {@link Matreshka.Object#toObject}
		 * @returns {Object}
		 * @example &lt;caption>Usage&lt;/caption>
		 * var mkObject = new MK.Object( { a: 1, b: 2 } );
		 * mkObject.toNative(); // returns { a: 1, b: 2 }
		 */
		toNative: function() {
			return this.toObject();
		},
		
		/**
		 * @method Matreshka.Object#toJSON
		 * @summary Converts {@link Matreshka.Object} instance to native object
		 * @desc Diferrence between &lt;code>toJSON&lt;/code> and &lt;code>toObjec&lt;/code> is that &lt;code>toJSON&lt;/code> tries to call &lt;code>toJSON&lt;/code> method for inner objects.
		 * @returns {Object}
		 * @example &lt;caption>Usage&lt;/caption>
		 * var json = this.toJSON();
		 */
		toJSON: function() {
			var JSON = {},
				_keys = this._keys;
			for( var p in _keys ) if( _keys.hasOwnProperty( p ) ) {
				JSON[ p ] = this[ p ] && this[ p ].toJSON ? this[ p ].toJSON() : this[ p ];
			}
			return JSON;
		},
		
		/**
		 * @method Matreshka.Object#keyOf
		 * @summary Gets key of given value
		 * @desc Returns first match or &lt;code>null&lt;/code> if no property found (&lt;code>Array.prototype.indexOf&lt;/code> analogue)
		 * @prop {*} o - value that we want to find
		 * @returns {(string|null)}
		 * @example &lt;caption>Usage&lt;/caption>
		 * var mkObject = new MK.Object( { a: 1, b: 2 } );
		 * mkObject.keyOf( 1 ); // 'a'
		 * mkObject.keyOf( 2 ); // 'b'
		 * mkObject.keyOf( 3 ); // null
		 */
		keyOf: function( o ) {
			var _keys = this._keys;
			for( var p in _keys ) if( _keys.hasOwnProperty( p ) ) {
				if( o === _keys[ p ] ) {
					return p;
				}
			}
			return null;
		},
		
		/**
		 * @method Matreshka.Object#jset
		 * @fires change
		 * @fires change:*key*
		 * @fires modify
		 * @variation 1
		 * @summary Sets given property and adds key to enumerable list
		 * @desc &lt;p>This is common method of {@link Matreshka.Object} insance that does two things:&lt;/p>
		 * &lt;p>1. Sets property.&lt;/p>
		 * &lt;p>2. Adds given key to enumerable list (key enumerates via {@link Matreshka.Object#each} method, includes in result object returned by {@link Matreshka.Object#toObject} and {@link Matreshka.Object#toJSON}).&lt;/p>
		 * 
		 * @param {string} key
		 * @param {*} value
		 * @param {eventOptions} [evtOpts]
		 * 
		 * @returns {mkObject} self
		 * 
		 * @example &lt;caption>Basic usage&lt;/caption>
		 * this.jset( 'a', 1 ).jset( 'b', 2 );
		 * 
		 * @example &lt;caption>{@link Matreshka.Object#each} method example&lt;/caption>
		 * this.jset( 'a', 1 ).jset( 'b', 2 );
		 * // sets 'c' to 3 but not adds keys to enumerable list
		 * this.set( 'c', 3 );
		 * this.each( function( value, key ) {
		 * 	console.log( key, value ); 
		 * });
		 * // logs 'a' 1 and 'b' 2
		 * 
		 * @example &lt;caption>{@link Matreshka.Object#keys} method example&lt;/caption>
		 * this.jset( 'a', 1 ).jset( 'b', 2 );
		 * // sets 'c' to 3 but not adds keys to enumerable list
		 * this.set( 'c', 3 );
		 * console.log( this.keys() ); // logs [ 'a', 'b' ]
		 * 
		 * @example &lt;caption>{@link Matreshka.Object#toObject} method example&lt;/caption>
		 * this.jset( 'a', 1 ).jset( 'b', 2 );
		 * // sets 'c' to 3 but not adds keys to enumerable list
		 * this.set( 'c', 3 );
		 * console.log( this.toObject() ); // logs { a: 1, b: 2 }
		 * 
		 * @example &lt;caption>After using {@link Matreshka.Object#jset} you can work with property as with regular ptoperty&lt;/caption>
		 * this.jset( 'a', 1 ).jset( 'b', 2 ); // sets properties and adds to enumerable list
		 * this.set( 'a', 3 ); 
		 * this.b = 4;
		 */
		
		/**
		 * @method Matreshka.Object#jset
		 * @variation 2
		 * @summary Uses key-value object for setting property and adding it's key to enumerable list
		 * @param {object} keyValuePairs
		 * @param {eventOptions} evtOpts
		 * 
		 * @returns {mkObject} self
		 * 
		 * @example &lt;caption>Basic usage&lt;/caption>
		 * this.jset({
		 * 	a: 1,
		 * 	b: 2
		 * });
		 * @example &lt;caption>Using &lt;code>eventOptions&lt;/code>&lt;/caption>
		 * this.jset({
		 * 	a: 1,
		 * 	b: 2
		 * }, { silent: true });
		 */
		jset: function( key, v, evtOpts ) {
			if( typeof key === 'object' ) {
				for( var i in key ) {
					this.jset( i, key[ i ], v );
				}
				return this;
			}
			
			this._keys[ key ] = 1;
			
			this.makeSpecial( key );
			
			return this.set( key, v, evtOpts );
		},
		
		/**
		 * @method Matreshka#remove
		 * @fires remove
		 * @fires remove:*key*
		 * @fires modify
		 * @summary Removes property from {@link Matreshka.Object} instance and enumerable list
		 * @param {string} key - key (or keys separated by space) that you want to remove from current instance
		 * @param {eventOptions} - [evtOptions]
		 * @returns {MKInstance} self
		 * @example &lt;caption>Basic usage&lt;/caption>
		 * this.remove( 'myKey' );
		 * this.remove( 'myKey1 myKey2' );
		 * @example &lt;caption>Using &lt;code>eventOptions&lt;/code>&lt;/caption>
		 * this.remove( 'myKey', { silent: true } );
		 */
		remove: function( key, evtOpts ) {
			this.removeJSONKeys( key );
			return MK.Object.parent.remove( this, key, evtOpts );
		},
		
		/**
		 * @method Matreshka.Object#addJSONKeys
		 * @summary Adds keys to enumerable list
		 * @desc This method is used if you want to define enumerable keys but you don't know values yet.
		 * @param {(...string|string[]|string)} keys - list of keys separated by space or array of keys or repeated string
		 * @returns {mkObject} self
		 * @example &lt;caption>Basic usage 1&lt;/caption>
		 * this.addJSONKeys( 'a b' );
		 * @example &lt;caption>Basic usage 2&lt;/caption>
		 * this.addJSONKeys( [ 'a', 'b' ] );
		 * @example &lt;caption>Basic usage 3&lt;/caption>
		 * this.addJSONKeys( 'a', 'b' );
		 * @example &lt;caption>Using {@link Matreshka.Object#each}&lt;/caption>
		 * this.addJSONKeys( 'a b' );
		 * this.each( function( value, key ) {
		 * 	console.log( key, value );
		 * });
		 * // logs 'a' undefined and 'b' undefined
		 */
		addJSONKeys: function( keys ) {
			keys = arguments.length > 1 ? arguments : keys instanceof Array ? keys : keys.split( /\s/ );
			for( var i = 0; i &lt; keys.length; i++ ) {
				this._keys[ keys[ i ] ] = 1;
				this.makeSpecial( keys[ i ] );
			}
			return this;
		},
		
		/**
		 * @method Matreshka.Object#removeJSONKeys
		 * @summary Removes keys from enumerable list (but not removes property from the instance)
		 * @desc You can remove keys from enumerable list if you no longer need them.
		 * @param {(string|string[]|...string)} keys - list of keys separated by space or array of keys or repeated string
		 * @returns {mkObject} self
		 * @example &lt;caption>Basic usage 1&lt;/caption>
		 * this.removeJSONKeys( 'a b' );
		 * @example &lt;caption>Basic usage 2&lt;/caption>
		 * this.removeJSONKeys( [ 'a', 'b' ] );
		 * @example &lt;caption>Basic usage 3&lt;/caption>
		 * this.removeJSONKeys( 'a', 'b' );
		 */
		removeJSONKeys: function( keys ) {
			keys = arguments.length > 1 ? arguments : keys instanceof Array ? keys : keys.split( /\s/ );
			for( var i = 0; i &lt; keys.length; i++ ) {
				delete this._keys[ keys[ i ] ];
			}
			return this;
		},
		
		/**
		 * @method Matreshka.Object#each
		 * @summary Iterates enumerable properties
		 * @param {function} callback
		 * @param {*} [thisArg] - the context of callback
		 * @returns {mkObject} self
		 * @example &lt;caption>Usage&lt;/caption>
		 * this.each( function() {
		 * 	... 
		 * }, this );
		 */
		each: function( callback, thisArg ) {
			for( var p in this._keys ) if( this._keys.hasOwnProperty( p ) ) {
				callback.call( thisArg, this[ p ], p, this );
			}
			
			return this;
		}
	});
	
/**
 * {@link Matreshka.Object} instance
 * @typedef {object} mkObject
 */
})( window.Matreshka );</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Classes</h3><ul><li><a href="Matreshka.html">Matreshka</a></li><li><a href="Matreshka.Array.html">Array</a></li><li><a href="Matreshka.Object.html">Object</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-dev</a> on Thu Sep 26 2013 22:02:48 GMT+0300 (EEST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
